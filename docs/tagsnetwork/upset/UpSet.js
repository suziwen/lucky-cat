(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["UpSet"] = factory();
	else
		root["UpSet"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(5);
	__webpack_require__(7);
	
	__webpack_require__(9);
	__webpack_require__(12);
	__webpack_require__(14);
	__webpack_require__(16);
	__webpack_require__(18);
	__webpack_require__(20);
	__webpack_require__(22);
	__webpack_require__(24);
	__webpack_require__(26);
	__webpack_require__(28);
	__webpack_require__(30);
	__webpack_require__(32);
	__webpack_require__(34);
	__webpack_require__(36);
	__webpack_require__(38);
	__webpack_require__(40);
	__webpack_require__(42);
	__webpack_require__(44);
	__webpack_require__(46);
	__webpack_require__(48);
	__webpack_require__(50);
	__webpack_require__(52);
	__webpack_require__(54);
	__webpack_require__(56);
	__webpack_require__(58);
	__webpack_require__(60);
	__webpack_require__(62);
	
	module.exports = {
	  githubDataLoading: window.githubDataLoading,
	  dataLoading: window.localDataLoading,
	  UpSet: window.UpSet,
	  Ui: window.Ui
	};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/index.js!./html_styles.scss", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/index.js!./html_styles.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/**\n* Styles for pure html layout\n*/\n.upset-body {\n  background: white;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 0;\n  padding: 0; }\n\n.upset-body {\n  /** ============ Configuration Panel Left ============== */ }\n  .upset-body a:link,\n  .upset-body a:visited {\n    color: black; }\n  .upset-body .upset-body h1 {\n    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; }\n  .upset-body .header-label-left {\n    margin-right: 5px;\n    float: left;\n    color: white; }\n  .upset-body #data-loading-indicator {\n    padding-left: 5px;\n    padding-right: 5px; }\n  .upset-body .header, .upset-body .header-right, .upset-body .header-right-clickable {\n    color: white;\n    font-weight: bold; }\n    .upset-body .header a:visited, .upset-body .header-right a:visited, .upset-body .header-right-clickable a:visited,\n    .upset-body .header a:link, .upset-body .header-right a:link, .upset-body .header-right-clickable a:link {\n      color: white;\n      text-decoration: none; }\n  .upset-body .header-right, .upset-body .header-right-clickable {\n    float: right;\n    padding-right: 10px; }\n  .upset-body .header-right-clickable {\n    cursor: pointer; }\n  .upset-body #header-ds-selector {\n    float: right;\n    color: black; }\n  .upset-body .button-panel {\n    display: inline-block;\n    margin-left: 10px;\n    margin-right: 5px; }\n  .upset-body .header-container {\n    padding-top: 5px;\n    padding-bottom: 5px;\n    padding-left: 10px;\n    padding-right: 10px;\n    background: #000;\n    border-bottom: 2px solid #999;\n    display: block;\n    height: 20px;\n    color: #666; }\n  .upset-body .menu-container {\n    padding: 5px 10px;\n    background: #eee;\n    border-bottom: 2px solid #999;\n    display: block;\n    height: 20px;\n    text-align: right;\n    font-size: 0.8em;\n    font-style: italic; }\n  .upset-body .padded-container {\n    padding: 20px 20px 10px; }\n  .upset-body html, .upset-body body, .upset-body .ui-container {\n    height: 100%; }\n  .upset-body .ui-container {\n    width: 100%;\n    padding-left: 10px;\n    min-height: 100%;\n    height: 100VH;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box; }\n  .upset-body .ui-fader {\n    position: absolute;\n    /* makes the div go into a position that’s absolute to the browser viewing area */\n    background-color: white;\n    width: 100%;\n    height: 100%;\n    z-index: 90;\n    /* makes the div the second most top layer, so it’ll lay on top of everything else EXCEPT for divs with a higher z-index (meaning the #overlay ruleset) */ }\n  .upset-body .ui-overlay-loading {\n    display: block;\n    /* ensures it’s invisible until it’s called */\n    position: absolute;\n    /* makes the div go into a position that’s absolute to the browser viewing area */\n    left: 50%;\n    /* positions the div half way horizontally */\n    top: 50%;\n    /* positions the div half way vertically */\n    padding: 25px;\n    z-index: 100;\n    /* makes the div the top layer, so it’ll lay on top of the other content */\n    color: white; }\n  .upset-body .ui-header {\n    height: 30px; }\n  .upset-body .ui-menu {\n    height: 50px; }\n  .upset-body .ui-row {\n    height: 100%;\n    display: flex;\n    align-items: stretch; }\n  .upset-body .ui-column {\n    box-sizing: border-box;\n    vertical-align: top;\n    padding-top: 10px;\n    overflow-y: auto; }\n  .upset-body .ui-column.ui-column-15 {\n    width: 15%;\n    min-width: 180px; }\n  .upset-body .ui-column.ui-column-25 {\n    width: 25%; }\n  .upset-body .ui-column.ui-column-50 {\n    width: 50%; }\n  .upset-body .ui-column.ui-column-60 {\n    width: 60%; }\n  .upset-body .ui-column.ui-column-75 {\n    background: yellow;\n    width: 75%;\n    min-width: 75%; }\n  .upset-body .ui-column.ui-column-100 {\n    width: 100%; }\n  .upset-body .ui-column.ui-column-33 {\n    background: pink;\n    width: 33%; }\n  .upset-body .ui-column.ui-column-66 {\n    background: lightpurple;\n    width: 66%;\n    min-width: 66%; }\n  .upset-body .ui-column.ui-layout-center {\n    position: relative;\n    flex: 1;\n    overflow: hidden; }\n  .upset-body .ui-column.ui-layout-west {\n    max-width: 250px;\n    margin-right: 10px; }\n  .upset-body .ui-column.ui-layout-east {\n    overflow-y: auto;\n    overflow-x: hidden;\n    border-left: 1px solid #999;\n    padding: 0; }\n  .upset-body .element-infos-container {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    width: 100%; }\n  .upset-body .query-result-container {\n    flex: 1;\n    overflow: hidden;\n    display: flex;\n    flex-direction: column; }\n  .upset-body .configTable, .upset-body #dataset-info-viewer {\n    padding-bottom: 10px;\n    font-size: 12px;\n    display: inline-block;\n    float: left;\n    clear: both; }\n  .upset-body .configHeader {\n    font-weight: bold;\n    padding-bottom: .2em; }\n  .upset-body .configH1 {\n    font-weight: bold; }\n  .upset-body #dataset-info-viewer {\n    color: white;\n    background-color: #636363;\n    padding: .4em; }\n    .upset-body #dataset-info-viewer a:link,\n    .upset-body #dataset-info-viewer a:visited {\n      color: white; }\n", ""]);
	
	// exports


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(6);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/index.js!./set_view.scss", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/index.js!./set_view.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "/**\n * SVG styles for the set view.\n * Currently still a mess of various things\n */\n.upset-body {\n  /** The set size bar */\n  /** The subSet size bar */\n  /** The labels for the vertical set names */\n  /*.cell, .what, .setSize, .disproportionality, .subSetSize, .groupBackGround {*/\n  /*stroke: #fff;*/\n  /*stroke-width: .5;*/\n  /*}*/\n  /* ---------------- The set selector --------------- */\n  /* ---------------- tables --------------- */\n  /*--- logic --*/\n  /** === Filter Controls === */\n  /** ==== for range slider == **/\n  /*.groupingSelect{*/\n  /*position: relative;*/\n  /*left:-6px;*/\n  /*}*/\n  /*.groupBackGround .filterGroup{*/\n  /*fill: #d3d3d3;;  */\n  /*logic Color*/\n  /**/\n  /*}*/ }\n  .upset-body .axis path,\n  .upset-body .axis line {\n    fill: none;\n    stroke: gray;\n    shape-rendering: crispEdges; }\n  .upset-body .axis text {\n    font-size: 0.6em; }\n  .upset-body .setSize {\n    /*fill: #bbb0fb;*/\n    fill: #636363;\n    stroke: white;\n    stroke-width: 1px; }\n  .upset-body .unusedSetSize {\n    fill: lightgray;\n    stroke: white;\n    stroke-width: 1px; }\n  .upset-body .setSizeBackground, .upset-body .unusedSetSizeBackground {\n    fill: #f0f0f0;\n    stroke: white;\n    stroke-width: 1px; }\n  .upset-body .setSizeBackground:hover {\n    stroke: white;\n    shape-rendering: crispEdges; }\n  .upset-body .subSetSize.row-type-subset {\n    fill: #737373; }\n  .upset-body .subSetSize.row-type-group {\n    fill: #535353; }\n  .upset-body .setLabel, .upset-body .connection {\n    /*dominant-baseline: middle;*/\n    font: 12px sans-serif;\n    cursor: pointer;\n    font-weight: 300;\n    /*alignment-baseline:middle;*/\n    /*alignment-baseline:middle;*/\n    /* writing-mode: bt-lr;*/ }\n  .upset-body .setRow .setLabel {\n    font-weight: 500; }\n  .upset-body .setLabel.small {\n    dominant-baseline: middle;\n    font: 9px sans-serif;\n    cursor: s-resize; }\n  .upset-body .configTable {\n    float: left; }\n  .upset-body .groupLabel {\n    /*dominant-baseline: central;*/\n    font: sans-serif;\n    text-anchor: left;\n    cursor: s-resize;\n    font-size: 10pt;\n    font-weight: 200; }\n  .upset-body .groupLabel.small {\n    /*dominant-baseline: central;*/\n    font: sans-serif;\n    /*font-weight:bold;*/\n    text-anchor: left;\n    cursor: s-resize;\n    font-size: 8pt; }\n  .upset-body .intersectionSizeLabel {\n    /*dominant-baseline: central;*/\n    font: sans-serif;\n    text-anchor: left;\n    font-size: 8pt;\n    dominant-baseline: middle; }\n  .upset-body .columnLabel, .upset-body .axis .columnLabel {\n    dominant-baseline: central;\n    font: 13px sans-serif;\n    text-anchor: middle;\n    cursor: s-resize; }\n  .upset-body .addButton {\n    dominant-baseline: central;\n    font: 13px sans-serif;\n    text-anchor: middle;\n    cursor: row-resize; }\n  .upset-body .groupBackGround {\n    /*stroke: #d3d3d3;*/\n    stroke: #555555;\n    stroke-width: 1px;\n    fill: #cccccc;\n    opacity: .3; }\n  .upset-body .groupBackGround.secondLevel {\n    stroke: #aaaaaa; }\n  .upset-body .labelBackground {\n    fill: #d3d3d3; }\n  .upset-body .labelBackground:hover {\n    fill: rgba(145, 145, 145, 0.88);\n    cursor: s-resize; }\n  .upset-body .setBackground {\n    fill: #d3d3d3;\n    stroke-width: 1;\n    fill: white; }\n  .upset-body .disproportionality.positive {\n    fill: #74add1; }\n  .upset-body .disproportionality.negative {\n    fill: #f46d43; }\n  .upset-body .connection {\n    stroke: white;\n    stroke-width: 1;\n    fill: #f0f0f0; }\n  .upset-body #setSelect {\n    float: left;\n    padding-right: 10px; }\n  .upset-body td {\n    padding-left: 2px;\n    padding-right: 2px; }\n  .upset-body tr:nth-child(even) {\n    background-color: #eee; }\n  .upset-body th {\n    text-align: left;\n    padding-left: 2px;\n    padding-right: 2px;\n    cursor: s-resize; }\n  .upset-body th.attribute-header {\n    background-color: lightgray; }\n  .upset-body th.attribute-header.selected {\n    background-color: yellow; }\n  .upset-body #selection-tabs {\n    border-bottom: 1px dotted #bbb;\n    padding-bottom: 3px;\n    margin-bottom: 3px; }\n  .upset-body .selection-tab-list {\n    display: inline-block;\n    min-height: 30px;\n    margin-left: 5px; }\n  .upset-body .selection-tab {\n    cursor: pointer;\n    background-color: #eee;\n    border-radius: 5px;\n    padding: 4px;\n    margin-right: 4px; }\n  .upset-body .selection-tab.active {\n    background-color: #ccc; }\n  .upset-body .selection-button {\n    cursor: pointer;\n    background-color: #eee;\n    border-radius: 5px;\n    padding: 4px;\n    margin-right: 4px;\n    display: inline-block; }\n  .upset-body .selection-button:hover {\n    background-color: #ccc; }\n  .upset-body .filter-button {\n    cursor: default;\n    color: #2b8cbe;\n    fill: #2b8cbe;\n    /*should be the same as \"color\" -- for svg and html*/ }\n  .upset-body .filter-button:hover {\n    color: darkblue; }\n  .upset-body #venn-diagram-viewer {\n    display: block;\n    position: absolute;\n    right: 0;\n    top: 0;\n    opacity: 0.7;\n    transition: opacity 1s;\n    pointer-events: none; }\n  .upset-body #venn-diagram-handle {\n    position: absolute;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    width: 50px;\n    background: transparent;\n    pointer-events: initial; }\n  .upset-body #venn-diagram-viewer:hover {\n    opacity: 1; }\n  .upset-body .venn-zero-set-area {\n    fill: #eee; }\n  .upset-body .venn-one-set-area {\n    fill: #ccc; }\n  .upset-body .venn-two-set-area {\n    fill: #aaa; }\n  .upset-body .venn-three-set-area {\n    fill: #999; }\n  .upset-body .venn-zero-set-area-active {\n    fill: #faa; }\n  .upset-body .venn-one-set-area-active {\n    fill: #f99; }\n  .upset-body .venn-two-set-area-active {\n    fill: #f66; }\n  .upset-body .venn-three-set-area-active {\n    fill: #f33; }\n  .upset-body .logicPanelCircle {\n    stroke-width: 2pt; }\n  .upset-body .logicPanelHeaderCircle {\n    stroke-width: 1pt; }\n  .upset-body #dataset-selector {\n    float: right; }\n  .upset-body .ui-button {\n    color: #666; }\n  .upset-body .ui-button:hover {\n    color: #136382;\n    text-shadow: 0 0 10px #3fa0c7; }\n  .upset-body .fixed-y-container {\n    overflow-y: auto; }\n  .upset-body #set-vis-container {\n    height: 100%; }\n  .upset-body #item-vis-container {\n    min-height: 200px;\n    max-height: 400px; }\n  .upset-body #item-table-container {\n    font-size: 14px;\n    flex: 1; }\n  .upset-body #item-table {\n    border-bottom: 1px dotted #bbb;\n    padding-bottom: 2px; }\n  .upset-body #item-table thead {\n    position: sticky;\n    top: 0;\n    left: 0;\n    background: white; }\n  .upset-body .item-table-header {\n    padding-top: 3px;\n    padding-bottom: 3px;\n    padding-left: 5px;\n    padding-right: 5px;\n    font-size: 10pt;\n    font-weight: bold; }\n  .upset-body #item-table {\n    counter-reset: itemtable; }\n  .upset-body .table-element-item > td:first-child:before {\n    counter-increment: itemtable;\n    content: counter(itemtable, decimal-leading-zero) \". \";\n    color: gray; }\n  .upset-body .table-element-item:hover {\n    background: #dddbdb;\n    cursor: pointer; }\n  .upset-body * {\n    margin: 0;\n    padding: 0; }\n  .upset-body .level-1-button {\n    cursor: default;\n    display: inline-block;\n    font-weight: bold;\n    background-color: #ccc;\n    color: #444;\n    border-radius: 10px;\n    margin-left: 3px;\n    margin-right: 3px;\n    margin-top: 1px;\n    margin-bottom: 1px;\n    padding-left: 8px;\n    padding-right: 8px;\n    padding-top: 1px;\n    padding-bottom: 1px; }\n  .upset-body .level-1-button:hover {\n    background-color: #aaa;\n    color: #444; }\n  .upset-body .level-2-button {\n    cursor: default;\n    display: inline-block;\n    color: #444;\n    margin-left: 2px;\n    margin-right: 2px;\n    margin-top: 1px;\n    margin-bottom: 1px;\n    padding-left: 2px;\n    padding-right: 2px;\n    padding-top: 1px;\n    padding-bottom: 1px; }\n  .upset-body .level-2-button:hover {\n    color: #111; }\n  .upset-body .info-message {\n    display: block;\n    background-color: #eee;\n    color: #444;\n    margin-top: 2px;\n    margin-bottom: 2px;\n    padding: 3px;\n    font-style: italic; }\n  .upset-body .element-viewer-header {\n    display: inline; }\n  .upset-body .element-viewer-title {\n    display: inline; }\n  .upset-body .element-viewer-editor-button {\n    display: inline-block; }\n  .upset-body .element-viewer-editor-button:hover {\n    /*text-shadow: 0 0 10px #3fa0c7*/ }\n  .upset-body .element-viewer-active {\n    margin-top: 5px;\n    border-bottom: 1px dotted #bbb;\n    padding-bottom: 3px;\n    margin-bottom: 5px; }\n  .upset-body #element-viewer-selector {\n    display: inline;\n    float: none; }\n  .upset-body #filters-container {\n    display: block; }\n  .upset-body .filter-header {\n    display: inline; }\n  .upset-body .filter-title {\n    display: inline; }\n  .upset-body .filter-editor-button {\n    display: inline-block; }\n  .upset-body .filter-active {\n    background-color: white;\n    border: 1px dashed lightgray;\n    padding: 5px;\n    margin-top: 5px;\n    margin-bottom: 5px; }\n  .upset-body .filter-parameter-viewer {\n    font-size: 10pt; }\n  .upset-body .filter-viewer:not(:first-child) {\n    border-top: 1px dotted #bbb; }\n  .upset-body .filter-viewer {\n    padding-bottom: 3px;\n    margin-bottom: 1px; }\n  .upset-body #filter-selector {\n    display: inline;\n    margin-left: 5px; }\n  .upset-body #filters-list {\n    border-bottom: 1px dotted #bbb;\n    padding-bottom: 2px;\n    padding-left: 5px; }\n  .upset-body .filter-editor:not(:first-child) {\n    border-top: 1px dotted #bbb; }\n  .upset-body .filter-editor {\n    padding-bottom: 3px;\n    margin-bottom: 1px; }\n  .upset-body #filters-controls {\n    padding-top: 5px; }\n  .upset-body .element-view-header {\n    border-bottom: 1px solid #636363;\n    margin-bottom: 3px;\n    padding-left: 5px; }\n  .upset-body .element-view-title {\n    display: inline;\n    background-color: #636363;\n    color: white;\n    padding: 2px 5px 1px 5px;\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px;\n    margin-bottom: 0px;\n    font-weight: bold;\n    font-size: 10pt; }\n  .upset-body .element-view-subtitle {\n    display: inline;\n    color: #636363;\n    padding: 1px 3px 1px 3px;\n    margin-bottom: 0px;\n    font-weight: bold;\n    font-size: 10pt; }\n  .upset-body .drawBrush, .upset-body path.connectionArea {\n    fill: gray;\n    opacity: 0.2;\n    stroke: none; }\n  .upset-body .sliderLabel rect {\n    opacity: .5;\n    fill: #a6bddb; }\n  .upset-body .sliderLabel line {\n    opacity: .5;\n    stroke: #a6bddb;\n    stroke-width: 2; }\n  .upset-body .sliderLabel text {\n    opacity: 1;\n    font: 10px sans-serif;\n    fill: black;\n    text-anchor: middle; }\n  .upset-body .groupLabelText {\n    cursor: pointer; }\n  .upset-body .collapseIcon, .upset-body .groupDeleteIcon {\n    font-family: FontAwesome;\n    font-size: 12px;\n    cursor: pointer;\n    text-anchor: middle;\n    /*dominant-baseline: ;*/ }\n  .upset-body #moveHandle {\n    cursor: pointer;\n    position: absolute;\n    cursor: ew-resize;\n    width: 1px;\n    height: 100%; }\n  .upset-body .boxPlot {\n    stroke-width: 1px;\n    stroke: black;\n    fill: lightgray;\n    shape-rendering: crispEdges; }\n  .upset-body .logicButton {\n    font-family: FontAwesome;\n    font-size: 12px;\n    cursor: pointer;\n    text-anchor: middle;\n    dominant-baseline: central; }\n  .upset-body .gSeparatorLine {\n    stroke: darkgrey;\n    stroke-width: 3; }\n  .upset-body #bodyVis, .upset-body #headerVis {\n    display: block;\n    overflow-y: auto;\n    overflow-x: hidden; }\n  .upset-body .matrixTableContainer {\n    display: block;\n    overflow-y: hidden;\n    overflow-x: scroll; }\n  .upset-body .setSelectionArea {\n    fill: lightgrey;\n    stroke: none; }\n  .upset-body .setSelectionButton {\n    fill: lightgrey;\n    stroke: none; }\n  .upset-body .setSelectionButton:hover {\n    fill: darkgray; }\n  .upset-body .pagination, .upset-body .setMenuExtra {\n    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    font-size: 12px;\n    cursor: pointer;\n    font-weight: 300; }\n  .upset-body .setSelectionButtonText {\n    fill: #444;\n    font-weight: bold; }\n  .upset-body .setMenuExtraAwesome {\n    font-family: FontAwesome; }\n  .upset-body .setSelectionLabelAwesome {\n    font-family: FontAwesome;\n    font-size: 14px;\n    fill: lightgrey;\n    cursor: pointer;\n    font-weight: 300; }\n  .upset-body .setSelectionLabelAwesome:hover {\n    fill: darkgrey; }\n", ""]);
	
	// exports


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(8);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/index.js!./element_view.scss", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/index.js!./element_view.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, ".upset-body .subset-state-toggle-button {\n  cursor: default; }\n\n.upset-body .subset-state-toggle-button .fw {\n  color: #636363; }\n\n.upset-body .subset-state-toggle-button:hover .fw {\n  color: #000; }\n", ""]);
	
	// exports


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(11))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	module.exports = "/**\n * author: Nils Gehlenborg - nils@hms.harvard.edu\n*/\n\n/** basic event bus (http://stackoverflow.com/questions/2967332/jquery-plugin-for-event-driven-architecture) */\nvar EventManager = {};\n\n/** how to use:\n\n $(EventManager).bind(\"tabClicked\", function() {\n    // do something\n});\n\n $(EventManager).trigger(\"tabClicked\");\n\n $(EventManager).unbind(\"tabClicked\");\n\n */\n"

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(13))

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	module.exports = "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-transition')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-transition'], factory) :\n    (factory((global.venn = {}),global.d3,global.d3));\n}(this, (function (exports,d3Selection,d3Transition) { 'use strict';\n\n    var SMALL = 1e-10;\n\n    /** Returns the intersection area of a bunch of circles (where each circle\n     is an object having an x,y and radius property) */\n    function intersectionArea(circles, stats) {\n        // get all the intersection points of the circles\n        var intersectionPoints = getIntersectionPoints(circles);\n\n        // filter out points that aren't included in all the circles\n        var innerPoints = intersectionPoints.filter(function (p) {\n            return containedInCircles(p, circles);\n        });\n\n        var arcArea = 0, polygonArea = 0, arcs = [], i;\n\n        // if we have intersection points that are within all the circles,\n        // then figure out the area contained by them\n        if (innerPoints.length > 1) {\n            // sort the points by angle from the center of the polygon, which lets\n            // us just iterate over points to get the edges\n            var center = getCenter(innerPoints);\n            for (i = 0; i < innerPoints.length; ++i ) {\n                var p = innerPoints[i];\n                p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n            }\n            innerPoints.sort(function(a,b) { return b.angle - a.angle;});\n\n            // iterate over all points, get arc between the points\n            // and update the areas\n            var p2 = innerPoints[innerPoints.length - 1];\n            for (i = 0; i < innerPoints.length; ++i) {\n                var p1 = innerPoints[i];\n\n                // polygon area updates easily ...\n                polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n                // updating the arc area is a little more involved\n                var midPoint = {x : (p1.x + p2.x) / 2,\n                                y : (p1.y + p2.y) / 2},\n                    arc = null;\n\n                for (var j = 0; j < p1.parentIndex.length; ++j) {\n                    if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n                        // figure out the angle halfway between the two points\n                        // on the current circle\n                        var circle = circles[p1.parentIndex[j]],\n                            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n                            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n                        var angleDiff = (a2 - a1);\n                        if (angleDiff < 0) {\n                            angleDiff += 2*Math.PI;\n                        }\n\n                        // and use that angle to figure out the width of the\n                        // arc\n                        var a = a2 - angleDiff/2,\n                            width = distance(midPoint, {\n                                x : circle.x + circle.radius * Math.sin(a),\n                                y : circle.y + circle.radius * Math.cos(a)\n                            });\n\n                        // clamp the width to the largest is can actually be\n                        // (sometimes slightly overflows because of FP errors)\n                        if (width > circle.radius * 2) {\n                            width = circle.radius * 2;\n                        }\n\n                        // pick the circle whose arc has the smallest width\n                        if ((arc === null) || (arc.width > width)) {\n                            arc = { circle : circle,\n                                    width : width,\n                                    p1 : p1,\n                                    p2 : p2};\n                        }\n                    }\n                }\n\n                if (arc !== null) {\n                    arcs.push(arc);\n                    arcArea += circleArea(arc.circle.radius, arc.width);\n                    p2 = p1;\n                }\n            }\n        } else {\n            // no intersection points, is either disjoint - or is completely\n            // overlapped. figure out which by examining the smallest circle\n            var smallest = circles[0];\n            for (i = 1; i < circles.length; ++i) {\n                if (circles[i].radius < smallest.radius) {\n                    smallest = circles[i];\n                }\n            }\n\n            // make sure the smallest circle is completely contained in all\n            // the other circles\n            var disjoint = false;\n            for (i = 0; i < circles.length; ++i) {\n                if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n                    disjoint = true;\n                    break;\n                }\n            }\n\n            if (disjoint) {\n                arcArea = polygonArea = 0;\n\n            } else {\n                arcArea = smallest.radius * smallest.radius * Math.PI;\n                arcs.push({circle : smallest,\n                           p1: { x: smallest.x,        y : smallest.y + smallest.radius},\n                           p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},\n                           width : smallest.radius * 2 });\n            }\n        }\n\n        polygonArea /= 2;\n        if (stats) {\n            stats.area = arcArea + polygonArea;\n            stats.arcArea = arcArea;\n            stats.polygonArea = polygonArea;\n            stats.arcs = arcs;\n            stats.innerPoints = innerPoints;\n            stats.intersectionPoints = intersectionPoints;\n        }\n\n        return arcArea + polygonArea;\n    }\n\n    /** returns whether a point is contained by all of a list of circles */\n    function containedInCircles(point, circles) {\n        for (var i = 0; i < circles.length; ++i) {\n            if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** Gets all intersection points between a bunch of circles */\n    function getIntersectionPoints(circles) {\n        var ret = [];\n        for (var i = 0; i < circles.length; ++i) {\n            for (var j = i + 1; j < circles.length; ++j) {\n                var intersect = circleCircleIntersection(circles[i],\n                                                              circles[j]);\n                for (var k = 0; k < intersect.length; ++k) {\n                    var p = intersect[k];\n                    p.parentIndex = [i,j];\n                    ret.push(p);\n                }\n            }\n        }\n        return ret;\n    }\n\n    /** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\n    function circleArea(r, width) {\n        return r * r * Math.acos(1 - width/r) - (r - width) * Math.sqrt(width * (2 * r - width));\n    }\n\n    /** euclidean distance between two points */\n    function distance(p1, p2) {\n        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +\n                         (p1.y - p2.y) * (p1.y - p2.y));\n    }\n\n\n    /** Returns the overlap area of two circles of radius r1 and r2 - that\n    have their centers separated by distance d. Simpler faster\n    circle intersection for only two circles */\n    function circleOverlap(r1, r2, d) {\n        // no overlap\n        if (d >= r1 + r2) {\n            return 0;\n        }\n\n        // completely overlapped\n        if (d <= Math.abs(r1 - r2)) {\n            return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n        }\n\n        var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n            w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n        return circleArea(r1, w1) + circleArea(r2, w2);\n    }\n\n    /** Given two circles (containing a x/y/radius attributes),\n    returns the intersecting points if possible.\n    note: doesn't handle cases where there are infinitely many\n    intersection points (circles are equivalent):, or only one intersection point*/\n    function circleCircleIntersection(p1, p2) {\n        var d = distance(p1, p2),\n            r1 = p1.radius,\n            r2 = p2.radius;\n\n        // if to far away, or self contained - can't be done\n        if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {\n            return [];\n        }\n\n        var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n            h = Math.sqrt(r1 * r1 - a * a),\n            x0 = p1.x + a * (p2.x - p1.x) / d,\n            y0 = p1.y + a * (p2.y - p1.y) / d,\n            rx = -(p2.y - p1.y) * (h / d),\n            ry = -(p2.x - p1.x) * (h / d);\n\n        return [{x: x0 + rx, y : y0 - ry },\n                {x: x0 - rx, y : y0 + ry }];\n    }\n\n    /** Returns the center of a bunch of points */\n    function getCenter(points) {\n        var center = {x: 0, y: 0};\n        for (var i =0; i < points.length; ++i ) {\n            center.x += points[i].x;\n            center.y += points[i].y;\n        }\n        center.x /= points.length;\n        center.y /= points.length;\n        return center;\n    }\n\n    /** finds the zeros of a function, given two starting points (which must\n     * have opposite signs */\n    function bisect(f, a, b, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || 100,\n            tolerance = parameters.tolerance || 1e-10,\n            fA = f(a),\n            fB = f(b),\n            delta = b - a;\n\n        if (fA * fB > 0) {\n            throw \"Initial bisect points must have opposite signs\";\n        }\n\n        if (fA === 0) return a;\n        if (fB === 0) return b;\n\n        for (var i = 0; i < maxIterations; ++i) {\n            delta /= 2;\n            var mid = a + delta,\n                fMid = f(mid);\n\n            if (fMid * fA >= 0) {\n                a = mid;\n            }\n\n            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n                return mid;\n            }\n        }\n        return a + delta;\n    }\n\n    // need some basic operations on vectors, rather than adding a dependency,\n    // just define here\n    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\n    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\n    function dot(a, b) {\n        var ret = 0;\n        for (var i = 0; i < a.length; ++i) {\n            ret += a[i] * b[i];\n        }\n        return ret;\n    }\n\n    function norm2(a)  {\n        return Math.sqrt(dot(a, a));\n    }\n\n    function scale(ret, value, c) {\n        for (var i = 0; i < value.length; ++i) {\n            ret[i] = value[i] * c;\n        }\n    }\n\n    function weightedSum(ret, w1, v1, w2, v2) {\n        for (var j = 0; j < ret.length; ++j) {\n            ret[j] = w1 * v1[j] + w2 * v2[j];\n        }\n    }\n\n    /** minimizes a function using the downhill simplex method */\n    function nelderMead(f, x0, parameters) {\n        parameters = parameters || {};\n\n        var maxIterations = parameters.maxIterations || x0.length * 200,\n            nonZeroDelta = parameters.nonZeroDelta || 1.05,\n            zeroDelta = parameters.zeroDelta || 0.001,\n            minErrorDelta = parameters.minErrorDelta || 1e-6,\n            minTolerance = parameters.minErrorDelta || 1e-5,\n            rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n            chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n            maxDiff;\n\n        // initialize simplex.\n        var N = x0.length,\n            simplex = new Array(N + 1);\n        simplex[0] = x0;\n        simplex[0].fx = f(x0);\n        simplex[0].id = 0;\n        for (var i = 0; i < N; ++i) {\n            var point = x0.slice();\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n            simplex[i+1] = point;\n            simplex[i+1].fx = f(point);\n            simplex[i+1].id = i+1;\n        }\n\n        function updateSimplex(value) {\n            for (var i = 0; i < value.length; i++) {\n                simplex[N][i] = value[i];\n            }\n            simplex[N].fx = value.fx;\n        }\n\n        var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n        var centroid = x0.slice(),\n            reflected = x0.slice(),\n            contracted = x0.slice(),\n            expanded = x0.slice();\n\n        for (var iteration = 0; iteration < maxIterations; ++iteration) {\n            simplex.sort(sortOrder);\n\n            if (parameters.history) {\n                // copy the simplex (since later iterations will mutate) and\n                // sort it to have a consistent order between iterations\n                var sortedSimplex = simplex.map(function (x) {\n                    var state = x.slice();\n                    state.fx = x.fx;\n                    state.id = x.id;\n                    return state;\n                });\n                sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n                parameters.history.push({x: simplex[0].slice(),\n                                         fx: simplex[0].fx,\n                                         simplex: sortedSimplex});\n            }\n\n            maxDiff = 0;\n            for (i = 0; i < N; ++i) {\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n            }\n\n            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n                (maxDiff < minTolerance)) {\n                break;\n            }\n\n            // compute the centroid of all but the worst point in the simplex\n            for (i = 0; i < N; ++i) {\n                centroid[i] = 0;\n                for (var j = 0; j < N; ++j) {\n                    centroid[i] += simplex[j][i];\n                }\n                centroid[i] /= N;\n            }\n\n            // reflect the worst point past the centroid  and compute loss at reflected\n            // point\n            var worst = simplex[N];\n            weightedSum(reflected, 1+rho, centroid, -rho, worst);\n            reflected.fx = f(reflected);\n\n            // if the reflected point is the best seen, then possibly expand\n            if (reflected.fx < simplex[0].fx) {\n                weightedSum(expanded, 1+chi, centroid, -chi, worst);\n                expanded.fx = f(expanded);\n                if (expanded.fx < reflected.fx) {\n                    updateSimplex(expanded);\n                }  else {\n                    updateSimplex(reflected);\n                }\n            }\n\n            // if the reflected point is worse than the second worst, we need to\n            // contract\n            else if (reflected.fx >= simplex[N-1].fx) {\n                var shouldReduce = false;\n\n                if (reflected.fx > worst.fx) {\n                    // do an inside contraction\n                    weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < worst.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                } else {\n                    // do an outside contraction\n                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < reflected.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                }\n\n                if (shouldReduce) {\n                    // if we don't contract here, we're done\n                    if (sigma >= 1) break;\n\n                    // do a reduction\n                    for (i = 1; i < simplex.length; ++i) {\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                        simplex[i].fx = f(simplex[i]);\n                    }\n                }\n            } else {\n                updateSimplex(reflected);\n            }\n        }\n\n        simplex.sort(sortOrder);\n        return {fx : simplex[0].fx,\n                x : simplex[0]};\n    }\n\n    /// searches along line 'pk' for a point that satifies the wolfe conditions\n    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n    /// f : objective function\n    /// pk : search direction\n    /// current: object containing current gradient/loss\n    /// next: output: contains next gradient/loss\n    /// returns a: step size taken\n    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n            phi = phi0, phi_old = phi0,\n            phiPrime = phiPrime0,\n            a0 = 0;\n\n        a = a || 1;\n        c1 = c1 || 1e-6;\n        c2 = c2 || 0.1;\n\n        function zoom(a_lo, a_high, phi_lo) {\n            for (var iteration = 0; iteration < 16; ++iteration) {\n                a = (a_lo + a_high)/2;\n                weightedSum(next.x, 1.0, current.x, a, pk);\n                phi = next.fx = f(next.x, next.fxprime);\n                phiPrime = dot(next.fxprime, pk);\n\n                if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                    (phi >= phi_lo)) {\n                    a_high = a;\n\n                } else  {\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                        return a;\n                    }\n\n                    if (phiPrime * (a_high - a_lo) >=0) {\n                        a_high = a_lo;\n                    }\n\n                    a_lo = a;\n                    phi_lo = phi;\n                }\n            }\n\n            return 0;\n        }\n\n        for (var iteration = 0; iteration < 10; ++iteration) {\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (iteration && (phi >= phi_old))) {\n                return zoom(a0, a, phi_old);\n            }\n\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                return a;\n            }\n\n            if (phiPrime >= 0 ) {\n                return zoom(a, a0, phi);\n            }\n\n            phi_old = phi;\n            a0 = a;\n            a *= 2;\n        }\n\n        return a;\n    }\n\n    function conjugateGradient(f, initial, params) {\n        // allocate all memory up front here, keep out of the loop for perfomance\n        // reasons\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            yk = initial.slice(),\n            pk, temp,\n            a = 1,\n            maxIterations;\n\n        params = params || {};\n        maxIterations = params.maxIterations || initial.length * 20;\n\n        current.fx = f(current.x, current.fxprime);\n        pk = current.fxprime.slice();\n        scale(pk, current.fxprime,-1);\n\n        for (var i = 0; i < maxIterations; ++i) {\n            a = wolfeLineSearch(f, pk, current, next, a);\n\n            // todo: history in wrong spot?\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     alpha: a});\n            }\n\n            if (!a) {\n                // faiiled to find point that satifies wolfe conditions.\n                // reset direction for next iteration\n                scale(pk, current.fxprime, -1);\n\n            } else {\n                // update direction using Polak–Ribiere CG method\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n                var delta_k = dot(current.fxprime, current.fxprime),\n                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n                temp = current;\n                current = next;\n                next = temp;\n            }\n\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        return current;\n    }\n\n    /** given a list of set objects, and their corresponding overlaps.\n    updates the (x, y, radius) attribute on each set such that their positions\n    roughly correspond to the desired overlaps */\n    function venn(areas, parameters) {\n        parameters = parameters || {};\n        parameters.maxIterations = parameters.maxIterations || 500;\n        var initialLayout = parameters.initialLayout || bestInitialLayout;\n        var loss = parameters.lossFunction || lossFunction;\n\n        // add in missing pairwise areas as having 0 size\n        areas = addMissingAreas(areas);\n\n        // initial layout is done greedily\n        var circles = initialLayout(areas, parameters);\n\n        // transform x/y coordinates to a vector to optimize\n        var initial = [], setids = [], setid;\n        for (setid in circles) {\n            if (circles.hasOwnProperty(setid)) {\n                initial.push(circles[setid].x);\n                initial.push(circles[setid].y);\n                setids.push(setid);\n            }\n        }\n        var solution = nelderMead(\n            function(values) {\n                var current = {};\n                for (var i = 0; i < setids.length; ++i) {\n                    var setid = setids[i];\n                    current[setid] = {x: values[2 * i],\n                                      y: values[2 * i + 1],\n                                      radius : circles[setid].radius,\n                                     // size : circles[setid].size\n                                     };\n                }\n                return loss(current, areas);\n            },\n            initial,\n            parameters);\n\n        // transform solution vector back to x/y points\n        var positions = solution.x;\n        for (var i = 0; i < setids.length; ++i) {\n            setid = setids[i];\n            circles[setid].x = positions[2 * i];\n            circles[setid].y = positions[2 * i + 1];\n        }\n\n        return circles;\n    }\n\n    var SMALL$1 = 1e-10;\n\n    /** Returns the distance necessary for two circles of radius r1 + r2 to\n    have the overlap area 'overlap' */\n    function distanceFromIntersectArea(r1, r2, overlap) {\n        // handle complete overlapped circles\n        if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap + SMALL$1) {\n            return Math.abs(r1 - r2);\n        }\n\n        return bisect(function(distance$$1) {\n            return circleOverlap(r1, r2, distance$$1) - overlap;\n        }, 0, r1 + r2);\n    }\n\n    /** Missing pair-wise intersection area data can cause problems:\n     treating as an unknown means that sets will be laid out overlapping,\n     which isn't what people expect. To reflect that we want disjoint sets\n     here, set the overlap to 0 for all missing pairwise set intersections */\n    function addMissingAreas(areas) {\n        areas = areas.slice();\n\n        // two circle intersections that aren't defined\n        var ids = [], pairs = {}, i, j, a, b;\n        for (i = 0; i < areas.length; ++i) {\n            var area = areas[i];\n            if (area.sets.length == 1) {\n                ids.push(area.sets[0]);\n            } else if (area.sets.length == 2) {\n                a = area.sets[0];\n                b = area.sets[1];\n                pairs[[a, b]] = true;\n                pairs[[b, a]] = true;\n            }\n        }\n        ids.sort(function(a, b) { return a > b; });\n\n        for (i = 0; i < ids.length; ++i) {\n            a = ids[i];\n            for (j = i + 1; j < ids.length; ++j) {\n                b = ids[j];\n                if (!([a, b] in pairs)) {\n                    areas.push({'sets': [a, b],\n                                'size': 0});\n                }\n            }\n        }\n        return areas;\n    }\n\n    /// Returns two matrices, one of the euclidean distances between the sets\n    /// and the other indicating if there are subset or disjoint set relationships\n    function getDistanceMatrices(areas, sets, setids) {\n        // initialize an empty distance matrix between all the points\n        var distances = zerosM(sets.length, sets.length),\n            constraints = zerosM(sets.length, sets.length);\n\n        // compute required distances between all the sets such that\n        // the areas match\n        areas.filter(function(x) { return x.sets.length == 2; })\n            .map(function(current) {\n            var left = setids[current.sets[0]],\n                right = setids[current.sets[1]],\n                r1 = Math.sqrt(sets[left].size / Math.PI),\n                r2 = Math.sqrt(sets[right].size / Math.PI),\n                distance$$1 = distanceFromIntersectArea(r1, r2, current.size);\n\n            distances[left][right] = distances[right][left] = distance$$1;\n\n            // also update constraints to indicate if its a subset or disjoint\n            // relationship\n            var c = 0;\n            if (current.size + 1e-10 >= Math.min(sets[left].size,\n                                                 sets[right].size)) {\n                c = 1;\n            } else if (current.size <= 1e-10) {\n                c = -1;\n            }\n            constraints[left][right] = constraints[right][left] = c;\n        });\n\n        return {distances: distances, constraints: constraints};\n    }\n\n    /// computes the gradient and loss simulatenously for our constrained MDS optimizer\n    function constrainedMDSGradient(x, fxprime, distances, constraints) {\n        var loss = 0, i;\n        for (i = 0; i < fxprime.length; ++i) {\n            fxprime[i] = 0;\n        }\n\n        for (i = 0; i < distances.length; ++i) {\n            var xi = x[2 * i], yi = x[2 * i + 1];\n            for (var j = i + 1; j < distances.length; ++j) {\n                var xj = x[2 * j], yj = x[2 * j + 1],\n                    dij = distances[i][j],\n                    constraint = constraints[i][j];\n\n                var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n                    distance$$1 = Math.sqrt(squaredDistance),\n                    delta = squaredDistance - dij * dij;\n\n                if (((constraint > 0) && (distance$$1 <= dij)) ||\n                    ((constraint < 0) && (distance$$1 >= dij))) {\n                    continue;\n                }\n\n                loss += 2 * delta * delta;\n\n                fxprime[2*i]     += 4 * delta * (xi - xj);\n                fxprime[2*i + 1] += 4 * delta * (yi - yj);\n\n                fxprime[2*j]     += 4 * delta * (xj - xi);\n                fxprime[2*j + 1] += 4 * delta * (yj - yi);\n            }\n        }\n        return loss;\n    }\n\n    /// takes the best working variant of either constrained MDS or greedy\n    function bestInitialLayout(areas, params) {\n        var initial = greedyLayout(areas, params);\n        var loss = params.lossFunction || lossFunction;\n\n        // greedylayout is sufficient for all 2/3 circle cases. try out\n        // constrained MDS for higher order problems, take its output\n        // if it outperforms. (greedy is aesthetically better on 2/3 circles\n        // since it axis aligns)\n        if (areas.length >= 8) {\n            var constrained  = constrainedMDSLayout(areas, params),\n                constrainedLoss = loss(constrained, areas),\n                greedyLoss = loss(initial, areas);\n\n            if (constrainedLoss + 1e-8 < greedyLoss) {\n                initial = constrained;\n            }\n        }\n        return initial;\n    }\n\n    /// use the constrained MDS variant to generate an initial layout\n    function constrainedMDSLayout(areas, params) {\n        params = params || {};\n        var restarts = params.restarts || 10;\n\n        // bidirectionally map sets to a rowid  (so we can create a matrix)\n        var sets = [], setids = {}, i;\n        for (i = 0; i < areas.length; ++i ) {\n            var area = areas[i];\n            if (area.sets.length == 1) {\n                setids[area.sets[0]] = sets.length;\n                sets.push(area);\n            }\n        }\n\n        var matrices = getDistanceMatrices(areas, sets, setids),\n            distances = matrices.distances,\n            constraints = matrices.constraints;\n\n        // keep distances bounded, things get messed up otherwise.\n        // TODO: proper preconditioner?\n        var norm = norm2(distances.map(norm2))/(distances.length);\n        distances = distances.map(function (row) {\n            return row.map(function (value) { return value / norm; });});\n\n        var obj = function(x, fxprime) {\n            return constrainedMDSGradient(x, fxprime, distances, constraints);\n        };\n\n        var best, current;\n        for (i = 0; i < restarts; ++i) {\n            var initial = zeros(distances.length*2).map(Math.random);\n\n            current = conjugateGradient(obj, initial, params);\n            if (!best || (current.fx < best.fx)) {\n                best = current;\n            }\n        }\n        var positions = best.x;\n\n        // translate rows back to (x,y,radius) coordinates\n        var circles = {};\n        for (i = 0; i < sets.length; ++i) {\n            var set = sets[i];\n            circles[set.sets[0]] = {\n                x: positions[2*i] * norm,\n                y: positions[2*i + 1] * norm,\n                radius:  Math.sqrt(set.size / Math.PI)\n            };\n        }\n\n        if (params.history) {\n            for (i = 0; i < params.history.length; ++i) {\n                scale(params.history[i].x, norm);\n            }\n        }\n        return circles;\n    }\n\n    /** Lays out a Venn diagram greedily, going from most overlapped sets to\n    least overlapped, attempting to position each new set such that the\n    overlapping areas to already positioned sets are basically right */\n    function greedyLayout(areas, params) {\n        var loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n        // define a circle for each set\n        var circles = {}, setOverlaps = {}, set;\n        for (var i = 0; i < areas.length; ++i) {\n            var area = areas[i];\n            if (area.sets.length == 1) {\n                set = area.sets[0];\n                circles[set] = {x: 1e10, y: 1e10,\n                                rowid: circles.length,\n                                size: area.size,\n                                radius: Math.sqrt(area.size / Math.PI)};\n                setOverlaps[set] = [];\n            }\n        }\n        areas = areas.filter(function(a) { return a.sets.length == 2; });\n\n        // map each set to a list of all the other sets that overlap it\n        for (i = 0; i < areas.length; ++i) {\n            var current = areas[i];\n            var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n            var left = current.sets[0], right = current.sets[1];\n\n            // completely overlapped circles shouldn't be positioned early here\n            if (current.size + SMALL$1 >= Math.min(circles[left].size,\n                                                 circles[right].size)) {\n                weight = 0;\n            }\n\n            setOverlaps[left].push ({set:right, size:current.size, weight:weight});\n            setOverlaps[right].push({set:left,  size:current.size, weight:weight});\n        }\n\n        // get list of most overlapped sets\n        var mostOverlapped = [];\n        for (set in setOverlaps) {\n            if (setOverlaps.hasOwnProperty(set)) {\n                var size = 0;\n                for (i = 0; i < setOverlaps[set].length; ++i) {\n                    size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n                }\n\n                mostOverlapped.push({set: set, size:size});\n            }\n        }\n\n        // sort by size desc\n        function sortOrder(a,b) {\n            return b.size - a.size;\n        }\n        mostOverlapped.sort(sortOrder);\n\n        // keep track of what sets have been laid out\n        var positioned = {};\n        function isPositioned(element) {\n            return element.set in positioned;\n        }\n\n        // adds a point to the output\n        function positionSet(point, index) {\n            circles[index].x = point.x;\n            circles[index].y = point.y;\n            positioned[index] = true;\n        }\n\n        // add most overlapped set at (0,0)\n        positionSet({x: 0, y: 0}, mostOverlapped[0].set);\n\n        // get distances between all points. TODO, necessary?\n        // answer: probably not\n        // var distances = venn.getDistanceMatrices(circles, areas).distances;\n        for (i = 1; i < mostOverlapped.length; ++i) {\n            var setIndex = mostOverlapped[i].set,\n                overlap = setOverlaps[setIndex].filter(isPositioned);\n            set = circles[setIndex];\n            overlap.sort(sortOrder);\n\n            if (overlap.length === 0) {\n                // this shouldn't happen anymore with addMissingAreas\n                throw \"ERROR: missing pairwise overlap information\";\n            }\n\n            var points = [];\n            for (var j = 0; j < overlap.length; ++j) {\n                // get appropriate distance from most overlapped already added set\n                var p1 = circles[overlap[j].set],\n                    d1 = distanceFromIntersectArea(set.radius, p1.radius,\n                                                   overlap[j].size);\n\n                // sample positions at 90 degrees for maximum aesthetics\n                points.push({x : p1.x + d1, y : p1.y});\n                points.push({x : p1.x - d1, y : p1.y});\n                points.push({y : p1.y + d1, x : p1.x});\n                points.push({y : p1.y - d1, x : p1.x});\n\n                // if we have at least 2 overlaps, then figure out where the\n                // set should be positioned analytically and try those too\n                for (var k = j + 1; k < overlap.length; ++k) {\n                    var p2 = circles[overlap[k].set],\n                        d2 = distanceFromIntersectArea(set.radius, p2.radius,\n                                                       overlap[k].size);\n\n                    var extraPoints = circleCircleIntersection(\n                        { x: p1.x, y: p1.y, radius: d1},\n                        { x: p2.x, y: p2.y, radius: d2});\n\n                    for (var l = 0; l < extraPoints.length; ++l) {\n                        points.push(extraPoints[l]);\n                    }\n                }\n            }\n\n            // we have some candidate positions for the set, examine loss\n            // at each position to figure out where to put it at\n            var bestLoss = 1e50, bestPoint = points[0];\n            for (j = 0; j < points.length; ++j) {\n                circles[setIndex].x = points[j].x;\n                circles[setIndex].y = points[j].y;\n                var localLoss = loss(circles, areas);\n                if (localLoss < bestLoss) {\n                    bestLoss = localLoss;\n                    bestPoint = points[j];\n                }\n            }\n\n            positionSet(bestPoint, setIndex);\n        }\n\n        return circles;\n    }\n\n    /** Given a bunch of sets, and the desired overlaps between these sets - computes\n    the distance from the actual overlaps to the desired overlaps. Note that\n    this method ignores overlaps of more than 2 circles */\n    function lossFunction(sets, overlaps) {\n        var output = 0;\n\n        function getCircles(indices) {\n            return indices.map(function(i) { return sets[i]; });\n        }\n\n        for (var i = 0; i < overlaps.length; ++i) {\n            var area = overlaps[i], overlap;\n            if (area.sets.length == 1) {\n                continue;\n            } else if (area.sets.length == 2) {\n                var left = sets[area.sets[0]],\n                    right = sets[area.sets[1]];\n                overlap = circleOverlap(left.radius, right.radius,\n                                        distance(left, right));\n            } else {\n                overlap = intersectionArea(getCircles(area.sets));\n            }\n\n            var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n            output += weight * (overlap - area.size) * (overlap - area.size);\n        }\n\n        return output;\n    }\n\n    // orientates a bunch of circles to point in orientation\n    function orientateCircles(circles, orientation, orientationOrder) {\n        if (orientationOrder === null) {\n            circles.sort(function (a, b) { return b.radius - a.radius; });\n        } else {\n            circles.sort(orientationOrder);\n        }\n\n        var i;\n        // shift circles so largest circle is at (0, 0)\n        if (circles.length > 0) {\n            var largestX = circles[0].x,\n                largestY = circles[0].y;\n\n            for (i = 0; i < circles.length; ++i) {\n                circles[i].x -= largestX;\n                circles[i].y -= largestY;\n            }\n        }\n\n        if (circles.length == 2) {\n            // if the second circle is a subset of the first, arrange so that\n            // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n            var dist = distance(circles[0], circles[1]);\n            if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n                circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n                circles[1].y = circles[0].y;\n            }\n        }\n\n        // rotate circles so that second largest is at an angle of 'orientation'\n        // from largest\n        if (circles.length > 1) {\n            var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n                c = Math.cos(rotation),\n                s = Math.sin(rotation), x, y;\n\n            for (i = 0; i < circles.length; ++i) {\n                x = circles[i].x;\n                y = circles[i].y;\n                circles[i].x = c * x - s * y;\n                circles[i].y = s * x + c * y;\n            }\n        }\n\n        // mirror solution if third solution is above plane specified by\n        // first two circles\n        if (circles.length > 2) {\n            var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n            while (angle < 0) { angle += 2* Math.PI; }\n            while (angle > 2*Math.PI) { angle -= 2* Math.PI; }\n            if (angle > Math.PI) {\n                var slope = circles[1].y / (1e-10 + circles[1].x);\n                for (i = 0; i < circles.length; ++i) {\n                    var d = (circles[i].x + slope * circles[i].y) / (1 + slope*slope);\n                    circles[i].x = 2 * d - circles[i].x;\n                    circles[i].y = 2 * d * slope - circles[i].y;\n                }\n            }\n        }\n    }\n\n    function disjointCluster(circles) {\n        // union-find clustering to get disjoint sets\n        circles.map(function(circle) { circle.parent = circle; });\n\n        // path compression step in union find\n        function find(circle) {\n            if (circle.parent !== circle) {\n                circle.parent = find(circle.parent);\n            }\n            return circle.parent;\n        }\n\n        function union(x, y) {\n            var xRoot = find(x), yRoot = find(y);\n            xRoot.parent = yRoot;\n        }\n\n        // get the union of all overlapping sets\n        for (var i = 0; i < circles.length; ++i) {\n            for (var j = i + 1; j < circles.length; ++j) {\n                var maxDistance = circles[i].radius + circles[j].radius;\n                if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n                    union(circles[j], circles[i]);\n                }\n            }\n        }\n\n        // find all the disjoint clusters and group them together\n        var disjointClusters = {}, setid;\n        for (i = 0; i < circles.length; ++i) {\n            setid = find(circles[i]).parent.setid;\n            if (!(setid in disjointClusters)) {\n                disjointClusters[setid] = [];\n            }\n            disjointClusters[setid].push(circles[i]);\n        }\n\n        // cleanup bookkeeping\n        circles.map(function(circle) { delete circle.parent; });\n\n        // return in more usable form\n        var ret = [];\n        for (setid in disjointClusters) {\n            if (disjointClusters.hasOwnProperty(setid)) {\n                ret.push(disjointClusters[setid]);\n            }\n        }\n        return ret;\n    }\n\n    function getBoundingBox(circles) {\n        var minMax = function(d) {\n            var hi = Math.max.apply(null, circles.map(\n                                    function(c) { return c[d] + c.radius; } )),\n                lo = Math.min.apply(null, circles.map(\n                                    function(c) { return c[d] - c.radius;} ));\n            return {max:hi, min:lo};\n        };\n\n        return {xRange: minMax('x'), yRange: minMax('y')};\n    }\n\n    function normalizeSolution(solution, orientation, orientationOrder) {\n        if (orientation === null){\n            orientation = Math.PI/2;\n        }\n\n        // work with a list instead of a dictionary, and take a copy so we\n        // don't mutate input\n        var circles = [], i, setid;\n        for (setid in solution) {\n            if (solution.hasOwnProperty(setid)) {\n                var previous = solution[setid];\n                circles.push({x: previous.x,\n                              y: previous.y,\n                              radius: previous.radius,\n                              setid: setid});\n            }\n        }\n\n        // get all the disjoint clusters\n        var clusters = disjointCluster(circles);\n\n        // orientate all disjoint sets, get sizes\n        for (i = 0; i < clusters.length; ++i) {\n            orientateCircles(clusters[i], orientation, orientationOrder);\n            var bounds = getBoundingBox(clusters[i]);\n            clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n            clusters[i].bounds = bounds;\n        }\n        clusters.sort(function(a, b) { return b.size - a.size; });\n\n        // orientate the largest at 0,0, and get the bounds\n        circles = clusters[0];\n        var returnBounds = circles.bounds;\n\n        var spacing = (returnBounds.xRange.max - returnBounds.xRange.min)/50;\n\n        function addCluster(cluster, right, bottom) {\n            if (!cluster) return;\n\n            var bounds = cluster.bounds, xOffset, yOffset, centreing;\n\n            if (right) {\n                xOffset = returnBounds.xRange.max  - bounds.xRange.min + spacing;\n            } else {\n                xOffset = returnBounds.xRange.max  - bounds.xRange.max;\n                centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -\n                            (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n                if (centreing < 0) xOffset += centreing;\n            }\n\n            if (bottom) {\n                yOffset = returnBounds.yRange.max  - bounds.yRange.min + spacing;\n            } else {\n                yOffset = returnBounds.yRange.max  - bounds.yRange.max;\n                centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -\n                            (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n                if (centreing < 0) yOffset += centreing;\n            }\n\n            for (var j = 0; j < cluster.length; ++j) {\n                cluster[j].x += xOffset;\n                cluster[j].y += yOffset;\n                circles.push(cluster[j]);\n            }\n        }\n\n        var index = 1;\n        while (index < clusters.length) {\n            addCluster(clusters[index], true, false);\n            addCluster(clusters[index+1], false, true);\n            addCluster(clusters[index+2], true, true);\n            index += 3;\n\n            // have one cluster (in top left). lay out next three relative\n            // to it in a grid\n            returnBounds = getBoundingBox(circles);\n        }\n\n        // convert back to solution form\n        var ret = {};\n        for (i = 0; i < circles.length; ++i) {\n            ret[circles[i].setid] = circles[i];\n        }\n        return ret;\n    }\n\n    /** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n    a rectangle of width/height - with padding around the borders. also\n    centers the diagram in the available space at the same time */\n    function scaleSolution(solution, width, height, padding) {\n        var circles = [], setids = [];\n        for (var setid in solution) {\n            if (solution.hasOwnProperty(setid)) {\n                setids.push(setid);\n                circles.push(solution[setid]);\n            }\n        }\n\n        width -= 2*padding;\n        height -= 2*padding;\n\n        var bounds = getBoundingBox(circles),\n            xRange = bounds.xRange,\n            yRange = bounds.yRange;\n\n        if ((xRange.max == xRange.min) ||\n            (yRange.max == yRange.min)) {\n            console.log(\"not scaling solution: zero size detected\");\n            return solution;\n        }\n\n        var xScaling = width  / (xRange.max - xRange.min),\n            yScaling = height / (yRange.max - yRange.min),\n            scaling = Math.min(yScaling, xScaling),\n\n            // while we're at it, center the diagram too\n            xOffset = (width -  (xRange.max - xRange.min) * scaling) / 2,\n            yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n        var scaled = {};\n        for (var i = 0; i < circles.length; ++i) {\n            var circle = circles[i];\n            scaled[setids[i]] = {\n                radius: scaling * circle.radius,\n                x: padding + xOffset + (circle.x - xRange.min) * scaling,\n                y: padding + yOffset + (circle.y - yRange.min) * scaling,\n            };\n        }\n\n        return scaled;\n    }\n\n    /*global console:true*/\n\n    function VennDiagram() {\n        var width = 600,\n            height = 350,\n            padding = 15,\n            duration = 1000,\n            orientation = Math.PI / 2,\n            normalize = true,\n            wrap = true,\n            styled = true,\n            fontSize = null,\n            orientationOrder = null,\n\n            // mimic the behaviour of d3.scale.category10 from the previous\n            // version of d3\n            colourMap = {},\n\n            // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n            // since we can support older versions of d3 as long as we don't force this,\n            // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n            colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n            colourIndex = 0,\n            colours = function(key) {\n                if (key in colourMap) {\n                    return colourMap[key];\n                }\n                var ret = colourMap[key] = colourScheme[colourIndex];\n                colourIndex += 1;\n                if (colourIndex >= colourScheme.length) {\n                    colourIndex = 0;\n                }\n                return ret;\n            },\n            layoutFunction = venn,\n            loss = lossFunction;\n\n\n        function chart(selection) {\n            var data = selection.datum();\n\n            // handle 0-sized sets by removing from input\n            var toremove = {};\n            data.forEach(function(datum) {\n                if ((datum.size == 0) && datum.sets.length == 1) {\n                    toremove[datum.sets[0]] = 1;\n                }\n            });\n            data = data.filter(function(datum) {\n                return !datum.sets.some(function(set) { return set in toremove; });\n            });\n\n            var circles = {};\n            var textCentres = {};\n\n            if (data.length > 0) {\n                var solution = layoutFunction(data, {lossFunction: loss});\n\n                if (normalize) {\n                    solution = normalizeSolution(solution,\n                                                orientation,\n                                                orientationOrder);\n                }\n\n                circles = scaleSolution(solution, width, height, padding);\n                textCentres = computeTextCentres(circles, data);\n            }\n\n            // Figure out the current label for each set. These can change\n            // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n            var labels = {};\n            data.forEach(function(datum) {\n                if (datum.label) {\n                    labels[datum.sets] = datum.label;\n                }\n            });\n\n            function label(d) {\n                if (d.sets in labels) {\n                    return labels[d.sets];\n                }\n                if (d.sets.length == 1) {\n                    return '' + d.sets[0];\n                }\n            }\n\n            // create svg if not already existing\n            selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n\n            var svg = selection.select(\"svg\")\n                .attr(\"width\", width)\n                .attr(\"height\", height);\n\n            // to properly transition intersection areas, we need the\n            // previous circles locations. load from elements\n            var previous = {}, hasPrevious = false;\n            svg.selectAll(\".venn-area path\").each(function (d) {\n                var path = d3Selection.select(this).attr(\"d\");\n                if ((d.sets.length == 1) && path) {\n                    hasPrevious = true;\n                    previous[d.sets[0]] = circleFromPath(path);\n                }\n            });\n\n            // interpolate intersection area paths between previous and\n            // current paths\n            var pathTween = function(d) {\n                return function(t) {\n                    var c = d.sets.map(function(set) {\n                        var start = previous[set], end = circles[set];\n                        if (!start) {\n                            start = {x : width/2, y : height/2, radius : 1};\n                        }\n                        if (!end) {\n                            end = {x : width/2, y : height/2, radius : 1};\n                        }\n                        return {'x' : start.x * (1 - t) + end.x * t,\n                                'y' : start.y * (1 - t) + end.y * t,\n                                'radius' : start.radius * (1 - t) + end.radius * t};\n                    });\n                    return intersectionAreaPath(c);\n                };\n            };\n\n            // update data, joining on the set ids\n            var nodes = svg.selectAll(\".venn-area\")\n                .data(data, function(d) { return d.sets; });\n\n            // create new nodes\n            var enter = nodes.enter()\n                .append('g')\n                .attr(\"class\", function(d) {\n                    return \"venn-area venn-\" +\n                        (d.sets.length == 1 ? \"circle\" : \"intersection\");\n                })\n                .attr(\"data-venn-sets\", function(d) {\n                    return d.sets.join(\"_\");\n                });\n\n            var enterPath = enter.append(\"path\"),\n                enterText = enter.append(\"text\")\n                .attr(\"class\", \"label\")\n                .text(function (d) { return label(d); } )\n                .attr(\"text-anchor\", \"middle\")\n                .attr(\"dy\", \".35em\")\n                .attr(\"x\", width/2)\n                .attr(\"y\", height/2);\n\n\n            // apply minimal style if wanted\n            if (styled) {\n                enterPath.style(\"fill-opacity\", \"0\")\n                    .filter(function (d) { return d.sets.length == 1; } )\n                    .style(\"fill\", function(d) { return colours(d.sets); })\n                    .style(\"fill-opacity\", \".25\");\n\n                enterText\n                    .style(\"fill\", function(d) { return d.sets.length == 1 ? colours(d.sets) : \"#444\"; });\n            }\n\n            // update existing, using pathTween if necessary\n            var update = selection;\n            if (hasPrevious) {\n                update = selection.transition(\"venn\").duration(duration);\n                update.selectAll(\"path\")\n                    .attrTween(\"d\", pathTween);\n            } else {\n                update.selectAll(\"path\")\n                    .attr(\"d\", function(d) {\n                        return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));\n                    });\n            }\n\n            var updateText = update.selectAll(\"text\")\n                .filter(function (d) { return d.sets in textCentres; })\n                .text(function (d) { return label(d); } )\n                .attr(\"x\", function(d) { return Math.floor(textCentres[d.sets].x);})\n                .attr(\"y\", function(d) { return Math.floor(textCentres[d.sets].y);});\n\n            if (wrap) {\n                if (hasPrevious) {\n                    // d3 4.0 uses 'on' for events on transitions,\n                    // but d3 3.0 used 'each' instead. switch appropiately\n                    if ('on' in updateText) {\n                        updateText.on(\"end\", wrapText(circles, label));\n                    } else {\n                        updateText.each(\"end\", wrapText(circles, label));\n                    }\n                } else {\n                    updateText.each(wrapText(circles, label));\n                }\n            }\n\n            // remove old\n            var exit = nodes.exit().transition('venn').duration(duration).remove();\n            exit.selectAll(\"path\")\n                .attrTween(\"d\", pathTween);\n\n            var exitText = exit.selectAll(\"text\")\n                .attr(\"x\", width/2)\n                .attr(\"y\", height/2);\n\n            // if we've been passed a fontSize explicitly, use it to\n            // transition\n            if (fontSize !== null) {\n                enterText.style(\"font-size\", \"0px\");\n                updateText.style(\"font-size\", fontSize);\n                exitText.style(\"font-size\", \"0px\");\n            }\n\n\n            return {'circles': circles,\n                    'textCentres': textCentres,\n                    'nodes': nodes,\n                    'enter': enter,\n                    'update': update,\n                    'exit': exit};\n        }\n\n        chart.wrap = function(_) {\n            if (!arguments.length) return wrap;\n            wrap = _;\n            return chart;\n        };\n\n        chart.width = function(_) {\n            if (!arguments.length) return width;\n            width = _;\n            return chart;\n        };\n\n        chart.height = function(_) {\n            if (!arguments.length) return height;\n            height = _;\n            return chart;\n        };\n\n        chart.padding = function(_) {\n            if (!arguments.length) return padding;\n            padding = _;\n            return chart;\n        };\n\n        chart.colours = function(_) {\n            if (!arguments.length) return colours;\n            colours = _;\n            return chart;\n        };\n\n        chart.fontSize = function(_) {\n            if (!arguments.length) return fontSize;\n            fontSize = _;\n            return chart;\n        };\n\n        chart.duration = function(_) {\n            if (!arguments.length) return duration;\n            duration = _;\n            return chart;\n        };\n\n        chart.layoutFunction = function(_) {\n            if (!arguments.length) return layoutFunction;\n            layoutFunction = _;\n            return chart;\n        };\n\n        chart.normalize = function(_) {\n            if (!arguments.length) return normalize;\n            normalize = _;\n            return chart;\n        };\n\n        chart.styled = function(_) {\n            if (!arguments.length) return styled;\n            styled = _;\n            return chart;\n        };\n\n        chart.orientation = function(_) {\n            if (!arguments.length) return orientation;\n            orientation = _;\n            return chart;\n        };\n\n        chart.orientationOrder = function(_) {\n            if (!arguments.length) return orientationOrder;\n            orientationOrder = _;\n            return chart;\n        };\n\n        chart.lossFunction = function(_) {\n          if (!arguments.length) return loss;\n          loss = _;\n          return chart;\n        };\n\n        return chart;\n    }\n    // sometimes text doesn't fit inside the circle, if thats the case lets wrap\n    // the text here such that it fits\n    // todo: looks like this might be merged into d3 (\n    // https://github.com/mbostock/d3/issues/1642),\n    // also worth checking out is\n    // http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n    // this seems to be one of those things that should be easy but isn't\n    function wrapText(circles, labeller) {\n        return function() {\n            var text = d3Selection.select(this),\n                data = text.datum(),\n                width = circles[data.sets[0]].radius || 50,\n                label = labeller(data) || '';\n\n                var words = label.split(/\\s+/).reverse(),\n                maxLines = 3,\n                minChars = (label.length + words.length) / maxLines,\n                word = words.pop(),\n                line = [word],\n                joined,\n                lineNumber = 0,\n                lineHeight = 1.1, // ems\n                tspan = text.text(null).append(\"tspan\").text(word);\n\n            while (true) {\n                word = words.pop();\n                if (!word) break;\n                line.push(word);\n                joined = line.join(\" \");\n                tspan.text(joined);\n                if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n                    line.pop();\n                    tspan.text(line.join(\" \"));\n                    line = [word];\n                    tspan = text.append(\"tspan\").text(word);\n                    lineNumber++;\n                }\n            }\n\n            var initial = 0.35 - lineNumber * lineHeight / 2,\n                x = text.attr(\"x\"),\n                y = text.attr(\"y\");\n\n            text.selectAll(\"tspan\")\n                .attr(\"x\", x)\n                .attr(\"y\", y)\n                .attr(\"dy\", function(d, i) {\n                     return (initial + i * lineHeight) + \"em\";\n                });\n        };\n    }\n\n    function circleMargin(current, interior, exterior) {\n        var margin = interior[0].radius - distance(interior[0], current), i, m;\n        for (i = 1; i < interior.length; ++i) {\n            m = interior[i].radius - distance(interior[i], current);\n            if (m <= margin) {\n                margin = m;\n            }\n        }\n\n        for (i = 0; i < exterior.length; ++i) {\n            m = distance(exterior[i], current) - exterior[i].radius;\n            if (m <= margin) {\n                margin = m;\n            }\n        }\n        return margin;\n    }\n\n    // compute the center of some circles by maximizing the margin of\n    // the center point relative to the circles (interior) after subtracting\n    // nearby circles (exterior)\n    function computeTextCentre(interior, exterior) {\n        // get an initial estimate by sampling around the interior circles\n        // and taking the point with the biggest margin\n        var points = [], i;\n        for (i = 0; i < interior.length; ++i) {\n            var c = interior[i];\n            points.push({x: c.x, y: c.y});\n            points.push({x: c.x + c.radius/2, y: c.y});\n            points.push({x: c.x - c.radius/2, y: c.y});\n            points.push({x: c.x, y: c.y + c.radius/2});\n            points.push({x: c.x, y: c.y - c.radius/2});\n        }\n        var initial = points[0], margin = circleMargin(points[0], interior, exterior);\n        for (i = 1; i < points.length; ++i) {\n            var m = circleMargin(points[i], interior, exterior);\n            if (m >= margin) {\n                initial = points[i];\n                margin = m;\n            }\n        }\n\n        // maximize the margin numerically\n        var solution = nelderMead(\n                    function(p) { return -1 * circleMargin({x: p[0], y: p[1]}, interior, exterior); },\n                    [initial.x, initial.y],\n                    {maxIterations:500, minErrorDelta:1e-10}).x;\n        var ret = {x: solution[0], y: solution[1]};\n\n        // check solution, fallback as needed (happens if fully overlapped\n        // etc)\n        var valid = true;\n        for (i = 0; i < interior.length; ++i) {\n            if (distance(ret, interior[i]) > interior[i].radius) {\n                valid = false;\n                break;\n            }\n        }\n\n        for (i = 0; i < exterior.length; ++i) {\n            if (distance(ret, exterior[i]) < exterior[i].radius) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (!valid) {\n            if (interior.length == 1) {\n                ret = {x: interior[0].x, y: interior[0].y};\n            } else {\n                var areaStats = {};\n                intersectionArea(interior, areaStats);\n\n                if (areaStats.arcs.length === 0) {\n                    ret = {'x': 0, 'y': -1000, disjoint:true};\n\n                } else if (areaStats.arcs.length == 1) {\n                    ret = {'x': areaStats.arcs[0].circle.x,\n                           'y': areaStats.arcs[0].circle.y};\n\n                } else if (exterior.length) {\n                    // try again without other circles\n                    ret = computeTextCentre(interior, []);\n\n                } else {\n                    // take average of all the points in the intersection\n                    // polygon. this should basically never happen\n                    // and has some issues:\n                    // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n                    ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    // given a dictionary of {setid : circle}, returns\n    // a dictionary of setid to list of circles that completely overlap it\n    function getOverlappingCircles(circles) {\n        var ret = {}, circleids = [];\n        for (var circleid in circles) {\n            circleids.push(circleid);\n            ret[circleid] = [];\n        }\n        for (var i  = 0; i < circleids.length; i++) {\n            var a = circles[circleids[i]];\n            for (var j = i + 1; j < circleids.length; ++j) {\n                var b = circles[circleids[j]],\n                    d = distance(a, b);\n\n                if (d + b.radius <= a.radius + 1e-10) {\n                    ret[circleids[j]].push(circleids[i]);\n\n                } else if (d + a.radius <= b.radius + 1e-10) {\n                    ret[circleids[i]].push(circleids[j]);\n                }\n            }\n        }\n        return ret;\n    }\n\n    function computeTextCentres(circles, areas) {\n        var ret = {}, overlapped = getOverlappingCircles(circles);\n        for (var i = 0; i < areas.length; ++i) {\n            var area = areas[i].sets, areaids = {}, exclude = {};\n            for (var j = 0; j < area.length; ++j) {\n                areaids[area[j]] = true;\n                var overlaps = overlapped[area[j]];\n                // keep track of any circles that overlap this area,\n                // and don't consider for purposes of computing the text\n                // centre\n                for (var k = 0; k < overlaps.length; ++k) {\n                    exclude[overlaps[k]] = true;\n                }\n            }\n\n            var interior = [], exterior = [];\n            for (var setid in circles) {\n                if (setid in areaids) {\n                    interior.push(circles[setid]);\n                } else if (!(setid in exclude)) {\n                    exterior.push(circles[setid]);\n                }\n            }\n            var centre = computeTextCentre(interior, exterior);\n            ret[area] = centre;\n            if (centre.disjoint && (areas[i].size > 0)) {\n                console.log(\"WARNING: area \" + area + \" not represented on screen\");\n            }\n        }\n        return  ret;\n    }\n\n    // sorts all areas in the venn diagram, so that\n    // a particular area is on top (relativeTo) - and\n    // all other areas are so that the smallest areas are on top\n    function sortAreas(div, relativeTo) {\n\n        // figure out sets that are completly overlapped by relativeTo\n        var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n        var exclude = {};\n        for (var i = 0; i < relativeTo.sets.length; ++i) {\n            var check = relativeTo.sets[i];\n            for (var setid in overlaps) {\n                var overlap = overlaps[setid];\n                for (var j = 0; j < overlap.length; ++j) {\n                    if (overlap[j] == check) {\n                        exclude[setid] = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // checks that all sets are in exclude;\n        function shouldExclude(sets) {\n            for (var i = 0; i < sets.length; ++i) {\n                if (!(sets[i] in exclude)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        // need to sort div's so that Z order is correct\n        div.selectAll(\"g\").sort(function (a, b) {\n            // highest order set intersections first\n            if (a.sets.length != b.sets.length) {\n                return a.sets.length - b.sets.length;\n            }\n\n            if (a == relativeTo) {\n                return shouldExclude(b.sets) ? -1 : 1;\n            }\n            if (b == relativeTo) {\n                return shouldExclude(a.sets) ? 1 : -1;\n            }\n\n            // finally by size\n            return b.size - a.size;\n        });\n    }\n\n    function circlePath(x, y, r) {\n        var ret = [];\n        ret.push(\"\\nM\", x, y);\n        ret.push(\"\\nm\", -r, 0);\n        ret.push(\"\\na\", r, r, 0, 1, 0, r *2, 0);\n        ret.push(\"\\na\", r, r, 0, 1, 0,-r *2, 0);\n        return ret.join(\" \");\n    }\n\n    // inverse of the circlePath function, returns a circle object from an svg path\n    function circleFromPath(path) {\n        var tokens = path.split(' ');\n        return {'x' : parseFloat(tokens[1]),\n                'y' : parseFloat(tokens[2]),\n                'radius' : -parseFloat(tokens[4])\n                };\n    }\n\n    /** returns a svg path of the intersection area of a bunch of circles */\n    function intersectionAreaPath(circles) {\n        var stats = {};\n        intersectionArea(circles, stats);\n        var arcs = stats.arcs;\n\n        if (arcs.length === 0) {\n            return \"M 0 0\";\n\n        } else if (arcs.length == 1) {\n            var circle = arcs[0].circle;\n            return circlePath(circle.x, circle.y, circle.radius);\n\n        } else {\n            // draw path around arcs\n            var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n            for (var i = 0; i < arcs.length; ++i) {\n                var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;\n                ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1,\n                         arc.p1.x, arc.p1.y);\n            }\n            return ret.join(\" \");\n        }\n    }\n\n    exports.intersectionArea = intersectionArea;\n    exports.circleCircleIntersection = circleCircleIntersection;\n    exports.circleOverlap = circleOverlap;\n    exports.circleArea = circleArea;\n    exports.distance = distance;\n    exports.venn = venn;\n    exports.greedyLayout = greedyLayout;\n    exports.scaleSolution = scaleSolution;\n    exports.normalizeSolution = normalizeSolution;\n    exports.bestInitialLayout = bestInitialLayout;\n    exports.lossFunction = lossFunction;\n    exports.disjointCluster = disjointCluster;\n    exports.distanceFromIntersectArea = distanceFromIntersectArea;\n    exports.VennDiagram = VennDiagram;\n    exports.wrapText = wrapText;\n    exports.computeTextCentres = computeTextCentres;\n    exports.computeTextCentre = computeTextCentre;\n    exports.sortAreas = sortAreas;\n    exports.circlePath = circlePath;\n    exports.circleFromPath = circleFromPath;\n    exports.intersectionAreaPath = intersectionAreaPath;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(15))

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	module.exports = "/**\n * author: Nils Gehlenborg - nils@hms.harvard.edu\n*/\n\nvar Utilities = function() {\n};\n\n\nUtilities.generateUuid = function() {\n    // see broofa's answer in http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n    return ( 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n        return v.toString(16) ;\n    }) );\n};\n\nUtilities.truncate = function(textElement, w) {\n\n  var too_large = true;\n\n  if(textElement[0][0].getBBox().width<w)\n    too_large = false;\n\n  while(too_large) {\n\n    var bbox = textElement[0][0].getBBox();\n    var width = bbox.width;\n    var height = bbox.height;\n\n    textElement.text(textElement.text().substring(0, textElement.text().length-1));\n\n    if(textElement[0][0].getBBox().width<w)\n      too_large = false;\n\n  }\n\n  return textElement.text();\n}\n\n// attach the .compare method to Array's prototype to call it on any array\nArray.prototype.compare = function (array) {\n    // if the other array is a falsy value, return\n    if (!array)\n        return false;\n\n    // compare lengths - can save a lot of time\n    if (this.length != array.length)\n        return false;\n\n    for (var i = 0, l=this.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (this[i] instanceof Array && array[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!this[i].compare(array[i]))\n                return false;\n        }\n        else if (this[i] != array[i]) {\n            // Warning - two different object instances will never be equal: {x:20} != {x:20}\n            return false;\n        }\n    }\n    return true;\n}\n\n//\nArray.prototype.unique = function() {\n    var a = this.concat();\n    for(var i=0; i<a.length; ++i) {\n        for(var j=i+1; j<a.length; ++j) {\n            if(a[i] === a[j])\n                a.splice(j--, 1);\n        }\n    }\n    return a;\n};\n\n\nfunction debounce(func, wait, immediate) {\n  var timeout;\n\n  return function executedFunction() {\n    var context = this;\n    var args = arguments;\n\n    var later = function() {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n\n    var callNow = immediate && !timeout;\n\n    clearTimeout(timeout);\n\n    timeout = setTimeout(later, wait);\n\n    if (callNow) func.apply(context, args);\n  };\n};\n\n\n"

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(17))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Author: Nils Gehlenborg, nils@hms.harvard.edu\n */\n\n/**\n * Venn Diagram\n * Based on https://gist.github.com/mbostock/1067636.\n */\n\n\nvar VennDiagram = function( element, radius ) {\n  this.element = element;\n  this.radius = radius;\n  var chart = venn.VennDiagram()\n                   .width(radius * 2)\n                   .height(radius * 2);\n  this.chart = chart;\n};\n\nVennDiagram.prototype.isActive = function( areaSets, highlightSubsets ) {\n  var self = this;\n\n  if ( !highlightSubsets ) {\n    return false;\n  }\n\n  for ( var s = 0; s < highlightSubsets.length; ++s ) {\n    var hitCounter = 0;\n    for ( var i = 0; i < areaSets.length; ++i ) {\n      if ( areaSets[i] === highlightSubsets[s].combinedSets[i] ) {\n        ++hitCounter;\n      }\n    }\n    if ( hitCounter === areaSets.length ) {\n      return ( true );\n    }\n  }\n\n  return ( false );\n};\n\n\n/**\n *\n * @param aadd  所有的数字的数组\n * @param xuanlen  需要选择几个数\n * @returns {Array}返回一个数组\n */\nfunction jisuan(aadd, xuanlen) {\n   var resultArr=[];\n    deepCompute(aadd, xuanlen - 1, 0,\"\",resultArr);\n    function deepCompute(arr, choselen, index,str) {\n        for (var a = index; a < arr.length - choselen; a++) {\n            if (choselen != 0) {\n                deepCompute(arr, choselen - 1, a + 1,str+arr[a]+\",\")\n            } else {\n                resultArr.push(str+arr[a])\n            }\n        }\n    }\n\n    return resultArr;\n}\n\nfunction intersect(a, b){\n  return a.filter(function(v){ return b.indexOf(v) > -1 });\n}\n\nfunction getSubSetsBySelections (){\n  var highlightSubsets = []\n  if (selections && selections.active && selections.active.filterCollection) {\n    var filterList = selections.active.filterCollection.list;\n    filterList.forEach(function(filterInfo){\n      if (filterInfo.configuration.name === 'Subset' && filterInfo.parameterMap.subset) {\n        var parameterMapSubset = Object.values(filterInfo.parameterMap.subset);\n        var filteredSubSets = subSets.filter(function(subSet){\n          if (subSet.combinedSets.length !== parameterMapSubset.length) {\n            return false;\n          }\n          for (var i=0; i < subSet.combinedSets.length; i++) {\n            var combinedSet = subSet.combinedSets[i];\n            if (parameterMapSubset[i]!==2 && parameterMapSubset[i] !== combinedSet) {\n              return false\n            }\n          }\n          return true\n        })\n        filteredSubSets.forEach(function(filteredSubSet){\n          if (highlightSubsets.indexOf(filteredSubSet) < 0 ) {\n            highlightSubsets.push(filteredSubSet)\n          }\n        })\n      }\n    })\n  }\n  if (highlightSubsets.length > 0) {\n    return highlightSubsets;\n  }\n  return null;\n}\n\nfunction getSubSetsByDeFaultSets(){\n  var highlightSubsets = subSets.filter(function(subSet){\n    var combinedSets = subSet.combinedSets;\n    return combinedSets.reduce(function(prev, current){\n      return prev + current\n    }, 0) === 1\n  });\n  if (highlightSubsets) {\n    return highlightSubsets\n  }\n  return null;\n}\n\nVennDiagram.prototype.plot = debounce(function( highlightSubsets, setCount ) {\n  if (setCount > 14) {return}\n  if (!highlightSubsets) {\n    highlightSubsets = getSubSetsBySelections()\n    if (!highlightSubsets) {\n      highlightSubsets = getSubSetsByDeFaultSets()\n    }\n    if (!highlightSubsets) {return}\n  }\n  var self = this;\n  var vennSets = []\n  usedSets.forEach(function(usedSet){\n    vennSets.push({\n      sets: [usedSet.id],\n      size: usedSet.setSize,\n      label: usedSet.elementName\n    })\n  })\n\n\n\n  // 计算交集，如果只有一个点，那就不计算\n  var vennSetIdsObj = {}\n  var intersetHighlightSubsets = highlightSubsets;\n  if (highlightSubsets.length === 1 && highlightSubsets[0].combinedSets.reduce(function(prev,current){return prev + current}, 0) === 1) {\n    intersetHighlightSubsets = getSubSetsByDeFaultSets();\n  }\n  intersetHighlightSubsets.forEach(function(subSet){\n    subSet.combinedSets.forEach(function(_val, index){\n      if (_val === 1) {\n        vennSetIdsObj[usedSets[index].id] = usedSets[index]\n      }\n    })\n  })\n  var vennSetIds = Object.keys(vennSetIdsObj);\n  if (vennSetIds < 2) {\n    // 只有一个点\n  } else {\n    // 保证　vennjs.js 能正常显示\n    var importanceVennSetId = vennSetIds.join(',')\n    for (var i = 2; i <= vennSetIds.length; i++) {\n      var combineResults = jisuan(vennSetIds, i);\n      combineResults.forEach(function(combineResultStr){\n        var combineIds = combineResultStr.split(',');\n        var intersectResult = null\n        combineIds.forEach(function(combineId){\n          if (intersectResult === null) {\n            intersectResult = vennSetIdsObj[combineId].items\n          } else {\n            intersectResult = intersect(intersectResult, vennSetIdsObj[combineId].items)\n          }\n        })\n        var _vennSet = {\n          sets: combineIds,\n          size: intersectResult.length\n        }\n        if (importanceVennSetId === combineResultStr) {\n          _vennSet['weight'] = 1000;\n        }\n        vennSets.push(_vennSet)\n      })\n    }\n  }\n\n  // 保证单个 set 能显示出来\n  // 也就是usedSets 里的所有 set 能显示出来\n  vennSets = vennSets.filter(function(vennSet){\n    if (!vennSet) {return false}\n    if (vennSet.sets.length > 1 && vennSet.size === 0) {\n      return false\n    }\n    return true\n  })\n\n  var div = d3.select(self.element);\n  div.datum(vennSets).call(self.chart);\n  div.selectAll(\"path\")\n      .style(\"stroke-opacity\", 0)\n      .style(\"stroke\", \"#fff\")\n      .style(\"stroke-width\", 3)\n  if (highlightSubsets.length >= 1) {\n    d3.selectAll('.venn-area').filter(function(d){\n      var hasVal = highlightSubsets.some(function(highlightSubset){\n        var highlightSets = []\n        highlightSubset.combinedSets.forEach(function(_val, index){\n          if (_val === 1) {\n            highlightSets.push(usedSets[index].id)\n          }\n        })\n        return highlightSets.join(',') === d.sets.join(',')\n      })\n      if (hasVal) {\n        venn.sortAreas(div, d)\n      }\n      return hasVal\n    })\n      .select(\"path\")\n      .style(\"fill-opacity\", function(d) {\n        return d.sets.length == 1 ? .4 : .1\n      })\n      .style(\"stroke-opacity\", 1)\n  }\n\n  return\n}, 600);\n"

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(19))

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	module.exports = "/**\n * author: Nils Gehlenborg - nils@hms.harvard.edu\n*/\n\n\nvar Attribute = function() {\n\t// nothing here\n};\n\nAttribute.matchesType = function( sourceType, targetType ) {\n\tif ( sourceType === targetType ) {\n\t\treturn true;\n\t}\n\n\tif ( sourceType === 'integer' ) {\n\t\treturn targetType === 'numeric';\n\t}\n\n\tif ( sourceType === 'float' ) {\n\t\treturn targetType === 'numeric';\n\t}\n\n\treturn false;\n};\n"

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(21))

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	module.exports = "var wordCloudConfiguration = {\n    name: \"Word Cloud\",\n    attributes: [{\n            name: \"Text\",\n            type: \"id\",\n            variable: \"text\"\n        }],\n    parameters: [],\n    render: function( elementId, selections, attributes, attributeMap, parameterMap ) {\n        // based on https://github.com/jasondavies/d3-cloud/blob/master/examples/simple.html\n        var attribute = attributes[attributeMap.text];\n\n        var fill = d3.scale.category20();\n\n        // create data structure: array of pair arrays for each selection\n        var data = [];\n        for ( var s = 0; s < selections.getSize(); ++s ) {\n\n            var values = [];\n            var selection = selections.getSelection(s);\n\n            for ( var i = 0; i < selection.items.length; ++i ) {\n                //console.log( attribute.values[selection.items[i]].split(\" \") );\n                values = values.concat( attribute.values[selection.items[i]].split(\" \") );\n            }\n\n\n            values.color = selections.getColor( selection );\n            data.push( values );\n        }\n\n\n        d3.select( elementId ).html(\"\");\n        d3.layout.cloud().size([300, 200])\n            .words(data[0].map(function(d) {\n            return {text: d, size: 3 + Math.random() * 7};\n            }))\n            .padding(5)\n            //.timeInterval(1)\n            .rotate(function() { return ~~(Math.random() * 2) * 30; })\n            .font(\"Helvetica\")\n            .fontSize(function(d) { return d.size; })\n            .on(\"end\", draw)\n            .start();\n\n        function draw(words) {\n            d3.select( elementId ).append(\"svg\")\n                .attr(\"width\", 300)\n                .attr(\"height\", 200)\n                .append(\"g\")\n                    .attr(\"transform\", \"translate(150,100)\")\n                    .selectAll(\"text\")\n                        .data(words)\n                .enter().append(\"text\")\n                    .style(\"font-size\", function(d) { return d.size + \"px\"; })\n                    .style(\"font-family\", \"Helvetica\")\n                    .style(\"fill\", function(d, i) { return fill(i); })\n                    .attr(\"text-anchor\", \"middle\")\n                    .attr(\"transform\", function(d) {\n                        return \"translate(\" + [d.x, d.y] + \")rotate(\" + d.rotate + \")\";\n                    })\n                .text(function(d) { return d.text; });\n        }\n    }\n};\n"

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(23))

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	module.exports = "var scatterplotConfiguration = {\n    name: \"Scatterplot\",\n    attributes: [{\n            name: \"x\",\n            type: \"numeric\",\n            variable: \"x\"\n        },\n        {\n            name: \"y\",\n            type: \"numeric\",\n            variable: \"y\"\n        }],\n    parameters: [{\n            name: \"Log Scale X\",\n            type: \"boolean\",\n            variable: \"logScaleX\",\n            default: false\n        },\n        {\n            name: \"Log Scale Y\",\n            type: \"boolean\",\n            variable: \"logScaleY\",\n            default: false\n        }],\n    render: function( elementId, selections, attributes, attributeMap, parameterMap ) {\n        // based on http://bl.ocks.org/bunkat/2595950\n\n        var data = [];\n\n        var attributeX = attributes[attributeMap.x];\n        var attributeY = attributes[attributeMap.y];\n\n        // create data structure: array of pair arrays for each selection\n        for ( var s = 0; s < selections.getSize(); ++s ) {\n\n            var values = [];\n            var selection = selections.getSelection(s);\n\n            for ( var i = 0; i < selection.items.length; ++i ) {\n                values.push( [ attributeX.values[selection.items[i]], attributeY.values[selection.items[i]]] );\n            }\n\n            values.color = selections.getColor( selection );\n\n            data.push( values );\n        }\n\n        var margin = {top: 10, right: 20, bottom: 35, left: 45},\n            width = 350 - margin.left - margin.right,\n            height = 200 - margin.top - margin.bottom;\n\n        var x;\n\n        if ( parameterMap.logScaleX ) {\n            x = d3.scale.log()\n                .domain([attributeX.min, attributeX.max])\n                .range([0, width]);\n        }\n        else {\n            x = d3.scale.linear()\n                .domain([attributeX.min, attributeX.max])\n                .range([0, width]);\n        }\n\n        var y;\n\n        if ( parameterMap.logScaleY ) {\n            y = d3.scale.log()\n                .domain([attributeY.min, attributeY.max])\n                .range([ height, 0 ]);\n        }\n        else {\n            y = d3.scale.linear()\n                .domain([attributeY.min, attributeY.max])\n                .range([ height, 0 ]);\n        }\n\n        d3.select( elementId ).html(\"\");\n\n        var chart = d3.select( elementId )\n        .append('svg:svg')\n        .attr('width', width + margin.right + margin.left)\n        .attr('height', height + margin.top + margin.bottom)\n        .attr('class', 'chart')\n\n        var main = chart.append('g')\n        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')\n        .attr('width', width)\n        .attr('height', height)\n        .attr('class', 'main')\n\n        // draw the x axis\n        var xAxis = d3.svg.axis()\n        .scale(x)\n        .orient('bottom');\n\n        var xAxisG = main.append('g')\n            .attr('transform', 'translate(0,' + height + ')')\n            .attr('class', 'main axis date')\n            .call(xAxis);\n\n        xAxisG.selectAll(\"text\")\n          .attr(\"y\", 0)\n          .attr(\"x\", 9)\n          .attr(\"dy\", \".35em\")\n          //旋转x轴label\n          .attr(\"transform\", \"rotate(30)\")\n          .style(\"text-anchor\", \"start\");\n\n        xAxisG.append(\"text\")\n            .attr(\"transform\", \"translate(-40,\" + 30 + \")\" )\n            .style(\"text-anchor\", \"start\")\n            .text(attributeX.name);\n\n\n\n        // draw the y axis\n        var yAxis = d3.svg.axis()\n        .scale(y)\n        .orient('left');\n\n        main.append('g')\n            .attr('transform', 'translate(0,0)')\n            .attr('class', 'main axis date')\n            .call(yAxis)\n            .append(\"text\")\n                .attr(\"transform\", \"rotate(-90)\")\n                .attr(\"y\", -margin.left)\n                .attr(\"dy\", \".71em\")\n                .style(\"text-anchor\", \"end\")\n                .text( attributeY.name );\n\n        var g = main.append(\"svg:g\");\n\n        var selectionGroup = g.selectAll( '.selection-group' )\n            .data(data)\n          .enter()\n            .append( 'g' )\n            .attr( 'class', '.selection-group' )\n            .style('fill-opacity', 0.5 )\n            .attr(\"fill\", function(d) {  return ( d.color ); } );\n\n        var marks = selectionGroup.selectAll( '.element-mark' )\n                .data( function( d ) { return ( d ); } )\n            .enter()\n                .append(\"svg:circle\")\n                    .attr(\"cx\", function (d,i) { return x(d[0]); } )\n                    .attr(\"cy\", function (d,i) { return y(d[1]); } )\n                    .attr(\"r\", 2);\n    }\n};\n"

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(25))

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = "var histogramConfiguration = {\n    name: \"Histogram\",\n    attributes: [{\n            name: \"Variable\",\n            type: \"numeric\",\n            variable: \"variable\"\n        }],\n    parameters: [/*{\n            name: \"Small Multiples?\",\n            type: \"boolean\",\n            variable: \"smallMultiples\"\n        }*/{\n            name: \"Bins\",\n            type: \"integer\",\n            variable: \"bins\",\n            default: 20\n        },\n        {\n            name: \"Frequency?\",\n            type: \"boolean\",\n            variable: \"isFrequency\",\n            default: false\n        },\n        {\n            name: \"Only active?\",\n            type: \"boolean\",\n            variable: \"isActiveOnly\",\n            default: false\n        }],\n    render: function( elementId, selections, attributes, attributeMap, parameterMap ) {\n\n        var attribute = attributes[attributeMap.variable];\n\n        // A formatter for counts.\n        var format = d3.format(\".00r\");\n\n        if ( attribute.type === \"float\" ) {\n            format = d3.format(\",.00r\");\n        }\n        if ( attribute.type === \"integer\" ) {\n            format = d3.format(\"d\");\n        }\n\n        var margin = {top: 10, right: 20, bottom: 35, left: 45},\n            width = 350 - margin.left - margin.right,\n            height = 200 - margin.top - margin.bottom;\n\n        var x = d3.scale.linear()\n            .domain([attribute.min, attribute.max])\n            .range([0, width]);\n\n        var xAxis = d3.svg.axis()\n            .scale(x)\n            .orient(\"bottom\");\n        if (attribute.format && attribute.format.indexOf(\"date\") >= 0) {\n          formatParse = d3.time.format(attribute.format.substring('date:'.length)).parse\n          format = d3.time.format(\"%Y-%m-%d\")\n          xAxis = xAxis.tickFormat(function(d){\n            var dStr = d + '';\n            if (/^\\d{8}$/.test(dStr)) {\n              return format(formatParse(d + ''))\n            } else {\n              return d;\n            }\n          })\n        }\n\n        // clear\n        d3.select( elementId ).html(\"\");\n\n        var svg = d3.select( elementId ).append(\"svg\")\n            .attr(\"width\", width + margin.left + margin.right)\n            .attr(\"height\", height + margin.top + margin.bottom)\n          .append(\"g\")\n            .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n        var histograms = [];\n\n        // for each selection\n        for ( var s = 0; s < selections.getSize(); ++s ) {\n\n            var values = [];\n            var selection = selections.getSelection(s);\n\n            if ( parameterMap.isActiveOnly && !selections.isActive(selection) ) {\n                    continue;\n            }\n\n            for ( var i = 0; i < selection.items.length; ++i ) {\n                values.push( attribute.values[selection.items[i]] );\n            }\n\n            // Generate a histogram using twenty uniformly-spaced bins.\n            var histogram = d3.layout.histogram()\n                .frequency(parameterMap.isFrequency)\n                .bins(x.ticks(parameterMap.bins))\n                (values);\n\n            // interleave by shifting bar positions and adjusting bar widths\n            for ( var i = 0; i < histogram.length; ++i ) {\n                histogram[i].color = selections.getColor( selection );\n                if ( !parameterMap.isActiveOnly ) {\n                    histogram[i].dx = histogram[i].dx/selections.getSize();\n                }\n                histogram[i].x = histogram[i].x + s*histogram[i].dx\n            }\n\n            histograms.push( histogram );\n        }\n\n        var y = d3.scale.linear()\n            .domain([0, d3.max(histograms, function(histogram) { return d3.max( histogram, function(d) { return d.y; } ); })])\n            .range([height, 0]);\n\n        var yAxis = d3.svg.axis()\n            .scale(y)\n            .orient(\"left\");\n\n        var histogram = svg.selectAll(\".histogram\")\n                .data( histograms )\n            .enter().append(\"g\")\n                .attr(\"class\", \"histogram\");\n\n        var bar = histogram.selectAll(\".bar\")\n                .data( function( d ) { return ( d ); } )\n            .enter().append(\"g\")\n                .attr(\"class\", \"bar\")\n                .attr(\"transform\", function(d) { return \"translate(\" + x(d.x) + \",\" + y(d.y) + \")\"; });\n\n        bar.append(\"rect\")\n            .attr(\"x\", 1)\n            .attr(\"width\", function(d) { return x(d.dx+attribute.min) - 1; }) //x(histograms[0].dx+attribute.min) - 1\n            .attr(\"height\", function(d) { return height - y(d.y); })\n            .style('fill-opacity', 0.5 )\n            .style('fill', function(d){ return (d.color) } );\n\n        var xAxisG = svg.append(\"g\")\n            .attr(\"class\", \"x axis\")\n            .attr(\"transform\", \"translate(0,\" + height + \")\")\n            .call(xAxis);\n        xAxisG.selectAll(\"text\")\n          .attr(\"y\", 0)\n          .attr(\"x\", 9)\n          .attr(\"dy\", \".35em\")\n          //旋转x轴label\n          .attr(\"transform\", \"rotate(30)\")\n          .style(\"text-anchor\", \"start\");\n        xAxisG.append(\"text\")\n            .attr(\"transform\", \"translate(-40,\" + 30 + \")\" )\n            .style(\"text-anchor\", \"start\")\n            .text(attribute.name);\n\n        svg.append(\"g\")\n            .attr(\"class\", \"x axis\")\n            //.attr('stroke-width','1')\n            .call(yAxis)\n            .append(\"text\")\n              .attr(\"transform\", \"rotate(-90)\")\n              .attr(\"y\", -margin.left)\n              .attr(\"dy\", \".71em\")\n              .style(\"text-anchor\", \"end\")\n              .text(function() { return ( parameterMap.isFrequency ? \"Frequency\" : \"Probability\" ); } );\n\n\n    }\n};\n"

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(27))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	module.exports = "var variantFrequencyConfiguration = {\n    name: \"Transition/Transversion Ratio\",\n    attributes: [{\n            name: \"Reference Allele\",\n            type: \"string\",\n            variable: \"reference\"\n        },\n        {\n            name: \"Alternative Allele\",\n            type: \"string\",\n            variable: \"alternative\"\n        }],\n    parameters: [{\n            name: \"Show Matrix\",\n            type: \"boolean\",\n            variable: \"showMatrix\"\n        }],\n    render: function( elementId, selections, attributes, attributeMap, parameterMap ) {\n        var data = [];\n\n        var attributeReference = attributes[attributeMap.reference];\n        var attributeAlternative = attributes[attributeMap.alternative];\n\n        // create data structure: array of pair arrays for each selection\n        for ( var s = 0; s < selections.getSize(); ++s ) {\n\n            var max = 0;\n\n            var values =\n                [\n                    [0,0,0,0], //A -> A, C, G, T\n                    [0,0,0,0], //C -> A, C, G, T\n                    [0,0,0,0], //G -> A, C, G, T\n                    [0,0,0,0]  //T -> A, C, G, T\n                ];\n\n            var transitions = 0;\n            var transversions = 0;\n\n            var nucleotideIndexMap = { A: 0, C: 1, G: 2, T: 3 };\n\n            var selection = selections.getSelection(s);\n\n            for ( var i = 0; i < selection.items.length; ++i ) {\n                var referenceIndex = nucleotideIndexMap[attributeReference.values[selection.items[i]]];\n                var alternativeIndex = nucleotideIndexMap[attributeAlternative.values[selection.items[i]]];\n                values[referenceIndex][alternativeIndex] += 1;\n\n                if ( values[referenceIndex][alternativeIndex] > max ) {\n                    max = values[referenceIndex][alternativeIndex];\n                }\n\n                var change = attributeReference.values[selection.items[i]] + attributeAlternative.values[selection.items[i]];\n\n                if ( change === \"AG\" || change === \"GA\" || change === \"CT\" || change === \"TC\" ) {\n                    transitions += 1;\n                }\n                else {\n                    transversions += 1;\n                }\n\n            }\n\n            values.color = selections.getColor( selection );\n            values.transitions = transitions;\n            values.transversions = transversions;\n            values.max = max;\n\n            data.push( values );\n        }\n\n        d3.select( elementId ).html( \"\" );\n        var viewer = d3.select( elementId );\n\n        viewer.selectAll( 'p' )\n                .data( data )\n            .enter()\n                .append( 'p' )\n                .html( function( d ) {  return ( 'ti/tv = ' + d3.round( d.transitions / d.transversions, 3 ) + ' (' + d.transitions + '/' + d.transversions + ')' ); } )\n                .style( \"color\", function( d ) { return ( d.color ); } );\n\n        if (!parameterMap.showMatrix) {\n            return;\n        }\n\n        var margin = {top: 20, right: 20, bottom: 30, left: 40},\n            width = 960 - margin.left - margin.right,\n            height = 500 - margin.top - margin.bottom;\n\n        var size = 20;\n\n        for ( var s = 0; s < selections.getSize(); ++s ) {\n\n            var x = d3.scale.ordinal()\n                .domain(['A', 'C', 'G', 'T'])\n                .rangePoints([0.5*size,3.5*size]);\n\n            var y = d3.scale.ordinal()\n                .domain(['A', 'C', 'G', 'T'])\n                .rangePoints([0.5*size,3.5*size]);\n\n            var xAxis = d3.svg.axis()\n                .scale(x)\n                .orient(\"bottom\");\n\n            var yAxis = d3.svg.axis()\n                .scale(y)\n                .orient(\"left\");\n\n            var color = d3.scale.linear()\n                .domain([0,data[s].max])\n                .range([\"#e8e8e8\", \"#080808\"]);\n\n            var svg = d3.select(elementId).append(\"svg\")\n                .attr(\"width\", size * 5 + margin.left + margin.right)\n                .attr(\"height\", size * 5 + margin.top + margin.bottom)\n              .append(\"g\")\n                .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n            svg.append(\"g\")\n                .attr(\"class\", \"x axis\")\n                .attr(\"transform\", \"translate(0,\" + size*4 + \")\")\n                .attr('stroke-width','0')\n                .call(xAxis)\n            .append(\"text\")\n              .attr(\"transform\", \"translate(0,\" + (size+10) + \")\" )\n              .style(\"text-anchor\", \"start\")\n              .text(\"Ref Allele\");\n\n            svg.append(\"g\")\n                .attr(\"class\", \"y axis\")\n                .attr('stroke-width','0')\n                .call(yAxis)\n            .append(\"text\")\n              .attr(\"transform\", \"rotate(-90)\")\n              .attr(\"y\", -10-size)\n              .attr(\"dy\", \".71em\")\n              .style(\"text-anchor\", \"end\")\n              .text(\"Alt Allele\");\n\n            var hm = svg.append(\"svg:g\");\n            var hmrows = hm.selectAll(\"g\")\n                    .data(data)\n                    .enter().append(\"svg:g\")\n                    .attr(\"transform\", function(d, i) {\n                            return \"translate(0,\" + (size * i) + \")\";\n                        });\n\n            var hmcells = hmrows.selectAll(\"g\")\n                    .data(function(d,i) { return d; })\n                .enter().append(\"svg:g\")\n                    .attr(\"transform\", function(d, i) {\n                            return \"translate(\" + (size * i) + \",0)\";\n                        });\n\n            hmcells = hmcells.selectAll('rect')\n                    .data(function(d,i) { return d; })\n                .enter().append(\"svg:rect\")\n                    .attr(\"width\", size)\n                    .attr(\"height\", size)\n                    .attr(\"transform\", function(d, i) {\n                            return \"translate(0,\" + (size * i) + \")\";\n                        })\n                    .attr('fill', function(d,i) { return( color(d) ); })\n                    .attr('stroke', 'white');\n        }\n    }\n};\n"

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(29))

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	module.exports = "/**\n * author: Nils Gehlenborg - nils@hms.harvard.edu\n*/\n\nvar ElementViewerConfigurations = {\n    scatterplot: scatterplotConfiguration,\n    histogram: histogramConfiguration,\n    wordCloud: wordCloudConfiguration,\n    variantFrequency: variantFrequencyConfiguration,\n};\n\n\n$(EventManager).bind(\"element-viewer-removed\", function (event, data) {\n});\n\n\n$(EventManager).bind(\"element-viewer-added\", function (event, data) {\n});\n\n\n$(EventManager).bind(\"element-viewer-activated\", function (event, data) {\n    elementViewers.renderViewer();\n});\n\n\nvar ElementViewerCollection = function( controllerElementId, viewerElementId ) {\n    var self = this;\n\n    self.list = [];\n    self.activeIndex = undefined;\n\n    self.controllerElementId = controllerElementId;\n    self.viewerElementId = viewerElementId;\n};\n\nElementViewerCollection.prototype.reset = function() {\n    var self = this;\n\n    self.list = [];\n    self.activeIndex = undefined;\n};\n\n\n\nElementViewerCollection.prototype.add = function( elementViewer, isActive ) {\n    var self = this;\n\n    isActive = isActive | false;\n\n    self.list.push( elementViewer );\n\n    $(EventManager).trigger(\"element-viewer-added\", { viewer: elementViewer });\n\n    if ( isActive ) {\n        self.setActiveIndex( self.list.length - 1 );\n    }\n};\n\n\nElementViewerCollection.prototype.remove = function( elementViewer ) {\n    var self = this;\n\n    for ( var i = 0; i < self.list.length; ++i ) {\n        if ( self.list[i].uuid === elementViewer.uuid ) {\n            self.list.splice(i, 1);\n\n            $(EventManager).trigger(\"element-viewer-removed\", { viewer: elementViewer });\n\n            if ( i === self.activeIndex ) {\n                if (self.list.length > 0) {\n                    self.setActiveIndex( i - 1 );\n                }\n                else {\n                    self.setActiveIndex(undefined);\n                }\n            }\n        }\n    }\n};\n\n\nElementViewerCollection.prototype.activateNext = function() {\n    var self = this;\n\n    if ( self.activeIndex < self.list.length - 1 ) {\n        self.setActiveIndex( self.activeIndex + 1 );\n    }\n    else if ( self.activeIndex === self.list.length -1 ) {\n        self.setActiveIndex( 0 );\n    }\n    else {\n        self.setActiveIndex( undefined );\n    }\n};\n\nElementViewerCollection.prototype.activatePrevious = function() {\n    var self = this;\n\n    if ( self.activeIndex > 0 ) {\n        self.setActiveIndex( self.activeIndex - 1 );\n    }\n    else if ( self.activeIndex === 0 ) {\n        self.setActiveIndex( self.list.length - 1 );\n    }\n    else {\n        self.setActiveIndex( undefined );\n    }\n};\n\n\nElementViewerCollection.prototype.getIndex = function( elementViewer ) {\n    var self = this;\n\n    for ( var i = 0; i < self.list.length; ++i ) {\n        if ( this.list[i].uuid === elementViewer.uuid ) {\n            return ( i );\n        }\n    }\n\n    return ( undefined );\n};\n\n\nElementViewerCollection.prototype.setActiveIndex = function( index ) {\n    var self = this;\n\n    if ( index < self.list.length && index >= 0 && self.activeIndex !== index ) {\n        self.activeIndex = index;\n\n        $(EventManager).trigger(\"element-viewer-activated\", { viewer: self.list[self.activeIndex], index: index });\n    }\n};\n\n\nElementViewerCollection.prototype.setActive = function( elementViewer ) {\n    var self = this;\n\n    var index = self.getIndex( elementViewer );\n\n    if ( index ) {\n        self.setActiveIndex( index );\n    }\n\n    return ( index );\n};\n\n\nElementViewerCollection.prototype.getActive = function() {\n    var self = this;\n\n    if ( self.activeIndex === undefined ) {\n        return undefined;\n    }\n\n    return ( self.list[self.activeIndex] );\n};\n\n// render the controller (i.e. list of viewers that can be added and a \"new\" button)\nElementViewerCollection.prototype.renderController = function() {\n    var self = this;\n    var controllerElement = d3.select( self.controllerElementId );\n\n    controllerElement.html(\"\");\n    var dataSetDescription = dataSetDescriptions[queryParameters['dataset']];\n    if (dataSetDescription && dataSetDescription.elementViewers ) {\n      dataSetDescription.elementViewers.forEach(function(elementViewerInitConfig){\n        var elementViewerConfiguration = ElementViewerConfigurations[elementViewerInitConfig.type];\n        if (elementViewerConfiguration) {\n            var elementViewer = new ElementViewer( attributes, selections, elementViewerConfiguration );\n            self.add( elementViewer );\n            var index = self.getIndex( elementViewer );\n            self.activeIndex = index;\n            Object.assign(elementViewer.attributeMap, elementViewerInitConfig.attribute)\n            Object.assign(elementViewer.parameterMap, elementViewerInitConfig.parameter)\n            self.renderViewer();\n        }\n      })\n    }\n    if (!queryParameters['showElementViewerController']) {return}\n\n    // create header and controls\n    var viewerElementHeaderLeft = controllerElement.append( \"div\" ).attr( \"class\", \"element-viewer-header\" );\n\n    viewerElementHeaderLeft.append( \"div\" )\n            .attr( \"class\", \"element-viewer-editor-button level-1-button\" )\n            .attr( \"id\", \"element-viewer-add\" )\n            .on( \"click\", function() {\n                var selector = document.getElementById( 'element-viewer-selector' );\n                var elementViewerConfiguration = selector.options[selector.selectedIndex].__data__;\n                var elementViewer = new ElementViewer( attributes, selections, elementViewerConfiguration );\n                self.add( elementViewer );\n                var index = self.getIndex( elementViewer );\n                self.activeIndex = index;\n                self.renderViewer( true );\n            })\n        .append( \"i\" ).\n            attr( \"class\", \"fa fw fa-plus\" );\n\n    var select = controllerElement.append('select');\n\n    // convert ElementViewerConfiguration into array\n    var viewerConfigurationList = $.map(ElementViewerConfigurations, function(value, index) {\n        return [value];\n    });\n\n    select.attr('id', 'element-viewer-selector')\n        .selectAll('option')\n            .data( viewerConfigurationList )\n        .enter()\n            .append('option')\n            .attr('value', function (d, i) {\n                return i;\n            })\n        .text(function (d) {\n            return d.name;\n        });\n\n    var viewerElementHeaderRight = controllerElement.append( \"div\" ).attr( \"class\", \"element-viewer-header\" );\n\n    viewerElementHeaderRight.append( \"div\" )\n            .attr( \"class\", \"element-viewer-editor-button level-1-button\" )\n            .attr( \"id\", \"element-viewer-previous\" )\n            .on( \"click\", function() {\n                self.activatePrevious();\n            })\n        .append( \"i\" ).\n            attr( \"class\", \"fa fw fa-arrow-left\" );\n\n    viewerElementHeaderRight.append( \"div\" )\n            .attr( \"class\", \"element-viewer-editor-button level-1-button\" )\n            .attr( \"id\", \"element-viewer-next\" )\n            .on( \"click\", function() {\n                self.activateNext();\n            })\n        .append( \"i\" ).\n            attr( \"class\", \"fa fw fa-arrow-right\" );\n\n\n    viewerElementHeaderRight.append( \"div\" )\n            .attr( \"class\", \"element-viewer-editor-button level-1-button\" )\n            .attr( \"id\", \"element-viewer-edit\" )\n            .on( \"click\", function() {\n                self.renderViewer( true );\n            })\n        .append( \"i\" ).\n            attr( \"class\", \"fa fw fa-pencil\" );\n\n    viewerElementHeaderRight.append( \"div\" )\n            .attr( \"class\", \"element-viewer-editor-button level-1-button\" )\n            .attr( \"id\", \"element-viewer-remove\" )\n            .on( \"click\", function() {\n                self.remove( self.getActive() );\n                self.renderViewer();\n            })\n        .append( \"i\" ).\n            attr( \"class\", \"fa fw fa-times-circle\" );\n\n};\n\n// render the active viewer\nElementViewerCollection.prototype.renderViewer = function( showEditor ) {\n    var self = this;\n\n    var viewerElement = d3.select( self.viewerElementId );\n\n    // clear element\n    viewerElement.html(\"\");\n    viewerElement = viewerElement.append( \"div\" ).attr( \"class\", \"element-viewer-active\" );\n\n    // check if there is a viewer\n    if ( self.list.length === 0 ) {\n        viewerElement.append( \"div\" ).attr( \"class\", \"info-message\" ).html( 'No visualizations configured. Click <i class=\"fa fw fa-plus\"></i> button to add a new visualization.' );\n\n        return self;\n    }\n\n    // if no active viewer is set, use the first one in the list\n    if ( self.activeIndex === undefined ) {\n        self.activeIndex = 0;\n    }\n\n    // === render active viewer ===\n\n    // create viewer\n    var id = \"element-viewer-\" + self.getActive().uuid;\n\n    // create element and render viewer\n    viewerElement.append( \"div\" ).attr( \"id\", id );\n\n    if ( !showEditor ) {\n        self.getActive().renderViewer( '#' + id );\n    }\n    else {\n        self.getActive().renderEditor( '#' + id );\n    }\n\n    return self;\n};\n\n\nvar ElementViewer = function( attributes, selections, configuration, editorElementId, viewerElementId  ) {\n    var self = this;\n\n    self.attributes = attributes;\n    //self.selections = selections;\n    self.editorElementId = editorElementId;\n    self.viewerElementId = viewerElementId;\n    self.configuration = configuration;\n    self.uuid = Utilities.generateUuid();\n    self.attributeMap = {};\n    self.parameterMap = {};\n\n    self.initializeParameterMap();\n};\n\nElementViewer.prototype.initializeParameterMap = function() {\n    var self = this;\n\n    for ( var i = 0; i < self.configuration.parameters.length; ++i ) {\n        var parameter = self.configuration.parameters[i];\n\n        self.parameterMap[parameter.variable] = parameter.default;\n    }\n}\n\n\nElementViewer.prototype.renderViewer = function( viewerElementId ) {\n    var self = this;\n\n    viewerElementId = viewerElementId || self.viewerElementId;\n\n    try {\n        self.configuration.render( viewerElementId, selections, self.attributes, self.attributeMap, self.parameterMap )\n    }\n    catch ( error ) {\n        console.error( error );\n    }\n};\n\n\nElementViewer.prototype.renderEditor = function( editorElementId ) {\n    var self = this;\n\n    editorElementId = editorElementId || self.editorElementId;\n\n    var element = d3.select( editorElementId );\n\n    element.html( \"\" );\n\n    var editor = element.append('div').attr( 'id', 'element-viewer-editor-' + self.uuid );\n\n    editor.html( '<div>' +\n        '<div class=\"element-viewer-title\">' + self.configuration.name +'</div>' +\n        '&nbsp;<span class=\"element-viewer-editor-button level-2-button element-viewer-editor-save\" data-viewer-uuid=\"' + self.uuid + '\"\"><i class=\"fa fw fa-check\"></i></span>' +\n        '&nbsp;<span class=\"element-viewer-editor-button level-2-button element-viewer-editor-cancel\" data-viewer-uuid=\"' + self.uuid + '\"\"><i class=\"fa fw fa-times\"></i></span>' +\n        '</div>');\n\n    d3.selectAll( '.element-viewer-editor-save' ).on( 'click', function(event){\n        // parse changes, then render the viewer\n        self.parseParameterValues();\n        self.parseAttributeValues();\n\n        self.renderViewer( editorElementId );\n    });\n\n    d3.selectAll( '.element-viewer-editor-cancel' ).on( 'click', function(event){\n        // ignore changes, just render the viewer\n        self.renderViewer( editorElementId );\n    });\n\n    for ( var i = 0; i < self.configuration.attributes.length; ++i ) {\n        var attribute = self.configuration.attributes[i];\n        var attributeEditor = editor.append( 'div' ).style( \"margin-left\", \"10px\");\n        self.renderAttributeEditor( attributeEditor, self.attributes, attribute, self.attributeMap[attribute.variable] );\n    }\n\n    for ( var i = 0; i < self.configuration.parameters.length; ++i ) {\n        var parameter = self.configuration.parameters[i];\n        var parameterEditor = editor.append( 'div' ).style( \"margin-left\", \"10px\");\n        self.renderParameterEditor( parameterEditor, parameter, self.parameterMap[parameter.variable] );\n    }\n};\n\n\nElementViewer.prototype.parseParameterValues = function() {\n    var self = this;\n    var parameters = self.configuration.parameters;\n\n    for ( var i = 0; i < parameters.length; ++i ) {\n        var value = self.parseParameterValue( parameters[i].variable, parameters[i].type );\n\n        if ( value !== undefined ) {\n            //console.log( 'Replacing ' + parameters[i].variable + ' (' + parameters[i].type + ') = \"' + self.parameterMap[parameters[i].variable] + '\" with \"' + value + '\"' );\n            self.parameterMap[parameters[i].variable] = value;\n        }\n    }\n}\n\nElementViewer.prototype.parseAttributeValues = function() {\n    var self = this;\n    var attributes = self.configuration.attributes;\n\n    for ( var i = 0; i < attributes.length; ++i ) {\n        var value = self.parseAttributeValue( attributes[i].variable );\n\n        if ( value !== undefined ) {\n            //console.log( 'Replacing ' + attributes[i].variable + ' = \"' + self.attributeMap[attributes[i].variable] + '\" with \"' + value + '\"' );\n            self.attributeMap[attributes[i].variable] = value;\n        }\n    }\n}\n\nElementViewer.prototype.parseParameterValue = function( parameterVariable, parameterType ) {\n    var editor = d3.select('#element-viewer-editor-' + self.uuid );\n    if ( editor.length === 0 ) {\n        return undefined;\n    }\n\n    var value = undefined;\n\n    switch ( parameterType ) {\n        case 'float':\n            var editor = $('[data-element-viewer-parameter-variable=\"' + parameterVariable + '\"]' );\n            value = parseFloat( $( editor ).val() );\n            break;\n        case 'integer':\n            var editor = $('[data-element-viewer-parameter-variable=\"' + parameterVariable + '\"]' );\n            value = parseInt( $( editor ).val(), 10 );\n            break;\n        case 'boolean':\n            var editor = $('[data-element-viewer-parameter-variable=\"' + parameterVariable + '\"]' );\n            value = Boolean( $( editor ).is( ':checked' ) );\n            break;\n        case 'string':\n            // fall-through\n        default:\n            var editor = $('[data-element-viewer-parameter-variable=\"' + parameterVariable + '\"]' );\n            value = $( editor ).val();\n            break;\n    }\n\n    return ( value );\n}\n\n\nElementViewer.prototype.parseAttributeValue = function( attributeVariable ) {\n    var editor = d3.select('#element-viewer-editor-' + self.uuid );\n    if ( editor.length === 0 ) {\n        return undefined;\n    }\n\n    var value = undefined;\n\n    editor = $('[data-element-viewer-attribute-variable=\"' + attributeVariable + '\"]' );\n\n    value = parseInt( $( editor ).val(), 10 );\n\n    return ( value );\n}\n\n\nElementViewer.prototype.renderParameterEditor = function( element, parameter, value ) {\n    var self = this;\n    var s = \"\";\n\n    s += '<div data-element-viewer-parameter-type=\"' + parameter.type + '\">';\n\n    switch ( parameter.type ) {\n        case 'float':\n            s += parameter.name + ' ' + '<input data-element-viewer-parameter-variable=\"' + parameter.variable + '\" type=\"number\" step=\"0.1\" value=\"' + d3.format('f')(value) + '\"></input>';\n            break;\n        case 'integer':\n            s +=  parameter.name + ' ' + '<input data-element-viewer-parameter-variable=\"' + parameter.variable + '\" type=\"number\" step=\"1\" value=\"' + d3.format('d')(value) + '\"></input>';\n            break;\n        case 'boolean':\n            s +=  parameter.name + ' ' + '<input data-element-viewer-parameter-variable=\"' + parameter.variable + '\" type=\"checkbox\" ' + ( value ? 'checked' : '' ) + '></input>';\n            break;\n        case 'string':\n            // fall-through\n        default:\n            s += parameter.name + ' ' + '<input data-element-viewer-parameter-variable=\"' + parameter.variable + '\" type=\"text\" value=\"' + value + '\"></input>';\n            break;\n    }\n\n    s += '</div>';\n\n    // add to DOM\n    element.html(s);\n\n    // attach events ...\n    // none right now\n};\n\n\nElementViewer.prototype.renderAttributeEditor = function( element, attributes, attribute, value ) {\n    var self = this;\n    var s = \"\";\n\n    s += '<div data-element-viewer-attribute-type=\"' + attribute.type + '\">';\n\n    s += '<b>' + attribute.name + '</b>' + '<select data-element-viewer-attribute-variable=\"' + attribute.variable +'\">';\n    for ( var i = 0; i < attributes.length; ++i ) {\n        if ( Attribute.matchesType( attributes[i].type, attribute.type ) ) {\n            if ( value && value === i ) {\n                s += '<option value=\"' + i + '\" selected>' + attributes[i].name + '</option>';\n            }\n            else {\n                s += '<option value=\"' + i + '\">' + attributes[i].name + '</option>';\n            }\n        }\n    }\n    s += \"</select>\";\n    s += '</div>';\n\n    // add to DOM\n    element.html(s);\n\n    // attach events ...\n    // none right now\n};\n"

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(31))

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	module.exports = "/**\n * author: Alexander Lex - alex@seas.harvard.edu\n * author: Nils Gehlenborg - nils@hms.harvard.edu\n * author: Hendrik Srtobelt - strobelt@seas.harvard.edu\n * author: Romain Vuillemot - romain.vuillemot@gmail.com\n */\n\nvar dataSetDescriptions = []\nvar queryParameters = {};\nvar initCallback; // function to call when dataset is loaded\nvar globalCtx;\n\n\nvar defaultDatasets = [\n{\n  \"file\": \"data/simpsons/simpsons.csv\",\n  \"name\": \"Simpsons Characters\",\n  \"header\": 0,\n  \"separator\": \"\\t\",\n  \"skip\": 0,\n  \"meta\": [\n    {\n      \"type\": \"id\",\n      \"index\": 0,\n      \"name\": \"Name\"\n    }\n  ],\n  \"sets\": [\n    {\n      \"format\": \"binary\",\n      \"start\": 1,\n      \"end\": 6\n    }\n  ],\n  \"author\": \"Alexander Lex\",\n  \"description\": \"A collection of simpsons characters and their attributes.\",\n  \"source\": \"http://www.thesimpsons.com/\",\n  \"data\": [\n    [\n      \"\",\n      \"School\",\n      \"Blue Hair\",\n      \"Duff Fan\",\n      \"Evil\",\n      \"Male\",\n      \"Power Plant\",\n      \"Age\"\n    ],\n    [\n      \"Lisa\",\n      \"1\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"8\"\n    ],\n    [\n      \"Bart\",\n      \"1\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"10\"\n    ],\n    [\n      \"Homer\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"40\"\n    ],\n    [\n      \"Marge\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"36\"\n    ],\n    [\n      \"Maggie\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\"\n    ],\n    [\n      \"Barney\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"39\"\n    ],\n    [\n      \"Mr. Burns\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"1\",\n      \"90\"\n    ],\n    [\n      \"Mo\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"41\"\n    ],\n    [\n      \"Ned\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"42\"\n    ],\n    [\n      \"Milhouse\",\n      \"1\",\n      \"1\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"10\"\n    ],\n    [\n      \"Grampa\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"85\"\n    ],\n    [\n      \"Krusty\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"1\",\n      \"0\",\n      \"46\"\n    ],\n    [\n      \"Smithers\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"1\",\n      \"33\"\n    ],\n    [\n      \"Ralph\",\n      \"1\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"8\"\n    ],\n    [\n      \"Sideshow Bob\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"0\",\n      \"37\"\n    ],\n    [\n      \"Kent Brockman\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"45\"\n    ],\n    [\n      \"Fat Tony\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"0\",\n      \"50\"\n    ],\n    [\n      \"Jacqueline Bouvier \",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"76\"\n    ],\n    [\n      \"Patty Bouvier\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"45\"\n    ],\n    [\n      \"Selma Bouvier\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"45\"\n    ],\n    [\n      \"Lenny Leonard\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"38\"\n    ],\n    [\n      \"Carl Carlson\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"37\"\n    ],\n    [\n      \"Nelson\",\n      \"1\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"1\",\n      \"0\",\n      \"11\"\n    ],\n    [\n      \"Martin Prince\",\n      \"1\",\n      \"0\",\n      \"0\",\n      \"0\",\n      \"1\",\n      \"0\",\n      \"10\"\n    ]\n  ]\n}\n]\n\nfunction initData(ctx, callback, datasets) {\n    dataSetDescriptions = [];\n    datasets = datasets || defaultDatasets;\n\n    retrieveQueryParameters();\n    setUpGUIElements();\n\n    initCallback = callback;\n    globalCtx = ctx;\n    loadDataSetDescriptions(datasets);\n}\n\nvar handleDatasetDescription = function (result) {\n    if (result != undefined) {\n        dataSetDescriptions.push(result);\n    }\n}\n\nfunction loadDataSetDescriptions(dataSetList) {\n\n    for (var i = 0; i < dataSetList.length; ++i) {\n        var url = dataSetList[i];\n        handleDatasetDescription(url);\n    }\n    changeDataset();\n}\n\n/**\n * Replace or load a new dataset based on the dataset index in the query parameters\n */\nvar changeDataset = function () {\n\n    $(EventManager).trigger(\"loading-dataset-started\", { description: dataSetDescriptions[queryParameters['dataset']]  });\n\n    sets.length = 0;\n    subSets.length = 0;\n    usedSets.length = 0;\n    dataRows.length = 0;\n    depth = 0;\n    allItems.length = 0;\n    attributes.length = 0;\n    selectedAttributes = {};\n    previousState = undefined;\n\n    UpSetState.logicGroups = [];\n    UpSetState.logicGroupChanged = true;\n\n    loadDataSet(queryParameters['dataset']);\n\n    // updateQueryParameters();\n\n    clearSelections();\n}\n\nfunction loadDataSet(index) {\n    processDataSet(dataSetDescriptions[index]);\n}\n\nfunction processDataSet(dataSetDescription) {\n    parseDataSet(dataSetDescription.data, dataSetDescription);\n    run();\n}\n\n/**\n * Setting up the html GUI elements\n */\nvar setUpGUIElements = function () {\n\n    var maxCardSpinner = document.getElementById('maxCardinality');\n    var minCardSpinner = document.getElementById('minCardinality');\n\n    var updateCardinality = function (e) {\n        UpSetState.maxCardinality = maxCardSpinner.value;\n        UpSetState.minCardinality = minCardSpinner.value;\n        UpSetState.forceUpdate = true;\n        run();\n    };\n\n    maxCardSpinner.addEventListener('input', updateCardinality);\n    minCardSpinner.addEventListener('input', updateCardinality);\n\n    var hideEmptiesCheck = document.getElementById('hideEmpties');\n\n    var hideEmptiesFu = function (e) {\n        UpSetState.hideEmpties = hideEmptiesCheck.checked;\n        updateState();\n        // TODO: need to call updateTransition instead, but this needs to be exposed first\n        plot();\n        plotSetOverview();\n    };\n    hideEmptiesCheck.addEventListener('click', hideEmptiesFu);\n}\n\nfunction retrieveQueryParameters() {\n\n    // Variables from query string\n    var queryString = location.search.substring(1),\n        re = /([^&=]+)=([^&]*)/g, m;\n\n    // Creates a map with the query string parameters\n    while (m = re.exec(queryString)) {\n        queryParameters[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);\n    }\n\n    queryParameters['dataset'] = parseInt(queryParameters['dataset']) || 0;\n    queryParameters['duration'] = queryParameters['duration'] || 1000;\n    queryParameters['orderBy'] = queryParameters['orderBy'] || \"subsetSize\"; // deviation, intersection, specific set\n    queryParameters['grouping'] = queryParameters['grouping'] == \"undefined\" ? undefined : queryParameters['grouping'] || \"groupBySet\"; // groupByIntersectionSize,\n    queryParameters['selection'] = queryParameters['selection'] || \"\";\n    queryParameters['showElementViewerController'] = queryParameters['showElementViewerController'] || false;\n    // Missing item space query..\n\n}\n\nfunction updateQueryParameters() {\n    var urlQueryString = \"\";\n    if (Object.keys(queryParameters).length > 0) {\n        urlQueryString = \"?\";\n        for (var q in queryParameters) {\n            urlQueryString += (q + \"=\" + queryParameters[q]) + \"&\";\n        }\n        urlQueryString = urlQueryString.substring(0, urlQueryString.length - 1);\n    }\n\n    history.replaceState({}, 'Upset', window.location.origin + window.location.pathname + urlQueryString);\n}\n\nfunction clearSelections() {\n    selections = new SelectionList();\n}\n\nfunction createInitialSelection() {\n    var selection = new Selection(allItems, new FilterCollection(\"#filters-controls\", \"#filters-list\"));\n\n    selections.addSelection(selection, true);\n    selections.setActive(selection);\n}\n\nfunction run() {\n\n    elementViewers.reset();\n\n    setUpSubSets();\n    // setUpGroupings();\n    updateState();\n    initCallback.forEach(function (callback) {\n        callback();\n    })\n//    plot();\n\n//    plotSetSelection();\n    selections.setActive();\n    //createInitialSelection();\n    plotSetOverview({initialize: true});\n\n    $(EventManager).trigger(\"loading-dataset-finished\", { });\n}\n\nfunction getNumberOfSets(dataSetDescription) {\n    var sets = 0;\n\n    for (var i = 0; i < dataSetDescription.sets.length; ++i) {\n        var setDefinitionBlock = dataSetDescription.sets[i];\n\n        if (setDefinitionBlock.format === 'binary') {\n            sets += setDefinitionBlock.end - setDefinitionBlock.start + 1;\n        }\n        else {\n            console.error('Set definition format \"' + setDefinitionBlock.format + '\" not supported');\n        }\n    }\n\n    return ( sets );\n}\n\nfunction getNumberOfAttributes(dataSetDescription) {\n    return ( dataSetDescription.meta.length );\n}\n\nfunction getIdColumn(dataSetDescription) {\n    for (var i = 0; i < dataSetDescription.meta.length; ++i) {\n        if (dataSetDescription.meta[i].type === \"id\") {\n            return dataSetDescription.meta[i].index;\n        }\n    }\n\n    // id column not defined, assume 0\n    return 0;\n}\n\nfunction parseDataSet(data, dataSetDescription) {\n    // the raw set arrays\n    var rawSets = [];\n    var setNames = [];\n\n    var file = data;\n    // the names of the sets are in the columns\n    var header = file[dataSetDescription.header];\n\n    // remove header\n    file.splice(dataSetDescription.header, 1);\n\n    // load set assignments\n    var processedSetsCount = 0;\n    for (var i = 0; i < dataSetDescription.sets.length; ++i) {\n        var setDefinitionBlock = dataSetDescription.sets[i];\n\n        if (setDefinitionBlock.format === 'binary') {\n            var setDefinitionBlockLength = setDefinitionBlock.end - setDefinitionBlock.start + 1;\n\n            // initialize the raw set arrays\n            for (var setCount = 0; setCount < setDefinitionBlockLength; ++setCount) {\n                rawSets.push(new Array());\n            }\n\n            var rows = file.map(function (row, rowIndex) {\n                return row.map(function (value, columnIndex) {\n\n                    if (columnIndex >= setDefinitionBlock.start && columnIndex <= setDefinitionBlock.end) {\n                        var intValue = parseInt(value, 10);\n\n                        if (isNaN(intValue)) {\n                            console.error('Unable to convert \"' + value + '\" to integer (row ' + rowIndex + ', column ' + columnIndex + ')');\n                        }\n\n                        return intValue;\n                    }\n\n                    return null;\n                });\n            });\n            // iterate over columns defined by this set definition block\n            for (var r = 0; r < rows.length; r++) {\n                // increment number of items in data set\n                // only increment depth when we are processing the first set definition block (we will already iterate overall rows)\n                if (i === 0) {\n                    allItems.push(depth++);\n                }\n\n                for (var s = 0; s < setDefinitionBlockLength; ++s) {\n                    rawSets[processedSetsCount + s].push(rows[r][setDefinitionBlock.start + s]);\n\n                    if (r === 0) {\n                        setNames.push(header[setDefinitionBlock.start + s]);\n                    }\n                }\n            }\n\n            processedSetsCount += setDefinitionBlockLength;\n        }\n        else {\n            console.error('Set definition format \"' + setDefinitionBlock.format + '\" not supported');\n        }\n    }\n\n    // initialize sets and set IDs\n    var setPrefix = \"S_\";\n    //var setID = 1;\n    var nrDefaultSelectedSets = dataSetDescription.nrDefaultSets || nrDefaultSets\n    if (nrDefaultSelectedSets < 3) {\n      nrDefaultSelectedSets = 3;\n    }\n    for (var i = 0; i < rawSets.length; i++) {\n        var combinedSets = Array.apply(null, new Array(rawSets.length)).map(Number.prototype.valueOf, 0);\n        combinedSets[i] = 1;\n        var set = new USet(setPrefix + i, setNames[i], combinedSets, rawSets[i]);\n        setIdToSet[setPrefix + i] = set;\n        sets.push(set);\n        if (i < nrDefaultSelectedSets) {\n            set.isSelected = true;\n            usedSets.push(set);\n        }\n        // setID = setID << 1;\n    }\n\n    // initialize attribute data structure\n    attributes.length = 0;\n    for (var i = 0; i < dataSetDescription.meta.length; ++i) {\n        var metaDefinition = dataSetDescription.meta[i];\n\n        attributes.push({\n            name: metaDefinition.name || header[metaDefinition.index],\n            type: metaDefinition.type,\n            format: metaDefinition.format,\n            hidden: metaDefinition.hidden,\n            hideStatics: metaDefinition.hideStatics,\n            values: [],\n            sort: 1\n        });\n    }\n\n    // add implicit attributes\n    var setCountAttribute = {\n        name: 'Set Count',\n        type: 'integer',\n        values: [],\n        sort: 1,\n        min: 0\n    };\n\n    for (var d = 0; d < depth; ++d) {\n        var setCount = 0;\n        for (var s = 0; s < rawSets.length; s++) {\n            setCount += rawSets[s][d];\n        }\n        setCountAttribute.values[d] = setCount;\n    }\n    attributes.push(setCountAttribute);\n\n    var setsAttribute = {\n        name: 'Sets',\n        type: 'sets',\n        values: [],\n        sort: 1\n    };\n\n    for (var d = 0; d < depth; ++d) {\n        var setList = [];\n        for (var s = 0; s < rawSets.length; s++) {\n            if (rawSets[s][d] === 1) {\n                //setList.push(Math.floor(Math.pow(2, s)));\n                setList.push(sets[s].id)\n            }\n        }\n        setsAttribute.values[d] = setList;\n    }\n    attributes.push(setsAttribute);\n\n    // load meta data\n    for (var i = 0; i < dataSetDescription.meta.length; ++i) {\n        var metaDefinition = dataSetDescription.meta[i];\n\n        attributes[i].values = file.map(function (row, rowIndex) {\n            var value = row[metaDefinition.index];\n            switch (metaDefinition.type) {\n                case 'integer':\n                    var intValue = parseInt(value, 10);\n                    if (isNaN(intValue)) {\n                        console.error('Unable to convert \"' + value + '\" to integer.');\n                        return NaN;\n                    }\n                    return intValue;\n                case 'float':\n                    var floatValue = parseFloat(value, 10);\n                    if (isNaN(floatValue)) {\n                        console.error('Unable to convert \"' + value + '\" to float.');\n                        return NaN;\n                    }\n                    return floatValue;\n                case 'id':\n                // fall-through\n                case 'string':\n                // fall-through\n                default:\n                    return value;\n            }\n\n        });\n    }\n\n    var max\n\n    // add meta data summary statistics\n    for (var i = 0; i < attributes.length; ++i) {\n\n        if (attributes[i].type === \"float\" || attributes[i].type === \"integer\") {\n            // explictly defined attributes might have user-defined ranges\n            if (i < dataSetDescription.meta.length) {\n                attributes[i].min = dataSetDescription.meta[i].min || Math.min.apply(null, attributes[i].values);\n                attributes[i].max = dataSetDescription.meta[i].max || Math.max.apply(null, attributes[i].values);\n            }\n            // implicitly defined attributes\n            else {\n                attributes[i].min = attributes[i].min || Math.min.apply(null, attributes[i].values);\n                attributes[i].max = attributes[i].max || Math.max.apply(null, attributes[i].values);\n            }\n        }\n    }\n\n    UpSetState.maxCardinality = attributes[attributes.length - 2].max;\n    if (isNaN(UpSetState.maxCardinality)) {\n        // fixme hack to make it work without attributes\n        UpSetState.maxCardinality = sets.length;\n    }\n    var maxCardSpinner = document.getElementById('maxCardinality');\n    maxCardSpinner.value = UpSetState.maxCardinality;\n    maxCardSpinner.max = UpSetState.maxCardinality;\n    var minCardSpinner = document.getElementById('minCardinality');\n    minCardSpinner.max = UpSetState.maxCardinality;\n\n    updateDatasetInformation(dataSetDescription)\n\n}\n\nvar updateDatasetInformation = function (dataSetDescription) {\n\n    var infoBox = $('#dataset-info-content');\n    infoBox.empty();\n    //infoBox.append('<hr><br />');\n    infoBox.append('<p style=\"padding-bottom: 5px\">');\n    infoBox.append(\"<b>Name:</b> \" + dataSetDescription.name + \"<br />\");\n    infoBox.append(\"<b># 标签总数:</b> \" + sets.length + \"<br />\");\n    infoBox.append(\"<b># 文章总数:</b> \" + depth + \"<br />\");\n    infoBox.append('</p> <p style=\"padding-bottom: 10px\">');\n    if (dataSetDescription.author) {\n        infoBox.append(\"<b>作者</b>: \" + dataSetDescription.author + \"<br />\");\n    }\n    if (dataSetDescription.description) {\n        infoBox.append(\"<b>描述:</b> <br />\" + dataSetDescription.description + \"<br />\");\n    }\n    if (dataSetDescription.source) {\n        if (dataSetDescription.source.indexOf(\"http://\") == 0) {\n            var urlText = dataSetDescription.source;\n            var numCharacters = 22;\n            if (urlText.length > numCharacters) {\n                urlText = urlText.substring(0, numCharacters) + \"..\"\n            }\n\n            infoBox.append(\"<b>来源:</b> <br /><a href=\\\"\" + dataSetDescription.source + \"\\\">\" + urlText + \"</a><br />\");\n\n        } else {\n            infoBox.append(\"<b>来源:</b> <br />\" + dataSetDescription.source + \"<br />\");\n        }\n    }\n\n    infoBox.append('</p>');\n\n}\n\nfunction createSignature(listOfUsedSets, listOfSets) {\n    return listOfUsedSets.map(function (d) {\n        return (listOfSets.indexOf(d) > -1) ? 1 : 0\n    }).join(\"\")\n\n}\n\nfunction setUpSubSets() {\n\n    $(EventManager).trigger(\"computing-subsets-started\", undefined);\n\n    combinations = Math.pow(2, usedSets.length) - 1;\n\n    subSets.length = 0;\n\n    var aggregateIntersection = {}\n\n    var listOfUsedSets = usedSets.map(function (d) {\n        return d.id\n    })\n\n    var setsAttribute = attributes.filter(function (d) {\n        return d.type == \"sets\"\n    })[0];\n\n    var signature = \"\";\n\n    var itemList;\n    //HEAVY !!!\n    setsAttribute.values.forEach(function (listOfSets, index) {\n        signature = createSignature(listOfUsedSets, listOfSets)\n        itemList = aggregateIntersection[signature];\n        if (itemList == null) {\n            aggregateIntersection[signature] = [index];\n        } else {\n            itemList.push(index);\n        }\n    })\n\n    // used Variables for iterations\n    var tempBitMask = 0;\n    var usedSetLength = usedSets.length\n    var combinedSetsFlat = \"\";\n    var actualBit = -1;\n    var names = [];\n\n    if (usedSetLength > 20) { // TODo HACK !!!!\n        Object.keys(aggregateIntersection).forEach(function (key) {\n            var list = aggregateIntersection[key]\n\n            var combinedSets = key.split(\"\");\n\n            //combinedSetsFlat = combinedSets.join(\"\");\n\n//            if (card>UpSetState.maxCardinality) continue;//UpSetState.maxCardinality = card;\n//            if (card<UpSetState.minCardinality) continue;//UpSetState.minCardinality = card;\n\n            names = [];\n            var expectedValue = 1;\n            var notExpectedValue = 1;\n            // go over the sets\n            combinedSets.forEach(function (d, i) {\n                    if (d == 1) { // if set is present\n                        names.push(usedSets[i].elementName);\n                        expectedValue = expectedValue * usedSets[i].dataRatio;\n                    } else {\n                        notExpectedValue = notExpectedValue * (1 - usedSets[i].dataRatio);\n                    }\n                }\n            );\n\n            //        console.log(expectedValue, notExpectedValue);\n            expectedValue *= notExpectedValue;\n\n            //        console.log(combinedSetsFlat);\n\n            var name = \"\";\n            if (names.length > 0) {\n                name = names.reverse().join(\" \") + \" \" // not very clever\n            }\n\n            //        var arghhList = Array.apply(null,new Array(setsAttribute.values.length)).map(function(){return 0})\n            //        list.forEach(function(d){arghhList[d]=1});\n\n//            console.log(parseInt(key,2), name, combinedSets, list, expectedValue);\n\n            var subSet = new SubSet(bitMask, name, combinedSets, list, expectedValue);\n            subSets.push(subSet);\n\n        })\n\n    } else {\n        for (var bitMask = 0; bitMask <= combinations; bitMask++) {\n            tempBitMask = bitMask;//originalSetMask\n\n            var card = 0;\n            var combinedSets = Array.apply(null, new Array(usedSetLength)).map(function () {  //combinedSets\n                actualBit = tempBitMask % 2;\n                tempBitMask = (tempBitMask - actualBit) / 2;\n                card += actualBit;\n                return +actualBit\n            }).reverse() // reverse not necessary.. just to keep order\n\n            combinedSetsFlat = combinedSets.join(\"\");\n\n            if (card > UpSetState.maxCardinality) continue;//UpSetState.maxCardinality = card;\n            if (card < UpSetState.minCardinality) continue;//UpSetState.minCardinality = card;\n\n            names = [];\n            var expectedValue = 1;\n            var notExpectedValue = 1;\n            // go over the sets\n            combinedSets.forEach(function (d, i) {\n\n\n                    //                console.log(usedSets[i]);\n                    if (d == 1) { // if set is present\n                        names.push(usedSets[i].elementName);\n//                    expectedValue*=expectedValueForOneSet;\n                        expectedValue = expectedValue * usedSets[i].dataRatio;\n                    } else {\n                        notExpectedValue = notExpectedValue * (1 - usedSets[i].dataRatio);\n                    }\n                }\n            );\n\n            //        console.log(expectedValue, notExpectedValue);\n            expectedValue *= notExpectedValue;\n\n            //        console.log(combinedSetsFlat);\n            var list = aggregateIntersection[combinedSetsFlat];\n            if (list == null) {\n                list = [];\n            }\n\n            var name = \"\";\n            if (names.length > 0) {\n                name = names.reverse().join(\" \") + \" \" // not very clever\n            }\n\n            //        var arghhList = Array.apply(null,new Array(setsAttribute.values.length)).map(function(){return 0})\n            //        list.forEach(function(d){arghhList[d]=1});\n\n            var subSet = new SubSet(bitMask, name, combinedSets, list, expectedValue);\n            subSets.push(subSet);\n        }\n    }\n    aggregateIntersection = {};\n\n//    var subSet = new SubSet(originalSetMask, name, combinedSets, combinedData, expectedValue);\n//    subSets.push(subSet);\n//\n//    for (var i = 0; i <= combinations; i++) {\n//        makeSubSet(i)\n//    }\n\n    $(EventManager).trigger(\"computing-subsets-finished\", undefined);\n\n}\n\nfunction updateSetContainment(set, refresh) {\n    if (!set.isSelected) {\n        set.isSelected = true;\n        usedSets.push(set);\n        $(EventManager).trigger(\"set-added\", { set: set });\n    }\n    else {\n        set.isSelected = false;\n\n        var index = usedSets.indexOf(set);\n        if (index > -1) {\n            usedSets.splice(index, 1);\n            $(EventManager).trigger(\"set-removed\", { set: set });\n        }\n    }\n\n    if (refresh) {\n        subSets.length = 0;\n        dataRows.length = 0;\n        setUpSubSets();\n        //  setUpGroupings();\n        previousState = undefined;\n        updateState();\n\n//        ctx.updateHeaders();\n//\n//        plot();\n//        plotSetSelection();\n        plotSetOverview();\n        initCallback.forEach(function (callback) {\n            callback();\n        })\n\n//        ctx.svg.attr(\"width\", ctx.w)\n//        d3.selectAll(\".svgGRows, .foreignGRows\").attr(\"width\", ctx.w)\n//        d3.selectAll(\".backgroundRect\").attr(\"width\", ctx.w - ctx.leftOffset)\n    }\n}\n\nfunction addSet(set) {\n\n}\n\nfunction removeSet(set) {\n    console.log('Not implemented');\n}\n\n"

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(33))

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	module.exports = "function githubDataLoading (user, token, opts, callback){\n  callback = callback || function(){};\n  var initOpts = {};\n  if (token) {\n    initOpts.token = token;\n  }\n  if (!user && !token) {\n    user = 'suziwen'\n  }\n  var gh = new GitHub(initOpts);\n  var targetUser = gh.getUser(user);\n  targetUser.listStarredRepos()\n    .then(function (res) {\n      var usedTags = [];\n      var usedTagObj = {}\n      var staredRepos = res.data\n      staredRepos.forEach(function (repoInfo) {\n        repoInfo.topics.forEach(function (topic) {\n          if (usedTagObj[topic]) {\n            usedTagObj[topic]++;\n          } else {\n            usedTagObj[topic] = 1;\n          }\n        });\n      });\n      usedTags = Object.keys(usedTagObj);\n      usedTags.sort(function(a, b){\n        return usedTagObj[b] - usedTagObj[a]\n      })\n      upsetDatas = [\n        [\n          \"id\",\n          \"name\",\n          \"createDate\",\n          \"stargazersCount\",\n          \"watchersCount\",\n          \"forksCount\",\n          \"pushedAt\",\n        ].concat(usedTags),\n      ];\n      var reposInfo = {}\n      staredRepos.forEach(function (repoInfo) {\n        topics = repoInfo.topics || [];\n        reposInfo[repoInfo.html_url] = repoInfo\n        upsetDatas.push(\n          [\n            repoInfo.html_url,\n            repoInfo.full_name,\n            d3.time.format('%Y%m%d')(new Date(repoInfo.created_at)),\n            repoInfo.stargazers_count,\n            repoInfo.watchers_count,\n            repoInfo.forks_count,\n            d3.time.format('%Y%m%d')(new Date(repoInfo.pushed_at)),\n          ].concat(usedTags.map(function (usedTag) {\n            if (topics.indexOf(usedTag) >= 0) {\n              return '1'\n            }\n            return '0'\n          }))\n        );\n      });\n      upsetOpts = {\n        name: 'me star repos',\n        author: '小书匠',\n        description: '',\n        source: '',\n        header: 0,\n        elementViewers: [{\n          \"type\": \"histogram\",\n          \"attribute\": {\"variable\": 2},\n          \"parameter\": {\"isFrequency\": true}\n        }],\n        meta: [{\n          type: 'id',\n          index: 0,\n          hidden: true,\n          name: '链接地址',\n        }, {\n          type: 'string',\n          index: 1,\n          name: '仓库名称'\n        }, {\n          type: 'integer',\n          index: 2,\n          \"format\": \"date:%Y%m%d\",\n          name: '创建时间'\n        }, {\n          type: 'integer',\n          index: 3,\n          name: '加星数'\n        }, {\n          type: 'integer',\n          index: 4,\n          name: '观察数'\n        }, {\n          type: 'integer',\n          index: 5,\n          name: '复制数'\n        }, {\n          type: 'integer',\n          index: 6,\n          \"format\": \"date:%Y%m%d\",\n          name: '更新时间'\n        }],\n        sets: [{\n          format: 'binary',\n          start: 7,\n          end: 7 + usedTags.length - 1\n        }],\n        data: upsetDatas\n      };\n      queryParameters['dataset'] = dataSetDescriptions.length\n      loadDataSetDescriptions([upsetOpts])\n      callback(null, reposInfo, upsetOpts);\n    })\n  .catch(function (err) {\n    console.log(\"err:\", err);\n    callback(err);\n  });\n}\n"

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(35))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	module.exports = "function localDataLoading (docs, opts, callback){\n  callback = callback || function(){};\n  var initOpts = {};\n  var usedTags = [];\n  var usedTagObj = {}\n  docs.forEach(function (docInfo) {\n    docInfo.tagNames.forEach(function (tagName) {\n      if (usedTagObj[tagName]) {\n        usedTagObj[tagName]++;\n      } else {\n        usedTagObj[tagName] = 1;\n      }\n    });\n  });\n  usedTags = Object.keys(usedTagObj);\n  usedTags.sort(function(a, b){\n    return usedTagObj[b] - usedTagObj[a]\n  })\n  upsetDatas = [\n    [\n      \"id\",\n      \"name\",\n      \"createDate\",\n    ].concat(usedTags),\n  ];\n  var reposInfo = {}\n  docs.forEach(function (docInfo) {\n    tagNames = docInfo.tagNames || [];\n    reposInfo[docInfo._id] = docInfo\n    upsetDatas.push(\n      [\n        docInfo._id,\n        docInfo.title,\n        d3.time.format('%Y%m%d')(new Date(docInfo.createDate)),\n      ].concat(usedTags.map(function (usedTag) {\n        if (tagNames.indexOf(usedTag) >= 0) {\n          return '1'\n        }\n        return '0'\n      }))\n    );\n  });\n  upsetOpts = {\n    name: 'me star repos',\n    author: '小书匠',\n    description: '',\n    source: '',\n    header: 0,\n    elementViewers: [{\n      \"type\": \"histogram\",\n      \"attribute\": {\"variable\": 2},\n      \"parameter\": {\"isFrequency\": true}\n    }],\n    meta: [{\n      type: 'id',\n      index: 0,\n      hidden: true,\n      name: '链接地址',\n    }, {\n      type: 'string',\n      index: 1,\n      name: '仓库名称'\n    }, {\n      type: 'integer',\n      index: 2,\n      \"format\": \"date:%Y%m%d\",\n      name: '创建时间'\n    }],\n    sets: [{\n      format: 'binary',\n      start: 3,\n      end: 3 + usedTags.length - 1\n    }],\n    data: upsetDatas\n  };\n  queryParameters['dataset'] = dataSetDescriptions.length\n  loadDataSetDescriptions([upsetOpts])\n  callback(null, reposInfo, upsetOpts);\n}\n\n"

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(37))

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	module.exports = "/**\n * author: Nils Gehlenborg - nils@hms.harvard.edu\n*/\n\n\n$(EventManager).bind(\"filter-removed\", function (event, data) {\n    selections.getActive().filterCollection.renderFilters();\n});\n\n\n$(EventManager).bind(\"filter-added\", function (event, data) {\n});\n\n\n$(EventManager).bind(\"filter-activated\", function (event, data) {\n});\n\nvar FilterConfigurations = {\n    // subset filter\n    subset: {\n      name: \"Subset\",\n      types: [\"sets\"],\n      parameters: [ { name: \"Subset\", type: \"subset\", variable: \"subset\" } ],\n      test: function( item, attribute, parameters ) {\n            /* subset definition example:\n                key = set id, value = yes or no\n                { 0: 1, 1: 1, 4: 0, 512: 1 }\n                sets not listed are treated as \"*\" (do not care)\n             */\n\n            var itemSets = attribute.values[item];\n\n            // iterate over keys in subset definitions\n            for (var id in parameters.subset) {\n                if (parameters.subset.hasOwnProperty(id)) {\n                    // set id is 1 => set is selected\n                    if ( parameters.subset[id] === 1 && itemSets.indexOf( id ) < 0 ) {\n                        // set id is selected but not found in item sets\n                        return false;\n                    }\n\n                    if ( parameters.subset[id] === 0 && itemSets.indexOf( id ) >= 0 ) {\n                        // set id is not selected but found in item sets\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n    },\n    // string match filter\n    stringMatch: {\n      name: \"Contains\",\n      types: [\"string\", \"id\"],\n      parameters: [ { name: \"String\", type: \"string\", variable: \"pattern\", default: \"\" } ],\n      test: function( item, attribute, parameters ) {\n            return ( attribute.values[item].indexOf( parameters.pattern ) >= 0 );\n        }\n    },\n    // exact string length filter\n    stringLength: {\n      name: \"String Length\",\n      types: [\"string\", \"id\"],\n      parameters: [ { name: \"Length\", type: \"integer\", variable: \"len\", default: 0 } ],\n      test: function( item, attribute, parameters ) {\n            return ( attribute.values[item].length === parameters.len );\n        }\n    },\n    // string match filter\n    stringRegex: {\n      name: \"Regular Expression\",\n      types: [\"string\", \"id\"],\n      parameters: [ { name: \"Pattern\", type: \"string\", variable: \"pattern\", default: \".\" } ],\n      test: function( item, attribute, parameters ) {\n            return ( attribute.values[item].match( parameters.pattern ) !== null );\n        }\n    },\n    // numeric range filter\n    numericRange: {\n      name: \"Range\",\n      types: [\"float\", \"integer\"],\n      parameters: [ { name: \"Minimum\", type: \"float\", variable: \"min\", default: 0 }, { name: \"Maximum\", type: \"float\", variable: \"max\", default: 1 } ],\n      test: function( item, attribute, parameters ) {\n            return ( attribute.values[item] >= parameters.min && attribute.values[item] <= parameters.max );\n        }\n    },\n    // numeric minimum filter\n    numericMinimum: {\n      name: \"Minimum\",\n      types: [\"float\", \"integer\"],\n      parameters: [ { name: \"Minimum\", type: \"float\", variable: \"min\", default: 0 } ],\n      test: function( item, attribute, parameters ) {\n            return ( attribute.values[item] >= parameters.min );\n        }\n    },\n    // numeric maximum filter\n    numericMaximum: {\n      name: \"Maximum\",\n      types: [\"float\", \"integer\"],\n      parameters: [ { name: \"Maximum\", type: \"float\", variable: \"max\", default: 0 } ],\n      test: function( item, attribute, parameters ) {\n            return ( attribute.values[item] <= parameters.max );\n        }\n    }\n};\n\n\n\nvar FilterCollection = function( controllerElementId, filterElementId ) {\n    var self = this;\n\n    self.list = [];\n\n    self.controllerElementId = controllerElementId;\n    self.filterElementId = filterElementId;\n};\n\n\nFilterCollection.prototype.add = function( filter ) {\n    var self = this;\n\n    self.list.push( filter );\n\n    $(EventManager).trigger(\"filter-added\", { viewer: filter });\n};\n\n\nFilterCollection.prototype.remove = function( filter ) {\n    var self = this;\n\n    for ( var i = 0; i < self.list.length; ++i ) {\n        if ( self.list[i].uuid === filter.uuid ) {\n            self.list.splice(i, 1);\n\n            $(EventManager).trigger(\"filter-removed\", { viewer: filter });\n        }\n    }\n};\n\n\nFilterCollection.prototype.getIndex = function( filter ) {\n    var self = this;\n\n    for ( var i = 0; i < self.list.length; ++i ) {\n        if ( self.list[i].uuid === filter.uuid ) {\n            return ( i );\n        }\n    }\n\n    return ( undefined );\n};\n\n\nFilterCollection.prototype.get = function( uuid ) {\n    var self = this;\n\n    for ( var i = 0; i < self.list.length; ++i ) {\n        if ( self.list[i].uuid === uuid ) {\n            return ( self.list[i] );\n        }\n    }\n\n    return ( undefined );\n};\n\n\n\n// render the controller (i.e. list of viewers that can be added and a \"new\" button)\nFilterCollection.prototype.renderController = function() {\n    var self = this;\n    var controllerElement = d3.select( self.controllerElementId );\n\n    controllerElement.html(\"\");\n\n    // create header and controls\n    var viewerElementHeader = controllerElement.append( \"div\" ).attr( \"class\", \"filter-header\" );\n\n    viewerElementHeader.append( \"div\" )\n            .attr( \"class\", \"filter-editor-button level-1-button\" )\n            .attr( \"id\", \"filter-add\" )\n            .on( \"click\", function() {\n                var filterSelector = document.getElementById( 'filter-selector' );\n                var configuration = filterSelector.options[filterSelector.selectedIndex].__data__;\n                var attributeSelector = document.getElementById( 'attribute-selector' );\n                var attribute = attributeSelector.options[attributeSelector.selectedIndex].__data__;\n                var filter = new Filter( attribute, configuration );\n\n                // if this is the first filter, make sure that the parent element (filters-list) is empty\n                if ( self.list.length == 0 ) {\n                    d3.select('#filters-list').html(\"\");\n                }\n\n                self.add( filter );\n\n                // add DOM nodes for filter viewer and editor\n                d3.select(self.filterElementId).insert( 'div' ).attr('class', 'filter-editor').attr( 'id', filter.editorElementId.substring(1) );\n                filter.renderEditor( d3.select( filter.editorElementId ), selections.getActive() );\n            })\n        .append( \"i\" ).\n            attr( \"class\", \"fa fw fa-plus\" );\n\n    var attributeSelect = controllerElement.append('select');\n    var filterSelect = controllerElement.append('select');\n    filterSelect.attr('id', 'filter-selector');\n\n    attributeSelect.attr('id', 'attribute-selector')\n        .selectAll('option')\n            .data( attributes.filter(function(_attribute){\n              if (_attribute.hidden) {\n                return false\n              }\n              return true\n            }) )\n        .enter()\n            .append('option')\n            .attr('value', function (d, i) {\n                return i;\n            })\n        .text(function (d) {\n            return d.name;\n        });\n\n    attributeSelect.on('changeDataset', self.initializeFilterList );\n    self.initializeFilterList();\n\n};\n\nFilterCollection.prototype.initializeFilterList = function() {\n    var filterSelect = d3.select( \"#filter-selector\");\n    filterSelect.html(\"\");\n    filterSelect.selectAll('option')\n            .data( function() {\n                // convert FilterConfiguration into array\n                // return only those filters that can be applied to the selected attribute\n                return $.map(FilterConfigurations, function(value, index) {\n                    var selector = document.getElementById( 'attribute-selector' );\n                    var attribute = selector.options[selector.selectedIndex].__data__;\n                    if ( value.types.indexOf( attribute.type ) >= 0 ) {\n                        return [value];\n                    }\n                });\n            })\n        .enter()\n            .append('option')\n            .attr('value', function (d, i) {\n                return i;\n            })\n        .text(function (d) {\n            return d.name;\n        });\n};\n\n// render the active viewer\nFilterCollection.prototype.renderFilters = function() {\n    var self = this;\n\n    var filterElement = d3.select( self.filterElementId );\n\n    // clear element\n    filterElement.html(\"\");\n    filterElement = filterElement.append( \"div\" ); //.attr( \"class\", \"filter-active\" );\n\n    // check if there is a viewer\n    if ( self.list.length === 0 ) {\n        filterElement.append( \"div\" ).attr( \"class\", \"info-message\" ).html( 'No filters configured. Click <i class=\"fa fw fa-plus\"></i> button to add a new filter.' );\n\n        return self;\n    }\n    else {\n        for ( var f = 0; f < self.list.length; ++f ) {\n            var filter = self.list[f];\n            filterElement.append( 'div' ).attr( 'id', filter.editorElementId.substring(1) );\n            filter.renderViewer( d3.select( filter.editorElementId ), selections.getActive() );\n        }\n    }\n\n    return self;\n};\n\nvar Filter = function(attribute, configuration,parameterMap) {\n    var self = this;\n\n    self.attribute = attribute;\n    self.uuid = Utilities.generateUuid();\n    self.editorElementId = '#filter-editor-' + self.uuid;\n    //self.viewerElementId = '#filter-viewer-' + self.uuid;\n    self.configuration = configuration;\n    self.parameterMap = {};\n\n    if ( !parameterMap ) {\n        self.initializeParameterMap();\n    }\n    else {\n        self.parameterMap = parameterMap;\n    }\n};\n\nFilter.prototype.initializeParameterMap = function() {\n    var self = this;\n\n    for ( var i = 0; i < self.configuration.parameters.length; ++i ) {\n        var parameter = self.configuration.parameters[i];\n\n        self.parameterMap[parameter.variable] = parameter.default;\n    }\n};\n\n/*\nFilter.prototype.getList = function( type ) {\n    var typeList = [];\n\n    if ( !type ) {\n        for (var filter in this.list) {\n            if (this.list.hasOwnProperty(filter)) {\n                typeList.push(filter);\n            }\n        }\n    }\n    else {\n        for (var filter in this.list) {\n            if (this.list.hasOwnProperty(filter)) {\n                if ( this.list[filter].types.indexOf( type ) >= 0 ) {\n                    typeList.push(filter);\n                }\n            }\n        }\n    }\n\n    return typeList;\n};\n*/\n\n\nFilter.prototype.renderViewer = function( element, selection ) {\n    var self = this;\n\n    var parameters = self.parameterMap;\n    var filterViewer = element;\n\n    filterViewer.attr( 'class', 'filter-viewer' );\n\n    filterViewer.html( '<div>' +\n        '<span class=\"filter-button level-2-button filter-remove\" data-filter-uuid=\"' + self.uuid + '\"\"><i class=\"fa fw fa-times-circle\"></i></span>' +\n        '<span class=\"filter-button level-2-button filter-edit\" data-filter-uuid=\"' + self.uuid + '\"\"><i class=\"fa fw fa-pencil\"></i></span>' +\n        '&nbsp;<b>' + self.configuration.name + '</b>&nbsp;|&nbsp;' + self.attribute.name +'</div>');\n\n    $('.filter-edit[data-filter-uuid=\"' + self.uuid + '\"]').on( 'click', function(){\n        self.renderEditor( element, selection, self.uuid );\n    });\n\n    $( '.filter-remove[data-filter-uuid=\"' + self.uuid + '\"]').on( 'click', function(){\n        $( self.editorElementId ).remove();\n        selection.filterCollection.remove( self );\n        selection.applyFilters();\n    });\n\n\n    var parameterType = undefined;\n    var parameterName = undefined;\n    for ( var parameterVariable in parameters ) {\n        if ( parameters.hasOwnProperty(parameterVariable) ) {\n            var parameterViewer = filterViewer.append( 'div' ).attr( 'class', 'filter-parameter-viewer' );\n\n            // look up parameter type in filter instance\n            for ( var p = 0; p < self.configuration.parameters.length; ++p ) {\n                if ( self.configuration.parameters[p].variable === parameterVariable ) {\n                    parameterType = self.configuration.parameters[p].type;\n                    parameterName = self.configuration.parameters[p].name;\n                }\n            }\n\n            this.renderParameterViewer( parameterViewer, parameterName, parameterType, parameters[parameterVariable] );\n        }\n    }\n};\n\nFilter.prototype.renderEditor = function( element, selection ) { // filterId, attributeId, parameters\n    var self = this;\n\n    var parameters = self.parameterMap;\n    var filterEditor = element;\n\n    filterEditor.html( '<div>' +\n        '<span class=\"filter-button level-2-button filter-cancel\" data-filter-uuid=\"' + self.uuid + '\"\"><i class=\"fa fw fa-times\"></i></span>' +\n        '<span class=\"filter-button level-2-button filter-save\" data-filter-uuid=\"' + self.uuid + '\"\"><i class=\"fa fw fa-check\"></i></span>' +\n        '&nbsp;<b>' + self.configuration.name + '</b>&nbsp;|&nbsp;' + self.attribute.name +'</div>');\n\n    $('.filter-save[data-filter-uuid=\"' + self.uuid + '\"]').on( 'click', function(){\n        self.parseParameterValues( selection );\n        selection.applyFilters();\n        self.renderViewer( element, selection );\n    });\n\n    $('.filter-cancel[data-filter-uuid=\"' + self.uuid + '\"]').on( 'click', function(){\n        self.renderViewer( element, selection );\n    });\n\n    var parameterType = undefined;\n    var parameterName = undefined;\n    for ( var parameterVariable in parameters ) {\n        if ( parameters.hasOwnProperty(parameterVariable) ) {\n            var parameterEditor = filterEditor.append( 'div' );\n\n            // look up parameter type in filter instance\n            for ( var p = 0; p < self.configuration.parameters.length; ++p ) {\n                if ( self.configuration.parameters[p].variable === parameterVariable ) {\n                    parameterType = self.configuration.parameters[p].type;\n                    parameterName = self.configuration.parameters[p].name;\n                }\n            }\n\n            self.renderParameterEditor( parameterEditor, parameterName, parameterType, parameters[parameterVariable], parameterVariable );\n        }\n    }\n};\n\n\nFilter.prototype.renderParameterViewer = function( element, parameterName, parameterType, parameterValue ) {\n\n    switch ( parameterType ) {\n        case 'float':\n            element.html( '<i>' + parameterName + '</i> = ' + d3.format('f')(parameterValue) );\n            break;\n        case 'integer':\n            element.html( '<i>' + parameterName + '</i> = ' + d3.format('d')(parameterValue) );\n            break;\n        case 'subset':\n            var s = \"\";\n            var subset = parameterValue;\n\n            for (var id in subset) {\n                if (subset.hasOwnProperty(id)) {\n                    s += '<span title=\"' + setIdToSet[id].elementName + '\">' + '<i class=\"' + this.subsetStateToClass( subset[id] ) + '\"></i>';\n                    s += '</span>&nbsp;';\n                }\n            }\n            element.html( s );\n            break;\n        case 'string':\n            // fall-through\n        default:\n            element.html( '<i>' + parameterName + '</i> = \"' + parameterValue + '\"' );\n            break;\n    }\n};\n\nFilter.prototype.parseParameterValues = function( selection ) {\n    var self = this;\n    var filterParameters = self.configuration.parameters;\n    var filterInstanceParameters = self.parameterMap;\n\n    for ( var i = 0; i < filterParameters.length; ++i ) {\n        var value = self.parseParameterValue( filterParameters[i].variable, filterParameters[i].type );\n\n        if ( value ) {\n    //        console.log( 'Replacing ' + filterParameters[i].variable + ' (' + filterParameters[i].type + ') = \"' + filterInstanceParameters[filterParameters[i].variable] + '\" with \"' + value + '\"' );\n            filterInstanceParameters[filterParameters[i].variable] = value;\n        }\n    }\n}\n\nFilter.prototype.parseParameterValue = function( parameterVariable, parameterType ) {\n    var self = this;\n\n    var filterEditor = $( self.editorElementId );\n\n    var value = undefined;\n\n    switch ( parameterType ) {\n        case 'float':\n            var parameterEditor = filterEditor.find('[data-filter-parameter-variable=\"' + parameterVariable + '\"]' );\n            value = parseFloat( $( parameterEditor ).val() );\n            break;\n        case 'integer':\n            var parameterEditor = filterEditor.find('[data-filter-parameter-variable=\"' + parameterVariable + '\"]' );\n            value = parseInt( $( parameterEditor ).val(), 10 );\n            break;\n        case 'subset':\n            value = {};\n            var parameterEditor = filterEditor.find( \".subset-state-toggle-button\" ).each(function() {\n                value[this.dataset.subset] = +this.dataset.subsetState;\n            });\n         //   console.log( value );\n            break;\n        case 'string':\n            // fall-through\n        default:\n            var parameterEditor = filterEditor.find('[data-filter-parameter-variable=\"' + parameterVariable + '\"]' );\n            value = $( parameterEditor ).val();\n            break;\n    }\n\n    return ( value );\n}\n\nFilter.prototype.renderParameterEditor = function( element, parameterName, parameterType, parameterValue, parameterVariable ) {\n    var self = this;\n    var s = \"\";\n\n    s += '<div data-filter-parameter-type=\"' + parameterType + '\">';\n\n    switch ( parameterType ) {\n        case 'float':\n            s += '<i>' + parameterName + '</i> = ' + '<input data-filter-parameter-variable=\"' + parameterVariable + '\" type=\"number\" step=\"0.1\" value=\"' + d3.format('f')(parameterValue) + '\"></input>';\n            break;\n        case 'integer':\n            s +=  '<i>' + parameterName + '</i> = ' + '<input data-filter-parameter-variable=\"' + parameterVariable + '\" type=\"number\" step=\"1\" value=\"' + d3.format('d')(parameterValue) + '\"></input>';\n            break;\n        case 'subset':\n            var subset = parameterValue;\n            for (var id in subset) {\n                if (subset.hasOwnProperty(id)) {\n                    s += '<span class=\"subset-state-toggle-button\" data-subset=\"' + id + '\" data-subset-state=\"' + subset[id] + '\">' + '<i class=\"' + this.subsetStateToClass( subset[id] ) + '\"></i>';\n                    s += ' ' + setIdToSet[id].elementName + ' <small>' + (setIdToSet[id].setSize === 0 ? '<i class=\"fa fa-warning\"></i> 0 items' : '') + '</small>' + '</span><br>';\n                }\n            }\n            break;\n        case 'string':\n            // fall-through\n        default:\n            s += '<i>' + parameterName + '</i> = ' + '<input data-filter-parameter-variable=\"' + parameterVariable + '\" type=\"text\" value=\"' + parameterValue + '\"></input>';\n            break;\n    }\n\n    s += '</div>';\n\n    // add to DOM\n    element.html(s);\n\n    // attach events ...\n    d3.selectAll( \".subset-state-toggle-button\").on( \"click\", function(event) {\n        this.dataset.subsetState = ( this.dataset.subsetState+1) % 3;\n        d3.select(this).select('i').attr( \"class\", self.subsetStateToClass( this.dataset.subsetState ) );\n    });\n};\n\n\nFilter.prototype.subsetStateToClass = function( state ) {\n    var s = \"\";\n\n    switch ( \"\" + state ) {\n        case \"0\":\n            s += 'fa fw fa-circle-o';\n            break;\n        case \"1\":\n            s += 'fa fw fa-circle';\n            break;\n        case \"2\":\n            s += 'fa fw fa-dot-circle-o';\n            break;\n        default:\n            s += 'fa fw fa-question-circle';\n            break;\n    }\n\n    return ( s );\n}\n"

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(39))

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	module.exports = "/**\n * author: Nils Gehlenborg - nils@hms.harvard.edu\n */\n\n\nvar Selection = function (items, filterCollection) {\n    this.items = items || [];\n    //this.filters = filters || [];\n    this.filterCollection = filterCollection;\n    this.id = undefined;\n};\n\nSelection.createSubsetDefinition = function (subsets) {\n\n    if (!(subsets[0] instanceof Object)) {\n        var newSubsets = [];\n        newSubsets.push(subsets);\n        subsets = newSubsets;\n    }\n    else {\n        //subsets = subsets[0];\n    }\n\n    //console.log( \"subsets\" );\n    //console.log( subsets );\n\n    var subsetDefinition = {};\n\n    for (var s = 0; s < subsets.length; ++s) {\n        var subset = subsets[s].combinedSets;\n\n        //console.log( \"subset\" );\n        //console.log( subset );\n\n        for (var x = 0; x < subset.length; ++x) {\n            if (subsetDefinition.hasOwnProperty(usedSets[x].id)) {\n                if (subsetDefinition[usedSets[x].id] !== subset[x]) {\n                    subsetDefinition[usedSets[x].id] = 2;\n                }\n            }\n            else {\n                subsetDefinition[usedSets[x].id] = subset[x];\n            }\n        }\n    }\n\n    //console.log( \"subsetDefinition\" );\n    //console.log( subsetDefinition );\n\n    return ( subsetDefinition );\n};\n\n/** Create a selection from a subset */\nSelection.fromSubset = function (subsets) {\n    var self = this;\n\n    // extract a subset definition for use with the subset filter\n    var subsetDefinition = Selection.createSubsetDefinition(subsets);\n\n    /*\n     var subsetDefinition = {};\n     for (var x = 0; x < subset.length; ++x) {\n     subsetDefinition[usedSets[x].id] = subset[x];\n     }\n     */\n\n    // create subset filter and create new selection based on all items\n    var selection = new Selection(allItems, new FilterCollection(\"#filters-controls\", \"#filters-list\"));\n\n    selection.filterCollection.add(new Filter(attributes[attributes.length - 1], FilterConfigurations.subset, { subset: subsetDefinition }));\n    selection.applyFilters();\n\n    return selection;\n};\n\nSelection.prototype.createSelection = function (attributeId, filterId, parameters) {\n    var newItems = [];\n    var filterInstance = filter.get(filterId);\n    for (var i = 0; i < this.items.length; ++i) {\n        if (filterInstance.test(this.items[i], attributes[attributeId], parameters)) {\n            newItems.push(this.items[i]);\n        }\n    }\n    //console.log(filter);\n    return ( new Selection(newItems, this.filters.concat([\n        { id: filterId, parameters: parameters, attributeId: attributeId, uuid: Utilities.generateUuid() }\n    ])) );\n};\n\nSelection.prototype.applyFilters = function () {\n    var self = this;\n\n    // start over with all items in the data set\n    self.items = allItems;\n\n    for (var f = 0; f < self.filterCollection.list.length; ++f) {\n        var filterInstance = self.filterCollection.list[f];\n        var newItems = [];\n\n        for (var i = 0; i < self.items.length; ++i) {\n            if (filterInstance.configuration.test(self.items[i], filterInstance.attribute, filterInstance.parameterMap)) {\n                newItems.push(self.items[i]);\n            }\n        }\n\n        self.items = newItems;\n    }\n\n    $(EventManager).trigger(\"item-selection-updated\", { selection: self });\n}\n\nSelection.prototype.mapToSubsets = function (subsetList) {\n    for (var i = 0; i < subsetList.length; ++i) {\n        var subset = subsetList[i];\n\n        // ignore empty subsets\n        if (subset.setSize == 0) {\n            continue;\n        }\n\n        var subsetDefinition = {};\n        for (var x = 0; x < subset.combinedSets.length; ++x) {\n            subsetDefinition[usedSets[x].id] = subset.combinedSets[x];\n        }\n\n        var subsetFilter = FilterConfigurations.subset;\n        var mappedItems = [];\n\n        for (var j = 0; j < this.items.length; ++j) {\n            if (subsetFilter.test(this.items[j], attributes[attributes.length - 1], { 'subset': subsetDefinition })) {\n                mappedItems.push(this.items[j]);\n            }\n            else {\n\n            }\n        }\n\n        subset.selections[this.id] = mappedItems;\n    }\n}\n\nSelection.prototype.unmapFromSubsets = function (subsetList) {\n    for (var i = 0; i < subsetList.length; ++i) {\n        var subset = subsetList[i];\n\n        delete subset.selections[this.id];\n    }\n}\n\nSelection.prototype.getFilter = function (uuid) {\n    var self = this;\n\n    return self.filterCollection.get(uuid);\n}\n\n// should be a singleton\nvar SelectionList = function (palette) {\n    var self = this;\n\n    self.list = [];\n    self.colors = {};\n    self.active = {};\n    self.palette = palette || d3.scale.category10().range().slice();\n\n    //  console.log(\"Palette Length \" + self.palette);\n};\n\nSelectionList.prototype.getSelections = function () {\n    var self = this;\n    return selections.list;\n}\n\nSelectionList.prototype.addSelection = function (selection) {\n    var self = this;\n\n    selection.id = self._nextId();\n    self.list.push(selection);\n\n    self.colors[selection.id] = self._nextColor();\n\n    $(EventManager).trigger(\"item-selection-added\", { selection: selection });\n\n    return self;\n};\n\nSelectionList.prototype.removeSelection = function (selection) {\n    var self = this;\n\n    for (var i = 0; i < this.list.length; ++i) {\n        if (self.list[i] === selection) {\n//            console.log('Deleting selection ' + i + '.');\n\n            // remove selection from list\n            self.list.splice(i, 1);\n\n            // return color to palette\n            self.palette.push(self.colors[selection.id]);\n\n            // remove selection from color map\n            delete self.colors[selection.id];\n\n            $(EventManager).trigger(\"item-selection-removed\", { selection: selection, index: i });\n\n            if (self.isActive(selection)) {\n                if (self.list.length > 0) {\n                    self.setActive(( i > 0 ? self.list[i - 1] : self.list[0] ));\n                }\n                else {\n                    self.setActive(undefined);\n                }\n            }\n\n            return;\n        }\n    }\n\n    // console.log('Unable to delete selection.');\n};\n\nSelectionList.prototype.getSelectionIndex = function (selection) {\n    var self = this;\n\n    for (var i = 0; i < self.list.length; ++i) {\n        if (self.list[i] === selection) {\n            return i;\n        }\n    }\n\n    return undefined;\n};\n\nSelectionList.prototype.getSelectionIndexFromUuid = function (uuid) {\n    var self = this;\n\n    for (var i = 0; i < self.list.length; ++i) {\n        if (self.list[i].id === uuid) {\n            return i;\n        }\n    }\n\n    return undefined;\n};\n\nSelectionList.prototype.getSelectionFromUuid = function (uuid) {\n    var self = this;\n\n    try {\n        return ( self.list[self.getSelectionIndexFromUuid(uuid)] );\n    }\n    catch (error) {\n        // ignore\n    }\n\n    return undefined;\n};\n\nSelectionList.prototype.getSelection = function (index) {\n    var self = this;\n\n    try {\n        return ( self.list[index] );\n    }\n    catch (error) {\n        // ignore\n    }\n\n    return undefined;\n};\n\nSelectionList.prototype.getColorFromUuid = function (uuid) {\n    var self = this;\n\n    try {\n        return ( self.colors[uuid] );\n    }\n    catch (error) {\n        // ignore\n    }\n\n    return undefined;\n};\n\nSelectionList.prototype.getColor = function (selection) {\n    var self = this;\n\n    try {\n        return ( self.colors[selection.id] );\n    }\n    catch (error) {\n        // ignore\n    }\n\n    return undefined;\n};\n\nSelectionList.prototype.getSize = function () {\n    var self = this;\n\n    return self.list.length;\n};\n\nSelectionList.prototype.isActive = function (selection) {\n    var self = this;\n\n    return ( self.active === selection );\n};\n\nSelectionList.prototype.isActiveByUuid = function (uuid) {\n    var self = this;\n    if (!self.active) {\n        return false;\n    }\n    return ( self.active.id === uuid );\n};\n\nSelectionList.prototype.getActive = function () {\n    var self = this;\n\n    return ( self.active );\n};\n\nSelectionList.prototype.setActive = function (selection) {\n    var self = this;\n\n    self.active = selection;\n\n    $(EventManager).trigger(\"item-selection-activated\", { selection: selection });\n\n    return ( self );\n};\n\nSelectionList.prototype.setActiveByUuid = function (uuid) {\n    var self = this;\n\n    self.active = self.getSelectionFromUuid(uuid);\n\n    $(EventManager).trigger(\"item-selection-activated\", { selection: self.active });\n\n    return ( self );\n};\n\nSelectionList.prototype._nextColor = function () {\n    var self = this;\n\n    // use color pool and return black once pool is empty\n    if (self.palette.length > 0) {\n        // first available color\n        return self.palette.splice(0, 1)[0];\n    }\n\n    return \"#000\";\n};\n\nSelectionList.prototype._nextId = function () {\n    return Utilities.generateUuid();\n};\n"

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(41))

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Created by Alexander Lex on 2/4/14.\n */\n\n\nvar ROW_TYPE =\n{\n    SET: 'SET_TYPE',\n    SUBSET: 'SUBSET_TYPE',\n    GROUP: 'GROUP_TYPE',\n    AGGREGATE: 'AGGREGATE_TYPE',\n    QUERY_GROUP: 'QUERY_GROUP_TYPE',\n    SEPARATOR: 'SEPARATOR',\n    UNDEFINED: 'UNDEFINED'}\n\n/** the user interface */\nvar ui; // initialized on document ready event\n\n/** The input datasets */\nvar sets = [];\nvar setIdToSet = {};\n/** The sets currently in use */\nvar usedSets = [];\n/** The ordered and grouped subsets */\nvar dataRows = [];\n/** Same as dataRows but including a wrapper for the data */\nvar renderRows = [];\n/** The dynamically created subSets */\nvar subSets = [];\n/** The labels of the records */\nvar labels = [];\n/** meta data attributes of the records/items */\nvar attributes = [];\n/** attributes selected by the user (for item visualizations) */\nvar selectedAttributes = {};\n/** The number of combinations that are currently active */\nvar combinations = 0;\n\nvar depth = 0;\n\n/** The depth of the dataset, i.e., how many records it contains */\n\n/** an array representing all items */\nvar allItems = [];\n\n//var filter = new Filter();\n\n/** Indices of selected items **/\nvar selectedItems = [];\n\nvar selections = new SelectionList(); //an array of selection\n\nvar elementViewers = new ElementViewerCollection( \"#element-viewers-controls\", \"#element-viewers-visualization\" );\n\n/** The list of available datasets */\nvar dataSets;\n\n/** Groups of subsets driven by group size */\n//var sizeGroups = [];\n\n/** Groups of subsets driven by set containment */\n//var setGroups = [];\n\n/** Venn diagram for tutorial mode */\nvar vennInstance = new VennDiagram(\"#venn-vis\", 200);\n\n/** The current primary grouping */\nvar levelOneGroups;\n/** The smart filter groups */\nvar filterGroups;\n\n/** How many sets do we want to see by default */\nvar nrDefaultSets = 6;\n\n/**\n * The base element for all rows (sets, groups, subsets, aggregates)\n * @param id\n * @param elementName\n * @constructor\n */\nfunction Element(id, elementName) {\n    this.id = id;\n    this.elementName = elementName;\n    /** The indices of the data items in this set */\n    this.items = [];\n    /** The number of elements in this (sub)set */\n    this.setSize = 0;\n    /** The ratio of elements that are contained in this set */\n    this.dataRatio = 0.0;\n}\n\nfunction Separator(id, elementName) {\n    Element.call(this, id, elementName);\n\n    this.type = ROW_TYPE.SEPARATOR;\n\n}\n\nSeparator.prototype = Element;\nSeparator.prototype.constructor = Element;\n/**\n * Base class for Sets, subsets, groups.\n *\n * The setID is set to Element.id and is a binary representation of the contained set\n * @param setID\n * @param setName\n * @param combinedSets\n * @param setData\n * @constructor\n */\nfunction BaseSet(setID, setName, combinedSets, setData, fake) {\n    Element.call(this, setID, setName);\n\n    /** An array of all the sets that are combined in this set. The array contains a 1 if a set at the corresponding position in the sets array is combined. */\n    this.combinedSets = combinedSets;\n\n    /** The number of combined dataRows */\n    this.nrCombinedSets = 0;\n\n    for (var i = 0; i < this.combinedSets.length; i++) {\n        if (this.combinedSets[i] !== 0) {\n            this.nrCombinedSets++;\n        }\n    }\n//    console.log(this.nrCombinedSets);\n\n    for (var i = 0; i < setData.length; i++) {\n            this.items.push(setData[i]);\n            this.setSize++;\n    }\n\n//    for (var i = 0; i < setData.length; i++) {\n//        if (setData[i] !== 0) {\n//            this.items.push(i);\n//            this.setSize++;\n//        }\n//    }\n\n    this.dataRatio = this.setSize / depth;\n}\n\nBaseSet.prototype = Element;\nBaseSet.prototype.constructor = Element;\n\nfunction USet(setID, setName, combinedSets, itemList) {\n    BaseSet.call(this, setID, setName, combinedSets,[],1);\n        for (var i = 0; i < itemList.length; i++) {\n        if (itemList[i] !== 0) {\n            this.items.push(i);\n            this.setSize++;\n        }\n    }\n    this.dataRatio = this.setSize / depth;\n\n    this.type = ROW_TYPE.SET;\n    /** Array of length depth where each element that is in this subset is set to 1, others are set to 0 */\n    this.itemList = itemList;\n    this.isSelected = false;\n\n}\n\nUSet.prototype = BaseSet;\nUSet.prototype.constructor = BaseSet;\n\nfunction SubSet(setID, setName, combinedSets, itemList, expectedProb) {\n    BaseSet.call(this, setID, setName, combinedSets, itemList);\n    this.type = ROW_TYPE.SUBSET;\n    this.expectedProb = expectedProb;\n    this.selections = {};\n\n    var observedProb = this.setSize*1.0 / depth;\n\n//    this.disproportionality =\n\n    this.disproportionality =  observedProb-expectedProb;\n//    if (this.disproportionality<1 && this.disproportionality>0) this.disproportionality=-(1/this.disproportionality);\n//    if (this.disproportionality>10) this.disproportionality=20;\n//    if (this.disproportionality<-10) this.disproportionality=-20;\n\n}\n\nSubSet.prototype.toString = function () {\n    return 'Subset + ' + this.id + ' Nr Combined Sets: ' + this.nrCombinedSets;\n}\n\n// Not sure how to do this properly with parameters?\nSubSet.prototype = USet;\nSubSet.prototype.constructor = SubSet;\n\nfunction Group(groupID, groupName, level) {\n    Element.call(this, groupID, groupName);\n    this.type = ROW_TYPE.GROUP;\n\n    this.isCollapsed = false;\n\n    this.nestedGroups = undefined;\n\n    /** the nesting level of the group, 1 is no nesting, 2 is one level down */\n    this.level = 1;\n    if (level) {\n        this.level = level;\n    }\n\n    /** all subsets */\n    this.subSets = [];\n    /** the visible subsets */\n    this.visibleSets = [];\n    this.aggregate = new Aggregate('empty' + groupID, ' Subsets', level + 1);\n    /** the hidden/aggregated subsets */\n    this.hiddenSets = [];\n\n    //this.setSize = 0;\n    this.expectedProb = 0;\n    this.disproportionality = 0;\n    this.disproportionalitySum =0;\n\n    this.addSubSet = function (subSet) {\n        this.subSets.push(subSet);\n        if (subSet.setSize > 0) {\n            this.visibleSets.unshift(subSet);\n\n        }\n        else {\n            this.hiddenSets.unshift(subSet);\n            this.aggregate.addSubSet(subSet);\n        }\n        this.items = this.items.concat(subSet.items);\n        this.setSize += subSet.setSize;\n        this.expectedProb += subSet.expectedProb;\n        this.disproportionality += subSet.disproportionality;\n//        if (this.subSets.length>0)\n//            this.disproportionality = this.disproportionalitySum/this.subSets.length;\n\n//        this.disproportionality += subSet.disproportionality;\n    }\n\n    this.contains = function (element) {\n        if (subSets.indexOf(element) >= 0) {\n            return true;\n        }\n        if (element === this.aggregate) {\n            return true;\n        }\n        return false;\n\n    }\n}\n\nGroup.prototype = Element;\nGroup.prototype.constructor = Element;\n\nfunction QueryGroup(groupID, groupName, orClauses) {\n    this.type = ROW_TYPE.QUERY_GROUP;\n    Group.call(this, groupID, groupName, 1);\n    this.orClauses = orClauses;\n    // if simple OR Group.. create combinedSet Element\n    if (orClauses.length==1){\n        this.combinedSets=Object.keys(orClauses[0]).map(function(key){\n            return orClauses[0][key].state\n        })\n    }\n}\n\nQueryGroup.prototype = Group;\nQueryGroup.prototype.constructor = Group;\n\nfunction Aggregate(aggregateID, aggregateName, level) {\n    Element.call(this, aggregateID, aggregateName);\n    this.type = ROW_TYPE.AGGREGATE;\n    this.subSets = [];\n\n    this.isCollapsed = true;\n\n    /** the nesting level of the group, 1 is no nesting, 2 is one level down */\n    this.level = level;\n\n    //this.setSize = 0;\n    this.expectedProb = 0;\n    this.disproportionality = 0;\n\n    this.addSubSet = function (subSet) {\n        this.subSets.push(subSet);\n        this.items = this.items.concat(subSet.items);\n        this.setSize += subSet.setSize;\n        this.expectedProb += subSet.expectedProb;\n        this.disproportionality += subSet.disproportionality;\n    }\n}\n\nAggregate.prototype = Element;\nAggregate.prototype.constructor = Element;\n\nfunction makeSubSet(setMask) {\n\n    var bitMask = 1;\n    var tempMask = setMask;\n    var sum = 0;\n    for (var i = 0; i < usedSets.length; i++) {\n        if ((tempMask & bitMask) === 1) {\n            sum += 1;\n            if (sum > UpSetState.maxCardinality) {\n                return;\n            }\n        }\n        tempMask = tempMask >> 1;\n    }\n    if (sum < UpSetState.minCardinality) {\n        return;\n    }\n    var originalSetMask = setMask;\n\n    var combinedSets = Array.apply(null, new Array(usedSets.length)).map(Number.prototype.valueOf, 0);\n//    console.log(\"combinedSets:\",combinedSets);\n\n    var combinedData = Array.apply(null, new Array(depth)).map(Number.prototype.valueOf, 1);\n\n    var isEmpty = true;\n    var expectedValue = 1;\n    var notExpectedValue = 1;\n    var name = '';\n    for (var setIndex = usedSets.length - 1; setIndex >= 0; setIndex--) {\n        var data = usedSets[setIndex].itemList;\n        if ((setMask & bitMask) === 1) {\n            combinedSets[setIndex] = 1;\n            expectedValue  = expectedValue *  usedSets[setIndex].dataRatio;\n            name += usedSets[setIndex].elementName + ' ';\n        }\n        else {\n            notExpectedValue = notExpectedValue * (1- usedSets[setIndex].dataRatio);\n        }\n        for (i = 0; i < data.length; i++) {\n            if ((setMask & bitMask) === 1) {\n                if (!(combinedData[i] === 1 && data[i] === 1)) {\n                    combinedData[i] = 0;\n                }\n            }\n            else {\n                // remove the element from the combined data if it's also in another set\n                if ((combinedData[i] === 1 && data[i] === 1)) {\n                    combinedData[i] = 0;\n                }\n            }\n        }\n\n        // update the set mask for the next iteration\n        setMask = setMask >> 1;\n    }\n\n\n//    console.log(expectedValue, notExpectedValue);\n//    console.log(\"combinedData:\", combinedData);\n    expectedValue *= notExpectedValue;\n  //  console.log(originalSetMask,name,combinedSets,combinedData,expectedValue);\n    var subSet = new SubSet(originalSetMask, name, combinedSets, combinedData, expectedValue);\n    subSets.push(subSet);\n}\n\n/** takes  a list l of arrays a(i) which represent disjunctive normal form: a(i) OR a(i+1) OR...\n a(i) represents a setMask: 0 - NOT, 1 - MUST, 2- DONTCARE\n if callFunction is null a list of matching subsets is returned\n */\nvar getSubsetsForMaskList = function (subsets, maskList, callFunction) {\n    var res = [];\n\n    var clauseMatches = true;\n    var isAhit = false;\n    subsets.forEach(function (subset) {\n\n        isAhit = false;\n        var combinedSets = subset.combinedSets;\n        maskList.forEach(function (compare) {\n            if (isAhit == false) {\n                var csLength = combinedSets.length\n                clauseMatches = (csLength == compare.length)\n                if (clauseMatches) {\n                    for (var i = 0; i < csLength; i++) {\n                        clauseMatches &= (\n                            (combinedSets[i] == compare[i])\n                                || compare[i] == 2 );\n                    }\n                }\n                if (clauseMatches) {\n                    isAhit = true;\n                }\n            }\n        })\n\n        if (isAhit && callFunction != null) {\n            callFunction(subset);\n\n        } else if (isAhit) {\n            res.push(subset);\n        }\n    })\n    return res;\n}\n"

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(43))

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	module.exports = "/**\n * author: Nils Gehlenborg - nils@hms.harvard.edu\n */\n\nvar Ui = function() {\n    var self = this;\n\n    self.lastWindowWidth = 0;\n    self.lastWindowHeight = 0;\n\n    // needs to be called\n    self.initialize();\n    self.initWidthHandler();\n};\n\n/**\n * update container sizes\n */\nUi.prototype.resize = function( event ) {\n    if ( ( self.lastWindowWidth != $(window).width() ) && ( self.lastWindowHeight != $(window).height() ) ) {\n        $(EventManager).trigger( \"ui-resize\", { newWidth: $(window).width(), oldWidth: self.lastWindowWidth, newHeight: $(window).height(), oldHeight: self.lastWindowHeight } );\n\n        self.lastWindowHeight = $(window).height();\n        self.lastWindowWidth = $(window).width();\n\n        return;\n    }\n\n    if ( self.lastWindowWidth != $(window).width() ) {\n        $(EventManager).trigger( \"ui-horizontal-resize\", { newWidth: $(window).width(), oldWidth: self.lastWindowWidth } );\n\n        self.lastWindowWidth = $(window).width();\n\n        return;\n    }\n\n    if ( self.lastWindowHeight != $(window).height() ) {\n        $(EventManager).trigger( \"ui-vertical-resize\", { newHeight: $(window).height(), oldHeight: self.lastWindowHeight } );\n\n        self.lastWindowHeight = $(window).height();\n\n        return;\n    }\n}\n\n\nUi.prototype.updateFixedHeightContainers = function() {\n    return\n    var fixedYContainers = $('.fixed-y-container');\n    fixedYContainers.map( function(index) {\n        var paddingBottom = parseInt( $(fixedYContainers[index]).css( 'padding-bottom' ) ) || 0;\n       // console.log( paddingBottom );\n        var targetHeight = ( $(window).height() - $(this).offset().top - paddingBottom ) * parseFloat( $(fixedYContainers[index]).attr(\"data-height-ratio\") );\n        var minHeight = parseInt( $('.fixed-y-container').css( \"min-height\" ) );\n        var maxHeight = parseInt( $('.fixed-y-container').css( \"max-height\" ) ) || targetHeight;\n\n\n        var newHeight = Math.min( Math.max( targetHeight, minHeight ), maxHeight );\n        $(this).css('height', newHeight + 'px');\n    });\n}\n\n\nUi.prototype.initialize = function() {\n    var self = this;\n\n    self.lastWindowHeight = $(window).height();\n    self.lastWindowWidth = $(window).width();\n\n    self.createHeader();\n    self.hideMenu();\n    self.updateFixedHeightContainers();\n\n}\n\nUi.prototype.createHeader = function() {\n    var self = this;\n\n    $( \"#load-data-header\").on( \"click\", function( event ){\n        self.toggleMenu();\n    });\n}\n\nUi.prototype.showMenu = function() {\n    var self = this;\n\n    $(\".ui-menu\").show();\n}\n\nUi.prototype.hideMenu = function() {\n    var self = this;\n\n    $(\".ui-menu\").hide();\n}\n\nUi.prototype.toggleMenu = function() {\n    var self = this;\n\n    $(\".ui-menu\").slideToggle( { step: self.updateFixedHeightContainers } );\n\n    //$( \"#show-menu-button\").toggleClass( \"fa-spin\");\n}\n\n\nUi.prototype.initWidthHandler = function(){\n    $(\"#moveHandle\").on(\"drag\")\n\n    $(function() {\n        var isDragging = false;\n        var startX = undefined;\n        var endX = undefined;\n        var eastWidth = undefined;\n\n        $(\"#moveHandle\")\n            .mousedown(function(event) {\n                event.stopPropagation()\n              //  console.log(\"MD\");\n                if ( !isDragging ) {\n                    startX = event.clientX; //#set-vis-container\n                    eastWidth = $(\".ui-layout-east\").width();\n                    isDragging = true;\n                }\n\n            });\n\n        $(window).mouseup(function() {\n            if ( isDragging ) {\n                isDragging = false;\n            }\n\n\n        });\n\n        $(window).mousemove(function(event) {\n\n            if ( isDragging ) {\n                endX = event.clientX;\n                event.stopPropagation()\n                var newWidth = eastWidth - (endX - startX)\n                if (newWidth > 800) {\n                  newWidth = 800\n                }\n                if (newWidth < 360) {\n                  newWidth = 360;\n                }\n                if (newWidth != eastWidth) {\n                  $(\".ui-layout-east\").width( newWidth );\n                  $(EventManager).trigger( \"vis-svg-resize\", { newWidth: $(\".ui-layout-center\").width() });\n                }\n            }\n        });\n\n    });\n\n\n\n\n\n\n}\n"

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(45))

/***/ }),
/* 45 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Created by romain & hen (hendrik.strobelt.com)\n */\n\nfunction plotSetOverview() {\n\n    var initialize = false;\n    var animate = false;\n\n\n    if (arguments[0]) {\n        initialize = arguments[0].initialize || false;\n\n        if (initialize) {\n            ctx.setSelection.mode = \"none\"\n            ctx.setSelection.modeChange = false;\n            ctx.setSelection.multiSelIn = d3.set();\n            ctx.setSelection.multiSelOut = d3.set();\n        }\n//        animate = arguments[0].animate || false;\n//        mode = arguments[0].mode || \"none\";\n    }\n\n\n    var majorPadding = 5;\n    var minorPadding = 2;\n    var cellDistance = 20;\n    var cellSize = cellDistance;// - minorPadding;\n    var setCellDistance = 12;\n    var setCellSize = 10;\n\n    var differenceForMultiSel = 7;\n    var textHeight = 62 - differenceForMultiSel;\n    var truncateAfter = 7;\n    var distanceUsedMenu = 15;\n    var paddingForPaginationRight = 115;\n    var paddingForPaginationRightExtra = (ctx.setSelection.mode === \"none\") ? 0 : 100;\n    const paginationLinespace = 14;\n\n    var headerSVG = d3.select('#headerVis').select('svg');\n\n    // calculate widths\n    var svgWidth = headerSVG.attr(\"width\");\n    var menuOffset = usedSets.length * cellSize + distanceUsedMenu;\n    var maxWidthUnused = svgWidth - menuOffset - paddingForPaginationRight - paddingForPaginationRightExtra - distanceUsedMenu - cellDistance;\n\n    var unusedSets = sets.filter(function (n) {\n        return usedSets.indexOf(n) == -1\n    });\n\n\n    // --- INIT the SVG structure (d3 version)\n\n\n    var setSelectionGroup = headerSVG.selectAll(\".setSelection\").data([1]);\n    setSelectionGroup.enter().append(\"g\").attr({\n        class: \"setSelection\",\n        \"transform\": \"translate(\" + 0 + \",\" + 0 + \")\"\n    })\n\n\n    // scale for the size of the subSets, also used for the sets\n    var setSizeScale = d3.scale.linear().domain([0, d3.max(sets, function (d) {\n        return d.setSize;\n    })]).nice().range([0, textHeight]);\n\n\n    function updateUsedSets() {\n        // ----------------------------\n        ///-- Render the used Sets\n        // ----------------------------\n        var usedSetsVis = setSelectionGroup.selectAll(\".usedSets\").data([1]);\n        usedSetsVis.enter().append(\"g\").attr(\"class\", \"usedSets\");\n\n        usedSetsVis.attr({\n            \"transform\": \"translate(\" + 0 + \",\" + differenceForMultiSel + \")\"\n        })\n\n        var usedSetsLabels = usedSetsVis\n            .selectAll('.setLabel')\n            .data(usedSets, function (d) {\n                return d.elementName;\n            })\n        usedSetsLabels.exit().remove();\n        var usedSetsLabelsEnter = usedSetsLabels.enter().append(\"g\").attr(\"class\", \"setLabel\").attr({\n            transform: function (d, i) {\n                return 'translate(' + (cellDistance * (i)) + ', 0)'\n            },\n            opacity: .1\n\n        });\n        usedSetsLabelsEnter\n            .append('rect')\n            .attr({\n                class: 'setSizeBackground',\n                height: (textHeight + 1),\n                width: cellSize,//setRowScale.rangeBand()\n                title: function (d) {\n                    return d.setSize\n                }\n            })\n            .on('click', setClicked)\n            .on('mouseover', function (d, i) {\n                mouseoverColumn(d, i);\n            })\n            .on('mouseout', function (d, i) {\n                mouseoutColumn(d, i);\n            })\n            .append(\"svg:title\")\n                .text(function (d) {\n                    return d.elementName + \" (\" + d.setSize + \")\";\n                });\n        // background bar\n        usedSetsLabelsEnter\n            .append('rect')\n            .attr({\n                class: 'setSizeRect setSize',\n                x: 1,\n                width: cellSize - 2//setRowScale.rangeBand()\n            })\n            //  .attr(\"transform\", \"skewX(45)\")\n            .on('mouseover', mouseoverColumn)\n            .on('mouseout', mouseoutColumn)\n            .on('click', setClicked)\n            .append(\"svg:title\")\n                .text(function (d) {\n                    return d.elementName + \" (\" + d.setSize + \")\";\n                });\n        // *** update sizes (might happen when changing datasets)\n        d3.selectAll(\".usedSets .setSize\").transition().duration(1000).attr({\n            y: function (d) {\n                return (textHeight - (setSizeScale(d.setSize)));\n            },\n            height: function (d) {\n                return setSizeScale(d.setSize);\n            }\n        });\n        usedSetsLabelsEnter.transition().duration(400).delay(400).attr({\n            opacity: 1\n        })\n        // *** update group position\n//        usedSetsLabels\n//            .attr({\n//                transform: function (d, i) {\n//                        return 'translate(' + (cellDistance * i) + ', 0)'\n//                }\n//            })\n\n        usedSetsLabels.attr({\n            transform: function (d, i) {\n                if (ctx.setSelection.mode === \"multiSel\") {\n                    if (ctx.setSelection.multiSelOut.has(d.elementName)) {\n                        return 'translate(' + (cellDistance * i) + ', -' + differenceForMultiSel + ')'\n                    } else {\n                        return 'translate(' + (cellDistance * i) + ', 0)'\n                    }\n\n                } else {\n                    return 'translate(' + (cellDistance * i) + ', 0)'\n                }\n\n            }\n        })\n\n        usedSetsLabels.selectAll(\".setSizeRect\")\n            .attr({\n                \"class\": function (d) {\n                    if (ctx.setSelection.multiSelOut.has(d.elementName)) {\n                        return 'setSizeRect unusedSetSize'\n                    } else {\n                        return 'setSizeRect setSize'\n                    }\n\n\n                }\n\n\n            })\n\n\n    }\n\n    updateUsedSets();\n\n\n    function updateUnusedSets() {\n        // ----------------------------\n        ///-- Render the unused Sets\n        // ----------------------------\n        var sortSize = function (a, b) {\n            return b.setSize - a.setSize;\n        };\n\n        var sortName = function (a, b) {\n            return d3.ascending(a.elementName, b.elementName);\n        };\n\n        var sortFn;\n\n        if (ctx.setSelection.setOrder === \"name\") {\n            sortFn = sortName;\n        } else {\n            sortFn = sortSize;\n        }\n\n        var unuseedSetsOffset = menuOffset + paddingForPaginationRight + paddingForPaginationRightExtra + distanceUsedMenu;\n\n\n        unusedSets.sort(sortFn);\n\n        var unusedSetsGroup = setSelectionGroup.selectAll(\".unusedSets\").data([1])\n        unusedSetsGroup.enter().append(\"g\").attr(\"class\", \"unusedSets\")\n\n        unusedSetsGroup.attr({\n            \"transform\": function (d) {\n                if (ctx.setSelection.mode === \"multiSel\") {\n                    return 'translate(' + unuseedSetsOffset + ', 0)'\n                } else {\n                    return 'translate(' + unuseedSetsOffset + ', ' + differenceForMultiSel + ')'\n                }\n            }\n        })\n\n\n        if (maxWidthUnused < cellDistance) {\n\n\n            unusedSetsGroup.selectAll('.unusedSetLabel').remove();\n\n        } else {\n\n            /*\n             * add only if there is enough space !!!\n             * */\n\n            var paginationDistance = Math.floor(maxWidthUnused / cellDistance);\n\n            if (initialize) {\n                ctx.setSelection.paginationStart = +0;\n            }\n            ctx.setSelection.paginationEnd = +ctx.setSelection.paginationStart + paginationDistance;\n\n            var unusedSetsFiltered = unusedSets.filter(\n                function (d, i) {\n                    return ((ctx.setSelection.paginationStart <= i) && (i <= ctx.setSelection.paginationEnd));\n                }\n            )\n\n\n            /*\n             * create buttons for pagination\n             * */\n            updatePaginationDecoration();\n\n\n            var unusedSetsLabels = unusedSetsGroup\n                .selectAll('.unusedSetLabel')\n                .data(unusedSetsFiltered, function (d) {\n                    return d.elementName;\n                })\n\n            unusedSetsLabels.exit().remove();\n\n\n            var unusedSetsLabelsEnter = unusedSetsLabels.enter().append(\"g\").attr(\"class\", \"unusedSetLabel\").attr({\n                transform: function (d, i) {\n                    return 'translate(' + (cellDistance * (i)) + ', -10)'\n                },\n                opacity: .1\n            });\n            unusedSetsLabelsEnter\n                .append('rect')\n                .attr({\n                    class: 'unusedSetSizeBackground',\n//                transform: function (d, i) {\n//                    return 'translate(' + (cellDistance * (i )) + ', 20)'\n//                },\n                    height: textHeight - 2,\n                    width: cellSize\n                })\n                .on('click', setClicked)\n\n            unusedSetsLabelsEnter\n                .append('rect')\n                .attr({\n                    class: 'setSizeRect unusedSetSize',\n                    transform: function (d, i) {\n                        return 'translate(1, ' + (textHeight - setSizeScale(d.setSize)) + ')'\n                    }, // ' + (textHeight - 5) + ')'\n                    height: function (d) {\n                        return setSizeScale(d.setSize);\n                    },\n                    width: cellSize - 2,\n                })\n                .on('click', setClicked)\n               // .append('title').text(function (d) {return d});\n              //     .append('title').text(\"what\");\n//        .append(\"svg:title\")\n//        .text(function(d, i) { return d.elementName + \" (\" +d.setSize+ \")\"; });;\n\n\n            unusedSetsLabelsEnter\n                .append('text').text(function (d) {\n                if (d.elementName.length > (truncateAfter + 3)) {\n                    var str = d.elementName.substring(0, truncateAfter)\n                    if (str.length < d.elementName.length)\n                        str = str.trim() + \"...\";\n                } else {\n                    str = d.elementName.trim();\n                }\n\n                return str;\n            })\n                .attr({\n                    class: 'setLabel',\n                    transform: function (d, i) {\n                        return 'translate(' + (cellDistance + 5) + ', 0) rotate(90)'\n                    },\n                    y: cellSize - 3,\n                    x: 3,\n                    height: textHeight - 4,\n                    'text-anchor': 'start'\n\n                })\n                .on('click', setClicked)\n                .append(\"svg:title\")\n                .text(function (d, i) {\n                    return d.elementName + \" (\" + d.setSize + \")\";\n                });\n\n\n//            console.log(\"animate:\", animate);\n//            var updateUnusedPos =unusedSetsLabelsEnter;\n//            if (animate){\n//                updateUnusedPos= unusedSetsLabelsEnter\n//                    .transition().duration(400).delay(400)\n//            }\n//            updateUnusedPos.attr({\n//                opacity:1,\n//                transform: function (d, i) {\n//                    return 'translate(' + (cellDistance * (i ) + unusedLabelOffset) + ', 0)'\n//                }\n//            })\n\n            unusedSetsLabels.attr({\n                transform: function (d, i) {\n                    if (ctx.setSelection.mode === \"multiSel\") {\n                        if (ctx.setSelection.multiSelIn.has(d.elementName)) {\n                            return 'translate(' + (cellDistance * (i)) + ', ' + differenceForMultiSel + ')'\n                        } else {\n                            return 'translate(' + (cellDistance * (i)) + ', 0)'\n                        }\n\n                    } else {\n                        return 'translate(' + (cellDistance * (i)) + ', 0)'\n                    }\n\n                },\n                opacity: 1\n            })\n\n\n            unusedSetsLabels.selectAll(\".setSizeRect\")\n                .attr({\n                    \"class\": function (d) {\n                        if (ctx.setSelection.multiSelIn.has(d.elementName)) {\n                            return 'setSizeRect setSize'\n                        } else {\n                            return 'setSizeRect unusedSetSize'\n                        }\n                    }\n                })\n        }\n    }\n\n    updateUnusedSets();\n\n\n    function updatePaginationDecoration() {\n        var internalLeftPadding = 0 // only local\n        var setsRight = unusedSets.length - ctx.setSelection.paginationEnd;\n        var setsLeft = ctx.setSelection.paginationStart;\n\n        var middlePos = ((paddingForPaginationRight - internalLeftPadding) / 2 + internalLeftPadding);\n        var paginationDistance = Math.floor(maxWidthUnused / cellDistance);\n\n        var pagi = headerSVG.selectAll(\".pagination\")\n            .data([{countRight: setsRight, countLeft: setsLeft, distance: paginationDistance}])\n        var pagiGroup = pagi.enter().append(\"g\").attr({\n            \"class\": \"pagination\"\n        })\n\n//        var finalPos = svgWidth-paddingForPaginationRight;\n        var finalPos = menuOffset;\n//        console.log(\"finalpos\", finalPos);\n        if (ctx.setSelection.mode !== \"none\") {\n            finalPos += paddingForPaginationRightExtra;\n        }\n\n        if (ctx.setSelection.modeChange) {\n            pagi.transition().attr({\n                \"transform\": \"translate(\" + (finalPos) + \",0)\"\n            })\n\n        } else {\n            pagi.attr({\n                \"transform\": \"translate(\" + (finalPos) + \",0)\"\n            })\n        }\n\n\n        pagiGroup.append(\"text\")\n            .style({\n                \"text-anchor\": \"middle\",\n                \"cursor\": \"default\",\n                \"font-weight\": \"bold\"\n            }).attr({\n            \"transform\": function () {\n\n                return \"translate(\" + (middlePos) + \",\" + (.8 * paginationLinespace) + \")\";\n            }\n        }).text(\"Set Selection\")\n\n\n        pagiGroup.append(\"rect\")\n            .attr({\n                \"class\": \"selectionRect setSelectionArea\",\n                x: -5,\n                width: paddingForPaginationRight - internalLeftPadding + 5,\n                height: paginationLinespace * .9,\n                opacity: 0\n            })\n\n\n        pagiGroup.append(\"text\").attr({\n            \"class\": \"right setSelectionLabelAwesome\"\n        }).style({\n            \"text-anchor\": \"end\"\n        }).attr({\n            \"transform\": function () {\n                return \"translate(\" + (paddingForPaginationRight - 2) + \",\" + (2 * paginationLinespace) + \")\";\n            }\n        })\n\n        pagiGroup.append(\"text\").attr({\n            \"class\": \"left setSelectionLabelAwesome\"\n        }).style({\n            \"text-anchor\": \"start\"\n        }).attr({\n            \"transform\": function () {\n                return \"translate(\" + (internalLeftPadding + 2) + \",\" + (2 * paginationLinespace) + \")\";\n            }\n        })\n\n\n        pagiGroup.append(\"text\").attr({\n            \"class\": \"info_distance\"\n        }).style({\n            \"text-anchor\": \"middle\",\n            \"cursor\": \"default\"\n        }).attr({\n            \"transform\": function (d) {\n                return \"translate(\" + (middlePos) + \",\"\n                    + (2 * paginationLinespace) + \")\";\n            }\n        })\n\n        pagiGroup.append(\"rect\").attr({\n            \"class\": \"multiSelect setSelectionButton\"\n        }).attr({\n            \"transform\": \"translate(\" + (internalLeftPadding + 2) + \",\" + (2.3 * paginationLinespace) + \")\",\n            width: paddingForPaginationRight - internalLeftPadding - 4,\n            height: .9 * paginationLinespace,\n            rx: 5,\n            ry: 5\n        })\n            .on({\n                \"click\": function () {\n                    if (ctx.setSelection.mode == \"none\") {\n                        ctx.setSelection.mode = \"multiSel\";\n                        ctx.setSelection.modeChange = true;\n                        plotSetOverview();\n                    } else if (ctx.setSelection.mode === \"multiSel\") {\n                        ctx.setSelection.multiSelIn = d3.set();\n                        ctx.setSelection.multiSelOut = d3.set();\n                        ctx.setSelection.mode = \"none\";\n                        ctx.setSelection.modeChange = true;\n                        plotSetOverview();\n                    }\n                }\n            })\n\n        pagiGroup.append(\"text\").attr({\n            \"class\": \"multiSelect setSelectionButtonText\"\n        }).style({\n            \"text-anchor\": \"middle\",\n            \"cursor\": \"pointer\",\n            \"pointer-events\": \"none\"\n        }).attr({\n            \"transform\": \"translate(\" + (middlePos) + \",\" + (3.0 * paginationLinespace) + \")\"\n        }).text(\"Batch Add Sets\")\n\n\n        pagiGroup.append(\"rect\").attr({\n            \"class\": \"sortFilter setSelectionButton\"\n        }).attr({\n            \"transform\": \"translate(\" + (internalLeftPadding + 2) + \",\" + (3.3 * paginationLinespace) + \")\",\n            width: paddingForPaginationRight - internalLeftPadding - 4,\n            height: .9 * paginationLinespace,\n            rx: 5,\n            ry: 5\n        })\n            .on({\n                \"click\": function () {\n                    if (ctx.setSelection.mode == \"none\") {\n                        ctx.setSelection.mode = \"sortFilter\";\n                        ctx.setSelection.modeChange = true;\n                        plotSetOverview();\n                    } else if (ctx.setSelection.mode === \"sortFilter\") {\n                        ctx.setSelection.mode = \"none\";\n                        ctx.setSelection.modeChange = true;\n                        plotSetOverview();\n                    }\n                }\n            })\n\n\n        pagiGroup.append(\"text\").attr({\n            \"class\": \"sortFilter setSelectionButtonText\"\n        }).style({\n            \"text-anchor\": \"middle\",\n            \"cursor\": \"pointer\",\n            \"pointer-events\": \"none\"\n        }).attr({\n            \"transform\": \"translate(\" + (middlePos) + \",\" + (4 * paginationLinespace) + \")\"\n        }).text(\"Sort Sets\")\n\n\n        // --- UPDATES\n\n        pagi.select(\".right\").text(function (d) {\n//            if (d.countRight < 1) return '-|'\n//            else return '>>';\n            if (d.countRight < 1) return ''\n            else return '\\uf0a9';\n        }).on({\n            \"click\": function (d) {\n                if (d.countRight > 0) {\n                    ctx.setSelection.paginationStart = ctx.setSelection.paginationStart + d.distance;\n\n                    plotSetOverview({animate: false});\n                } else {\n                    return;\n                }\n            }\n        })\n\n\n        pagi.select(\".left\")\n            .text(function (d) {\n//                if (d.countLeft < 1) return '|-'\n//                else return '<<'; })\n                if (d.countLeft < 1) return ''\n                else return '\\uf0a8';\n            })\n\n            //&#f053\n\n            .on({\n                \"click\": function (d) {\n                    if (d.countLeft > 0) {\n                        ctx.setSelection.paginationStart = Math.max(ctx.setSelection.paginationStart - d.distance, 0);\n                        plotSetOverview({animate: false});\n                    } else {\n                        return;\n                    }\n                }\n            })\n\n\n        pagi.select(\".info_distance\").text(function (d) {\n            return ctx.setSelection.paginationStart + \" - \" +\n                Math.min(ctx.setSelection.paginationEnd, unusedSets.length)\n        })\n\n//        pagi.select(\".multiSelect\").style({\n//            \"font-weight\": function () {\n////                if (ctx.setSelection.mode === \"multiSel\"){\n////                    return \"bold\"\n////                }else{\n//                    return \"normal\"\n////                }\n//            }\n//        })\n\n\n        var selRectPos = 0;\n        var selRectOpa = 0;\n        if (ctx.setSelection.mode === \"multiSel\") {\n            selRectPos = 2.3 * paginationLinespace;\n            selRectOpa = 1;\n        } else if (ctx.setSelection.mode === \"sortFilter\") {\n            selRectPos = 3.3 * paginationLinespace;\n            selRectOpa = 1;\n        }\n\n\n        if (ctx.setSelection.modeChange) {\n            pagi.select(\".selectionRect\").transition().duration(200)\n                .attr({\n                    y: selRectPos,\n                    opacity: selRectOpa\n                })\n\n        } else {\n            pagi.select(\".selectionRect\").attr({\n                y: selRectPos,\n                opacity: selRectOpa\n            })\n        }\n\n        updateSecondMenu();\n\n        // only one pass of mode change rendering\n        ctx.setSelection.modeChange = false;\n\n\n    }\n\n\n    function updateSecondMenu() {\n\n        var menuContent = []\n        if (ctx.setSelection.mode === \"multiSel\") {\n            menuContent =\n                [[\n                    {\n                        name: \"Add All Sets\", func: function () {\n                            unusedSets.forEach(function (d) {\n                                ctx.setSelection.multiSelIn.add(d.elementName);\n                            });\n                            ctx.setSelection.multiSelOut = d3.set();\n                            plotSetOverview();\n                        }\n                    },\n                    {\n                        name: \"Clear All Sets\", func: function () {\n                            ctx.setSelection.multiSelIn = d3.set();\n                            usedSets.forEach(function (d) {\n                                ctx.setSelection.multiSelOut.add(d.elementName);\n                            });\n\n                            plotSetOverview()\n                        }\n                    },\n                    {\n                        name: \"Cancel\", func: function () {\n                            ctx.setSelection.multiSelIn = d3.set();\n                            ctx.setSelection.multiSelOut = d3.set();\n\n                            //close multiselect panel\n                            ctx.setSelection.mode = \"none\"\n                            ctx.setSelection.modeChange = true\n                            plotSetOverview();\n                        }, fontawe: \"\\uf00d\"\n                    },\n                    {name: \"Confirm\", func: bulkChange, fontawe: \"\\uf00c\"}\n                ]]\n\n        } else if (ctx.setSelection.mode === \"sortFilter\") {\n            menuContent =\n                [[\n                    {\n                        name: \"by Size\", func: function () {\n                            ctx.setSelection.setOrder = \"size\"\n                            ctx.setSelection.mode = \"none\"\n                            ctx.setSelection.modeChange = true\n                            plotSetOverview();\n                        }\n                    },\n                    {\n                        name: \"by Name\", func: function () {\n                            ctx.setSelection.setOrder = \"name\"\n                            ctx.setSelection.mode = \"none\"\n                            ctx.setSelection.modeChange = true\n                            plotSetOverview()\n                        }\n                    }\n                ]]\n\n        }\n\n        var menuExtra = headerSVG.selectAll(\".setMenuExtra\").data(menuContent);\n        menuExtra.exit().remove();\n        var menuExtraGroup = menuExtra.enter().append(\"g\").attr(\"class\", \"setMenuExtra\").attr({\n            opacity: .1\n        })\n\n        menuExtraGroup.append(\"rect\").attr({\n            \"class\": \"setSelectionArea\",\n            x: 5,\n            width: paddingForPaginationRightExtra - 10,\n            height: textHeight + 5\n        })\n\n        if (ctx.setSelection.modeChange) {\n            menuExtra.transition().duration(500)\n                .attr({\n                    opacity: 1\n                });\n        }\n\n        menuExtra\n            .attr({\n                \"transform\": \"translate(\" + (menuOffset) + \",\" + 0 + \")\"\n            });\n\n\n        var menuExtraGroupEntries = menuExtraGroup.selectAll(\".menuExtraEntry\").data(function (d) {\n            return d;\n        })\n        menuExtraGroupEntries.enter().append(\"text\")\n            .attr({\n                \"class\": function (d) {\n                    if ('fontawe' in d) {\n                        return \"menuExtraEntry setMenuExtraAwesome\"\n                    } else {\n                        return \"menuExtraEntry\"\n                    }\n                },\n                \"transform\": function (d, i) {\n                    return \"translate(\" + (paddingForPaginationRightExtra / 2) + \",\" + ((1 + (i * 1.0)) * paginationLinespace) + \")\";\n                }\n            })\n            .style({\n                \"cursor\": \"pointer\",\n                \"text-anchor\": \"middle\"\n            })\n            .text(function (d) {\n                if ('fontawe' in d) {\n                    return d.fontawe + \" \" + d.name;\n                } else {\n                    return d.name;\n                }\n            })\n            .on(\"click\", function (d) {\n                d.func();\n            })\n\n\n    }\n\n\n//    // -- update position !!!\n\n//    var unusedSetsLabels =  overview.append(\"foreignObject\")\n//        .attr(\"width\", 710)\n//        .attr(\"height\", textHeight+20)\n//        .attr(\"x\", usedSets.length*cellSize)\n//        .attr(\"y\", 40)\n//      .append(\"xhtml:div\")\n//        .style(\"overflow-x\", \"auto\")\n//        .append(\"svg\")\n//        .attr({\n//            height: textHeight+20,\n//            width: unusedSets.length*cellSize\n//        })\n//        .append(\"g\")\n//        //.attr(\"transform\", \"translate(-50)\")\n//        .attr(\"class\", \"unusedSets\")\n//        .selectAll('.unusedSetsLabels')\n//        .data(unusedSets)\n//        .enter();\n//\n//    unusedSetsLabels\n//            .append('rect')\n//            .sort(sortFn)\n//            .attr({\n//                class: 'unusedSetSizeBackground',\n//                transform: function (d, i) {\n//                    return 'translate(' + (cellDistance * (i )) + ', 20)'\n//                },\n//                height: textHeight-2,\n//                width: cellSize\n//            })\n//            .on('click', setClicked)\n//\n//\n//    // background bar\n//    unusedSetsLabels\n//        .append('rect')\n//        .sort(sortFn)\n//        .attr({\n//            class: 'unusedSetSize',\n//            transform: function (d, i) {\n//                return 'translate(' + (cellDistance * i) + ', ' + ( textHeight - minorPadding - setSizeScale(d.setSize) + 21) + ')'\n//            }, // ' + (textHeight - 5) + ')'\n//            height: function (d) {\n//                return setSizeScale(d.setSize);\n//            },\n//            width: cellSize\n//        })\n//       // .on('mouseover', mouseoverColumn)\n//       // .on('mouseout', mouseoutColumn)\n//        .on('click', setClicked)\n//\n//    unusedSetsLabels\n//        .append('text').text(function (d) {\n//\n//          //var tmpText = d3.select(\"svg\").append(\"text\").attr(\"id\", \"tmpText\").text(d.elementName.substring(0, truncateAfter))\n//          //var str = Utilities.truncate(tmpText, 70)\n//          //tmpText.remove();\n//          var str = d.elementName.substring(0, truncateAfter)\n//          if(str.length<d.elementName.length)\n//            str = str.trim() + \"...\";\n//\n//            return str;\n//          })\n//        .sort(sortFn)\n//        .attr({\n//            class: 'setLabel',\n//         // Not sure we need this..\n//         //   id: function (d) {\n//         //       return d.elementName.substring(0, truncateAfter);\n//         //   },\n//                transform: function (d, i) {\n//                    return 'translate(' + (cellDistance * (i + 1) + 5) + ', 20) rotate(90)'\n//                },\n//            y: cellSize - 3,\n//            x: 3,\n//            height: textHeight-4,\n//            'text-anchor': 'start'\n//\n////            transform: function (d, i) {\n////                return 'translate(' + (cellDistance * (i ) + cellDistance / 2) + ',' + (setMatrixHeight + textHeight - textSpacing) + ')rotate(270)';\n////            }\n//      })\n//      .on('click', setClicked)\n//      .append(\"svg:title\")\n//      .text(function(d, i) { return d.elementName + \" (\" +d.setSize+ \")\"; });\n\n    function setClicked(d, i) {\n\n        if (ctx.setSelection.mode === \"multiSel\") {\n            if (d.isSelected) {\n                // for usedSets:\n                if (ctx.setSelection.multiSelOut.has(d.elementName)) {\n                    ctx.setSelection.multiSelOut.remove(d.elementName);\n                } else {\n                    ctx.setSelection.multiSelOut.add(d.elementName);\n                }\n            } else {\n                // for UNusedSets:\n                if (ctx.setSelection.multiSelIn.has(d.elementName)) {\n                    ctx.setSelection.multiSelIn.remove(d.elementName);\n                } else {\n                    ctx.setSelection.multiSelIn.add(d.elementName);\n                }\n            }\n            plotSetOverview();\n        } else {\n            updateSetContainment(d, true);\n        }\n\n\n//               d3.selectAll(\".bulkCheck\").transition().remove();\n    }\n\n\n    function bulkChange() {\n\n        var list_update =\n            sets.filter(function (d) {\n                return ctx.setSelection.multiSelIn.has(d.elementName) ||\n                    ctx.setSelection.multiSelOut.has(d.elementName)\n            })\n\n\n        ctx.setSelection.multiSelIn = d3.set();\n        ctx.setSelection.multiSelOut = d3.set();\n\n        //close multiselect panel\n        ctx.setSelection.mode = \"none\"\n        ctx.setSelection.modeChange = true\n\n        if (list_update.length > 0) {\n            // updateSetCon will call plot again\n            list_update.map(function (d, i) {\n                updateSetContainment(d, i == list_update.length - 1);\n            });\n        } else {\n            plotSetOverview()\n        }\n\n\n    }\n\n\n}\n\n//    overview.on('mouseover', function(d, i) {\n//\n//      // Remove current transitions\n//      d3.selectAll(\".bulkCheck\").transition();\n//\n//        var sortFn;\n//\n//        if (ctx.setOrder === \"name\") {\n//          sortFn = sortName;\n//        }  else {\n//          sortFn = sortSize;\n//        }\n//\n//      if(d3.selectAll(\".bulkCheck\")[0].length>5)\n//        return;\n//\n//        usedSets.filter(function(d, ii) {\n//\n//          d3.select(\".usedSets\")\n//            .append(\"foreignObject\")\n//            .datum([d])\n//            .attr(\"width\", 100)\n//            .attr(\"height\", 100)\n//            .attr(\"class\", \"bulkCheck\")\n//            .attr(\"y\", 40)\n//            .attr(\"x\", function(d, i) {\n//              return cellDistance * (ii);\n//            })\n//            .html(\"<form><input type=checkbox value=setcheck id=setcheck_\"+ii+\" checked/></form>\")\n//\n//        })\n//\n//        var unusedSetsCheck = unusedSets.sort(sortFn).filter(function(d, ii) {\n//\n//          d3.select(\".unusedSets\")\n//            .append(\"foreignObject\")\n//            .datum([d])\n//            .attr(\"width\", 100)\n//            .attr(\"height\", 100)\n//            .attr(\"class\", \"bulkCheck unusedSets\")\n//            .attr(\"y\", 0)\n//            .attr(\"x\", function(d, i) {\n//              return cellDistance * (ii);\n//            })\n//            .html(\"<form><input type=checkbox value=setcheck id=\"+ii+\" /></form>\")\n//\n//        })\n//\n//         d3.select(\"#headerVis\").select(\"svg\")\n//            .append(\"foreignObject\")\n//            .attr(\"width\", 100)\n//            .attr(\"height\", 100)\n//            .attr(\"class\", \"bulkCheck\")\n//            .attr(\"y\", 20)\n//            .attr(\"x\", function(d, i) {\n//              return 0;//ctx.w- usedSets.length*cellDistance-100;\n//            })\n//            .html(\"<form><input type=button value=update /></form>\")\n//            .on(\"click\", setClickedByBulk);\n//\n//         d3.select(\"#headerVis\").select(\"svg\")\n//            .append(\"foreignObject\")\n//            .attr(\"width\", 100)\n//            .attr(\"height\", 100)\n//            .attr(\"class\", \"bulkCheck\")\n//            .attr(\"y\", 20)\n//            .attr(\"x\", function(d, i) {\n//              return 60;//ctx.w- usedSets.length*cellDistance-100;\n//            })\n//            .html(\"<form><input type=button value='all' /></form>\")\n//            .on(\"click\", function() {\n//              d3.selectAll(\"input[value=setcheck]\").property(\"checked\", true);\n//            });\n//\n//         d3.select(\"#headerVis\").select(\"svg\")\n//            .append(\"foreignObject\")\n//            .attr(\"width\", 100)\n//            .attr(\"height\", 100)\n//            .attr(\"class\", \"bulkCheck\")\n//            .attr(\"y\", 20)\n//            .attr(\"x\", function(d, i) {\n//              return 95;//ctx.w- usedSets.length*cellDistance-100;\n//            })\n//            .html(\"<form><input type=button value='none' /></form>\")\n//            .on(\"click\", function() {\n//              d3.selectAll(\"input[value=setcheck]\").property(\"checked\", false);\n//            });\n//\n//         d3.select(\"#headerVis\").select(\"svg\")\n//            .append(\"foreignObject\")\n//            .attr(\"width\", 200)\n//            .attr(\"height\", 100)\n//            .attr(\"class\", \"bulkCheck\")\n//            .attr(\"y\", 20)\n//            .attr(\"x\", function(d, i) {\n//              return 145;//ctx.w- usedSets.length*cellDistance-100;\n//            })\n//            .html(\"<form style='font-size:12px'>Order by: <input type=radio name='order' value='size' \"+ (ctx.setOrder == 'size' ? 'checked' : '') +\"/> Size <input type=radio name='order' value='name' \"+ (ctx.setOrder == 'name' ? 'checked' : '') +\"/> Name</form>\")\n//            .on(\"click\", function() {\n//              d3.select(this).selectAll(\"input\").each(orderChange);\n//            });\n//\n//           d3.selectAll(\".bulkCheck\").on(\"mouseenter\", function() {\n//            // Remove current transitions\n//            d3.selectAll(\".bulkCheck\").transition();\n//          })\n//\n//        })\n//        .on('mouseout', function(d, i) {\n//            mouseoutColumn(d, i);\n//            d3.selectAll(\".bulkCheck\").transition().duration(1500).remove();\n//        })\n\n\n//function orderChange() {\n//    if(!this.checked)\n//        return;\n//\n//    var sortFn;\n//\n//    if (this.value === \"name\") {\n//        sortFn = sortName;\n//        ctx.setOrder = \"name\";\n//    }  else {\n//        sortFn = sortSize;\n//        ctx.setOrder = \"size\";\n//    }\n//\n//    d3.selectAll(\".unusedSets .unusedSetSizeBackground\")\n//        .sort(sortFn)\n//        .transition().duration(500).delay(function(d, i) {\n//            return i * 500 / unusedSets.length;\n//        })\n//        .attr(\"transform\", function (d, i) {\n//            return 'translate(' + (cellDistance * (i )) + ', 20)'\n//        })\n//    d3.selectAll(\".unusedSets .unusedSetSize\")\n//        .sort(sortFn)\n//        .transition().duration(500).delay(function(d, i) {\n//            return i * 500 / unusedSets.length;\n//        })\n//        .attr(\"transform\", function (d, i) {\n//            return 'translate(' + (cellDistance * i) + ', ' + ( textHeight - minorPadding - setSizeScale(d.setSize) + 20) + ')'\n//        })\n//\n//    d3.selectAll(\".unusedSets .setLabel\")\n//        .sort(sortFn)\n//        .transition().duration(500).delay(function(d, i) {\n//            return i * 500 / unusedSets.length;\n//        })\n//        .attr(\"transform\", function (d, i) {\n//            return 'translate(' + (cellDistance * (i + 1) + 5) + ', 20) rotate(90)'\n//        })\n//\n//    d3.selectAll(\".unusedSets .bulkCheck\").remove();\n//\n//    unusedSets.sort(sortFn).filter(function(d, ii) {\n//\n//        d3.select(\".unusedSets\")\n//            .append(\"foreignObject\")\n//            .datum([d])\n//            .attr(\"width\", 100)\n//            .attr(\"height\", 100)\n//            .attr(\"class\", \"bulkCheck\")\n//            .attr(\"y\", 0)\n//            .attr(\"x\", function(d, i) {\n//                return cellDistance * (ii);\n//            })\n//            .html(\"<form><input type=checkbox value=setcheck id=\"+ii+\" /></form>\")\n//\n//    })\n//\n//}\n"

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(47))

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Created by Alexander Lex on 3/4/14.\n */\n\nvar SET_SIZE_GROUP_PREFIX = 'SetSizeG_';\nvar EMPTY_GROUP_ID = 'EmptyGroup';\nvar SET_BASED_GROUPING_PREFIX = \"SetG_\";\n\nvar handleLogicGroups = function (subsets, level, parentGroup) {\n    filterGroups = [];\n    var deleteCandidates =[];\n    UpSetState.logicGroups.forEach(function (d) {\n        var maskList = d.getListOfValues();\n        var group = new QueryGroup(d.id, d.groupName, d.orClauses);\n        getSubsetsForMaskList(subsets, maskList, function (d) {\n            group.addSubSet(d);\n        });\n\n        if (group.subSets.length>0){\n            filterGroups.push(group)\n        }else{\n            deleteCandidates.push(d);\n        }\n    })\n\n    // TODO: HAS TO BE IMPROVED !!!\n    deleteCandidates.forEach(function(d){\n        UpSetState.logicGroups.slice(UpSetState.logicGroups.indexOf(d),1);\n    })\n\n\n}\n\nvar groupByOverlapDegree = function (subSets, level, parentGroup) {\n    var degree = 2;\n    if (level == 1) {\n        degree = UpSetState.levelOneDegree;\n    }\n    else if (level == 2) {\n        degree = UpSetState.levelTwoDegree;\n    }\n    var newGroups = []\n\n    var defaultMask;\n    if (parentGroup) {\n        defaultMask = parentGroup.combinedSets;\n    }\n\n    var combinations = Math.pow(2, usedSets.length) - 1;\n\n    var queries = []\n    for (var i = 0; i <= combinations; i++) {\n        fillMasks(i, usedSets.length, degree, queries, defaultMask);\n    }\n    for (var i = 0; i < queries.length; i++) {\n        var name = \"\";\n        for (var j = 0; j < queries[i].length; j++) {\n            if (queries[i][j] === 1) {\n                if (parentGroup.elementName !== usedSets[j].elementName)\n                    name += usedSets[j].elementName + \" \";\n            }\n        }\n        var group = new Group(\"Overlap_G_\" + i + \"_\" + parentGroup.id, name);\n        group.level = level;\n        group.combinedSets = queries[i];\n        getSubsetsForMaskList(subSets, [queries[i]], function (d) {\n            group.addSubSet(d);\n        });\n        if (group.subSets.length > 0) {\n            newGroups.unshift(group);\n        }\n    }\n\n    return newGroups;\n//    console.log(queries);\n\n//    for (var i = 0; i < subSets.length; i++) {\n//        mask = Array.apply(null, new Array(subSets.length)).map(Number.prototype.valueOf, 0);\n//        mask[i] = 1;\n//    }\n\n}\n\nvar fillMasks = function (setMask, length, minSets, queries, defaultMask) {\n\n    var bitMask = 1;\n\n    var query;\n    if (defaultMask) {\n        var query = defaultMask.slice(0);\n    }\n    else {\n        query = Array.apply(null, new Array(length)).map(Number.prototype.valueOf, 0);\n    }\n    var memberCount = 0;\n\n    for (var setIndex = length - 1; setIndex >= 0; setIndex--) {\n        if (query[setIndex] === 1) {\n            // true if this element is in the default mask\n            memberCount++;\n        }\n        else if ((setMask & bitMask) === 1) {\n            query[setIndex] = 1;\n            memberCount++;\n        }\n        else {\n            query[setIndex] = 2;\n        }\n        setMask = setMask >> 1;\n    }\n    if (memberCount == minSets) {\n        // FIXME this is to remove duplicates. We shouldn't produce them in the first place\n        var duplicate = false;\n        for (var i = 0; i < queries.length; i++) {\n            if (queries[i].compare(query)) {\n                duplicate = true;\n                break;\n            }\n        }\n        if (!duplicate) {\n            queries.push(query);\n        }\n    }\n\n//    var resultMasks = [];\n//    for (var maskCount = 0; maskCount < length; maskCount++) {\n//        for (var i = 0; i < length; i++) {\n//            var newMask = masks[maskCount].slice(0);\n//\n//\n//        }\n//    }\n}\n\nvar groupByRelevanceMeasure = function (subSets, level, parentGroup) {\n    var newGroups = [];\n    newGroups.push(new Group('GROUP_POS_DEV' + parentGroup.id, 'Positive Expected Value', level));\n    newGroups.push(new Group('GROUP_NEG_DEV' + parentGroup.id, 'Negative Expected Value', level));\n    newGroups.push(new Group(EMPTY_GROUP_ID + parentGroup.id, 'As Expected', level));\n    for (var i = 0; i < subSets.length; i++) {\n        var index = 0\n        if (subSets[i].disproportionality > 0) {\n            index = 0;\n        }\n        else if (subSets[i].disproportionality < 0) {\n            index = 1;\n        }\n        else {\n            index = 2;\n        }\n        newGroups[index].addSubSet(subSets[i])\n    }\n    return newGroups;\n}\n\nvar groupByIntersectionSize = function (subSets, level, parentGroup) {\n    var newGroups = [];\n    newGroups.push(new Group(EMPTY_GROUP_ID + parentGroup.id, 'Degree 0 (in no set)', level));\n    var maxSetSize = Math.min(usedSets.length, UpSetState.maxCardinality);\n    for (var i = UpSetState.minCardinality; i < maxSetSize; i++) {\n        newGroups.push(new Group(SET_SIZE_GROUP_PREFIX + (i + 1) + '_' + parentGroup.id, 'Degree ' + (i + 1) + \" (\" + (i + 1) + \" set intersect.)\", level));\n    }\n    subSets.forEach(function (subSet) {\n        var group = newGroups[subSet.nrCombinedSets];\n        if (group != null)\n            group.addSubSet(subSet);\n//        else\n//            console.log('Fail ' + group + subSet.nrCombinedSets);\n    })\n    return newGroups;\n}\n\n/**\n * Creates groups for all sets containing all subsets of this set\n */\nvar groupBySet = function (subSets, level, parentGroup) {\n\n    var newGroups = [];\n    var noSet = new Group(EMPTY_GROUP_ID, 'No Set', level);\n    newGroups.push(noSet);\n\n    for (var i = 0; i < usedSets.length; i++) {\n        var group = new Group(SET_BASED_GROUPING_PREFIX + (i + 1) + parentGroup.id, usedSets[i].elementName, level);\n        group.combinedSets = Array.apply(null, new Array(usedSets.length)).map(Number.prototype.valueOf, 2);\n        group.combinedSets[i] = 1;\n        newGroups.push(group);\n\n        subSets.forEach(function (subSet) {\n            if (subSet.combinedSets[i] !== 0) {\n                group.addSubSet(subSet);\n            }\n\n        });\n\n    }\n\n    subSets.forEach(function (subSet) {\n        if (subSet.id == 0) {\n            noSet.addSubSet(subSet);\n            noSet.combinedSets = subSet.combinedSets;\n        }\n    });\n\n    return newGroups;\n};\n\n/** Collapse or uncollapse group */\nvar collapseGroup = function (group) {\n    group.isCollapsed = !group.isCollapsed;\n\n    UpSetState.collapseChanged = true;\n    updateState();\n    return;\n\n};\n\nvar collapseAggregate = function (aggregate) {\n    aggregate.isCollapsed = !aggregate.isCollapsed;\n    updateState();\n};\n\n// ----------------------- Sort Functions ----------------------------\n\n/** Filters the provided list of subsets to include only those of length >0. If no list of subsets is provided the global list is used. */\nfunction getFilteredSubSets(subSetsToFilter) {\n    if (!subSetsToFilter) {\n        subSetsToFilter = subSets;\n    }\n    if (!UpSetState.hideEmpties) {\n        return subSetsToFilter.slice(0);\n    }\n    var filteredSubSets = []\n    for (var i = 0; i < subSetsToFilter.length; i++) {\n        if (subSetsToFilter[i].items.length > 0) {\n            filteredSubSets.push(subSetsToFilter[i]);\n        }\n    }\n    return filteredSubSets;\n}\n\nvar sortBySetItem = function (subSets, set) {\n    if (!set) {\n        set = usedSets[0];\n    }\n    var dataRows = getFilteredSubSets(subSets);\n    var setIndex = usedSets.indexOf(set);\n    dataRows.sort(function (a, b) {\n        // move all elements that contain the clicked set to the top\n        if (b.combinedSets[setIndex] !== a.combinedSets[setIndex]) {\n            return b.combinedSets[setIndex] - a.combinedSets[setIndex];\n        }\n        // move all elements with fewer intersections to the top\n        if (a.nrCombinedSets !== b.nrCombinedSets) {\n            return a.nrCombinedSets - b.nrCombinedSets;\n        }\n        // if the number of combined sets is identical, we can pick the largest one\n        return b.id - a.id;\n    });\n    return dataRows;\n}\n\nvar sortByCombinationSize = function (subSets) {\n    var dataRows = getFilteredSubSets(subSets);\n\n// sort by number of combinations\n    dataRows.sort(function (a, b) {\n        if (a.nrCombinedSets !== b.nrCombinedSets) {\n            return a.nrCombinedSets - b.nrCombinedSets;\n        }\n        // if the number of combined sets is identical, we can pick the largest one\n        return b.id - a.id;\n    });\n    return dataRows;\n}\n\n/** sort by size of set overlap */\nvar sortBySubSetSize = function (subSets) {\n    var dataRows = getFilteredSubSets(subSets);\n    dataRows.sort(function (a, b) {\n        return b.setSize - a.setSize;\n    });\n    return dataRows;\n}\n\n/** sort by size of set overlap */\nvar sortByExpectedValue = function (subSets) {\n    var dataRows = getFilteredSubSets(subSets);\n\n    dataRows.sort(function (a, b) {\n        return Math.abs(b.disproportionality) - Math.abs(a.disproportionality);\n    });\n    return dataRows;\n}\n\n/**\n * Takes a list of groups and writes them into an array, according to the nesting & collapse rules\n * @param groupList\n * @returns {*}\n */\nvar unwrapGroups = function (groupList) {\n    var dataRows = []\n    for (var i = 0; i < groupList.length; i++) {\n        var group = groupList[i];\n        // ignoring an empty empty group\n        if (group.id === EMPTY_GROUP_ID && group.setSize === 0 || (group.visibleSets.length === 0 && UpSetState.hideEmpties)) {\n            continue;\n        }\n        dataRows.push(group);\n        if (UpSetState.collapseAll && !(UpSetState.levelTwoGrouping && group.nestedGroups )) {\n            group.isCollapsed = true;\n        }\n        if (UpSetState.expandAll) {\n            group.isCollapsed = false;\n        }\n//        if (UpSetState.levelTwoGrouping && group.nestedGroups && (!group.isCollapsed || UpSetState.collapseAll)) {\n        if (UpSetState.levelTwoGrouping && group.nestedGroups && !group.isCollapsed) {\n\n            dataRows = dataRows.concat(unwrapGroups(group.nestedGroups, []));\n            continue;\n        }\n        if (!group.isCollapsed) {\n            dataRows = dataRows.concat(StateMap[UpSetState.sorting](group.visibleSets));\n\n            if (group.aggregate.subSets.length > 0 && !UpSetState.hideEmpties) {\n                dataRows.push(group.aggregate);\n                if (!group.aggregate.isCollapsed) {\n                    for (var k = 0; k < group.aggregate.subSets.length; k++) {\n                        dataRows.push(group.aggregate.subSets[k]);\n                    }\n                }\n            }\n        }\n    }\n\n    return dataRows;\n};\n\nvar StateMap = {\n    groupByIntersectionSize: groupByIntersectionSize,\n    groupBySet: groupBySet,\n    groupByRelevanceMeasure: groupByRelevanceMeasure,\n    groupByOverlapDegree: groupByOverlapDegree,\n\n    sortByCombinationSize: sortByCombinationSize,\n    sortBySubSetSize: sortBySubSetSize,\n    sortByExpectedValue: sortByExpectedValue,\n    sortBySubSetSize: sortBySubSetSize,\n    sortBySetItem: sortBySetItem\n};\n\nvar StateOpt = {\n    groupByIntersectionSize: 'groupByIntersectionSize',\n    groupBySet: 'groupBySet',\n    groupByRelevanceMeasure: 'groupByRelevanceMeasure',\n    groupByOverlapDegree: 'groupByOverlapDegree',\n\n    sortByCombinationSize: 'sortByCombinationSize',\n    sortBySubSetSize: 'sortBySubSetSize',\n    sortByExpectedValue: 'sortByExpectedValue',\n    sortBySetItem: 'sortBySetItem'\n};\n\nvar UpSetState = {\n    collapseAll: false,\n    expandAll: false,\n    // collapseChanged: false,\n\n    grouping: queryParameters[\"grouping\"] || StateOpt.groupByIntersectionSize,\n    levelTwoGrouping: undefined,\n\n    /** the degree used in case of groupByOverlapDegree on L1 */\n    levelOneDegree: 2,\n    /** the degree used in case of groupByOverlapDegree on L2 */\n    levelTwoDegree: 2,\n\n    sorting: StateOpt.sortByCombinationSize,\n\n    /** hide empty subsets, groups and aggregates */\n    hideEmpties: true,\n\n    /** Sets the upper threshold of cardinality of subsets */\n    maxCardinality: undefined,\n    /** Sets the lower threshold of cardinality of subsets */\n    minCardinality: 0,\n\n    forceUpdate: false,\n\n    /** user defined logic groups **/\n    logicGroups: [],\n    logicGroupChanged: false\n\n};\n\nvar previousState = false;\n\nvar updateState = function (parameter) {\n    var forceUpdate = !previousState || UpSetState.forceUpdate || (UpSetState.hideEmpties != previousState.hideEmpties);\n\n    // true if pure sorting - no grouping\n    if ((UpSetState.sorting && !UpSetState.grouping) && (forceUpdate || (previousState && previousState.sorting !== UpSetState.sorting))) {\n        dataRows = StateMap[StateOpt[UpSetState.sorting]](subSets, parameter);\n    }\n    else if (UpSetState.grouping && (forceUpdate || (previousState && previousState.grouping !== UpSetState.grouping || previousState.levelTwoGrouping !== UpSetState.levelTwoGrouping))) {\n        levelOneGroups = StateMap[StateOpt[UpSetState.grouping]](subSets, 1, \"\");\n\n        if (UpSetState.levelTwoGrouping) {\n            levelOneGroups.forEach(function (group) {\n                group.nestedGroups = StateMap[StateOpt[UpSetState.levelTwoGrouping]](group.subSets, 2, group);\n            });\n        }\n        dataRows = unwrapGroups(levelOneGroups);\n\n    }\n    else if (UpSetState.collapseChanged && UpSetState.grouping) {\n        dataRows = unwrapGroups(levelOneGroups);\n    }\n\n    if (UpSetState.logicGroupChanged) {\n        handleLogicGroups(subSets, 1);\n        UpSetState.logicGroupChanged = false;\n\n    }\n\n    if (filterGroups && filterGroups.length > 0) {\n        var filteredRows = unwrapGroups(filterGroups);\n        var separator = new Separator(\"FILTER_SEPARATOR\", 'Natural Intersections');\n        filteredRows.push(separator);\n        dataRows = filteredRows.concat(dataRows);\n    }\n\n    UpSetState.forceUpdate = false;\n    UpSetState.expandAll = false;\n    UpSetState.collapseAll = false;\n    UpSetState.collapseChanged = false;\n\n    renderRows.length = 0;\n\n    var registry = {};\n    var prefix = \"\";\n\n    var count = 1;\n    dataRows.forEach(function (element) {\n        var wrapper = {};\n\n        if (UpSetState.grouping === StateOpt.groupBySet || UpSetState.levelTwoGrouping === StateOpt.groupBySet) {\n            if (element.type === ROW_TYPE.SUBSET) {\n                wrapper.id = prefix + element.id;\n            }\n            else {\n                prefix = element.id + \"_\";\n                wrapper.id = element.id;\n            }\n        }\n        else {\n\n            if (registry.hasOwnProperty(element.id)) {\n                count = registry[element.id];\n                count += 1;\n                registry[element.id] = count;\n            }\n            else {\n                registry[element.id] = 1;\n            }\n\n            wrapper.id = element.id + '_' + count;\n        }\n        wrapper.data = element;\n        renderRows.push(wrapper);\n\n    });\n    previousState = JSON.parse(JSON.stringify(UpSetState));\n\n    queryParameters[\"grouping\"] = UpSetState.grouping;\n    // updateQueryParameters();\n\n};\n\n// external events that influence sort.js\nfunction bindEventsForSort() {\n    $(EventManager).bind(\"set-added\", function (event, data) {\n        UpSetState.logicGroups.forEach(function(lg){\n            lg.orClauses.forEach(function(orClause){\n                orClause[data.set.id] = {state:ctx.logicStates.DONTCARE};\n            })\n        })\n        UpSetState.logicGroupChanged = true;\n\n    })\n\n    $(EventManager).bind(\"set-removed\", function (event, data) {\n        UpSetState.logicGroups.forEach(function(lg){\n\n            lg.orClauses.forEach(function(orClause){\n                delete orClause[data.set.id];\n            })\n        })\n        UpSetState.logicGroupChanged = true;\n\n    })\n\n\n}\n\nbindEventsForSort();\n"

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(49))

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	module.exports = "\nfunction mouseoverColumn(d,i){\n    var combinedSets = usedSets.map(function(dd,ii){\n        return (dd.id== d.id)?1:0\n    })\n    mouseoverColumnImpl(combinedSets);\n\n\n}\n\nfunction mouseoverColumnImpl(combinedSets) {\n\n    d3.selectAll(\".connection, .combination rect, .setSize\")\n    //    .style(\"opacity\", .3)\n    .style(\"stroke\", \"white\")\n\n    d3.selectAll(\".connection.diagonal\").filter(function (dd, ii) {\n        return combinedSets[ii];\n//        return dd.id== d.id;\n    })\n        .style(\"opacity\", 1)\n        .style(\"stroke\", \"black\")\n\n\n//    d3.selectAll(\".combination\").selectAll(\"rect\").filter(function (dd, ii) {\n//        return combinedSets[ii];\n////        return dd.id== d.id;\n//    })\n//        .style(\"opacity\", 1)\n//        .style(\"stroke\", ctx.backHighlightColor)\n\n//    d3.selectAll(\".setSize\").filter(function (dd, ii) {\n//        return combinedSets[ii];\n////        return dd.id== d.id;\n//    })\n//        .style(\"opacity\", 1)\n//        .style(\"stroke\", \"black\")\n\n    d3.selectAll(\".setSizeBackground\").filter(function (dd, ii) {\n        return combinedSets[ii];\n//        return dd.id== d.id;\n    })\n        .style(\"opacity\", 1)\n        .style(\"fill\", ctx.backHighlightColor)\n\n    d3.selectAll(\".connection.vertical\").filter(function (dd, ii) {\n        return combinedSets[ii];\n//        return dd.id== d.id;\n    })\n        .style(\"opacity\", 1)\n//        .style(\"stroke\", \"black\")\n        .style(\"fill\",ctx.backHighlightColor)\n\n\n\n    ctx.columnBackgroundNode.selectAll(\".columnBackground\").style({\n        opacity:function(dd,i){\n            var value = combinedSets[i];\n            switch (value){\n                case 2:\n                    return 0; break;\n                default:\n                    return value;\n\n            }\n        }\n    })\n\n}\n\nfunction mouseoutColumn() {\n\n    d3.selectAll(\".connection, .combination rect\")\n        .style(\"opacity\", 1)\n        .style(\"stroke\", \"none\")\n\n    d3.selectAll((\".setSizeBackground\")).style({\n        \"stroke\": \"none\",\n        \"fill\":ctx.grays[0]\n    })\n\n    ctx.tableHeaderNode.selectAll(\".connection\")\n        .style(\"fill\", ctx.grays[0])\n\n    ctx.columnBackgroundNode.selectAll(\".columnBackground\").style({\n        opacity:0,\n        stroke:\"none\"\n    })\n\n}\n\nfunction mouseoverRow(d,i){\n  if (d.data.combinedSets) {\n    mouseoverRowImpl(d, d.data.combinedSets);\n  }\n}\n\nfunction mouseoverRowImpl(d, combinedSets) {\n\n\n    // plot Venn diagram with highlighting of selected subset\n    if ( d.data.type === 'SUBSET_TYPE') {\n        if ( usedSets.length > 1 || usedSets.length < 8 ) {\n            vennInstance.plot( [ d.data ], usedSets.length );\n        }\n    }\n\n    if ( d.data.type === 'GROUP_TYPE') {\n        if ( usedSets.length > 1 || usedSets.length < 8 ) {\n            vennInstance.plot( d.data.subSets, usedSets.length );\n        }\n    }\n\n    d3.selectAll(\".row .backgroundRect\")\n        .style({\n        \"stroke\":function(dd){\n                    if (d.id == dd.id) return \"black\";\n                    else null;\n                 },\n        \"fill-opacity\":function(dd){\n                   if (d.id == dd.id) return .7;\n                    else return 0.001;\n                }\n\n        })\n\n\n\n\n\n//    mouseoverColumn(d.data.combinedSets)\n    mouseoverColumnImpl(combinedSets)\n\n}\n\nfunction mouseoutRow() {\n\n    // plot Venn diagram without highlighting\n    vennInstance.plot(null, usedSets.length );\n\n    d3.selectAll(\".row .backgroundRect\")\n        .style({\"stroke\":null,\n            \"fill-opacity\":0\n        })\n    mouseoutColumn();\n}\n\nfunction mouseoverCell(rowData, columnIndex) {\n\n    var combinedSets = rowData.data.combinedSets.map(function(d,i){\n        if (i==columnIndex) return 1;\n        else return d;\n    })\n\n\n\n    mouseoverRowImpl(rowData, combinedSets)\n\n    var columnBackgrounds = ctx.columnBackgroundNode.selectAll(\".columnBackground\").style({\n        stroke:function(dd,i){if (i==columnIndex) return 1; else return \"none\"}\n    })\n\n    d3.selectAll(\".setSize\").style({\n        stroke:function(dd,i){if (i==columnIndex) return \"black\"; else return \"white\"}\n    })\n//        .style(\"opacity\", 1)\n//        .style(\"fill\", ctx.backHighlightColor)\n//\n\n\n\n    d3.selectAll(\".connection.vertical\")\n        .style(\"stroke\",function(d,i){\n            return (i==columnIndex)?\"black\":\"none\";\n        })\n\n\n\n//    columnBackgrounds.filter(function(d,i){return i==columnIndex})\n//        .style({\n//            opacity:1\n//        })\n\n}\n\nfunction mouseoutCell() {\n\n    mouseoutRow()\n\n}\n"

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(51))

/***/ }),
/* 51 */
/***/ (function(module, exports) {

	module.exports = "function Scrollbar(params) {\n\n\tthis.parentEl = params.parentEl;\n\tthis.x = params.x;\n\tthis.y = params.y;\n\tthis.width = params.width || 20;\n  this.height = params.height || 200;\n\tthis.value = params.initValue || 0;\n\n\tthis.rowsHeight = params.rowsHeight || 200;\n\tthis.viewportHeight = params.viewportHeight;\n\n\tif(this.rowsHeight < this.viewportHeight)\n\t\tthis.thumbHeight = this.height; // Nothing to scroll\n\telse\n\t\tthis.thumbHeight = this.height - this.height*(this.rowsHeight - this.viewportHeight) / this.rowsHeight; // Test\n\n\t// Ideally we should have some listeners\n\tthis.listeners = [];\n\n\tthis.min = params.min;\n\tthis.max = params.max;\n\n\t// In case we want some ticks on the scrollbar\n\tthis.ordinal_axis = d3.scale.ordinal().domain(d3.range(this.min, this.max+1)).rangePoints([0, this.height]);\n\tthis.linear_axis = d3.scale.linear().domain([this.min, this.max]).range([0, this.height]);\n\n\tthis.scale = d3.scale.linear().domain([0, this.viewportHeight-this.rowsHeight]).range([0,\tthis.height*(this.rowsHeight - this.viewportHeight) / this.rowsHeight]);\n\n\tvar that = this;\n\n  var dragScrollbar = d3.behavior.drag()\n          .origin(Object)\n          .on(\"dragstart\", dragstartScrollbar)\n          .on(\"drag\", dragScrollbar)\n          .on(\"dragend\", dragendScrollbar);\n\n   var backgroundScrollbar = this.parentEl.append(\"rect\").attr({\n      width: 20,\n      height: params.height,\n      fill: 'lightgray',\n      class: \"scrollbar-background\",\n      x: params.x,\n      y: params.y\n    });\n\n  this.parentEl.selectAll(\".scrollbar-thumb\").remove()\n\n  this.gThumb = this.parentEl.selectAll(\".scrollbar-thumb\")\n      .data([{value: this.value, dx:0, x:0, y:0}])\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", \"scrollbar-thumb\")\n      .on(\"mouseover\", function(d){\n          d3.select(this).style(\"cursor\", \"pointer\")\n      })\n      .call(dragScrollbar);\n\n   this.gThumb.append(\"rect\")\n        .attr(\"width\", 20)\n        .attr(\"height\", this.thumbHeight)\n        .attr(\"x\", params.x)\n        .attr(\"y\", params.y)\n        .attr(\"rx\", 20)\n        .attr(\"ry\", 10)\n        .attr(\"fill\", \"gray\")\n\n    function dragstartScrollbar(d) {\n      d.dx = 0;\n    }\n\n\n    function dragendScrollbar(d) {\n\n    }\n\n    function dragScrollbar(d) {\n      d.y += d3.event.dy;\n      d.y = Math.max(0, Math.min(d.y, that.height-that.thumbHeight))\n\n      that.gThumb.attr(\"transform\", \"translate(\"+[0, d.y]+\")\");\n\n      d3.select(\".gRows\").attr('transform', 'translate(0, ' + that.scale.invert(d.y) + ')');\n\n      // Subset background should stick to his place\n      d3.select(\".background-subsets\").attr('transform', function (d, i) {\n          return 'translate(' + [ 0, d.y ] + ')'\n      });\n    }\n\n }\n\nScrollbar.prototype.setValue = function(value) {\n\tthis.value = value;\n\tvar new_y = this.scale(value);\n\tthis.gThumb.attr(\"transform\", function(d) {\n\t\td.y = Math.min(0, new_y);\n\t\treturn \"translate(\"+[0, -d.y]+\")\";\n\t})\n}\n"

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(53))

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	module.exports = "function plotSelectionTabs( element, selections, activeSelection ) {\n    // clear target element\n    d3.select(element).html(\"\");\n\n    if ( selections.getSize() <= 0 ) {\n        d3.select(element).append('div' )\n            .attr( 'class', 'info-message' )\n            .html( 'No queries. Click <i class=\"fa fw fa-plus\"></i> button to add a new query.' );\n\n        d3.select('#filters-list').html(\"\");\n        d3.select('#filters-list').append( \"div\" ).attr( \"class\", \"info-message\" ).html( 'No active query.' );\n        d3.select('#filters-controls').html(\"\");\n    }\n    else {\n        var table = d3.select(element)\n            .append(\"table\")\n            .attr(\"class\", \"selection-tab-list\");\n\n        var tbody = table.append(\"tbody\");\n\n        var tabs = tbody.append(\"tr\")\n                .selectAll(\"td\")\n                .data(selections.list)\n            .enter()\n                .append(\"td\")\n                    .attr(\"class\", \"selection-tab\")\n                    .classed( { 'active': function(d,i) { return ( selections.isActive(d) ); } } )\n                    .on(\"click\", function(k) { // is attribute object\n                        // check if selection has been deleted or not\n                        if ( selections.getSelectionFromUuid( k.id ) ) {\n                            selections.setActive( k );\n                        }\n                    });\n\n                tabs.append(\"i\")\n                    .attr( \"class\", \"fa fa-square\" )\n                    .style(\"color\", function(d,i) { return ( selections.getColor( d ) ); } )\n                    .style( \"margin-right\", \"2px\");\n                tabs.append(\"span\")\n                    .text(function(d) { return d3.format(\"5d\")( d.items.length ); });\n                tabs.append(\"i\")\n                    .attr( \"class\", \"fa fa-times-circle\" )\n                    .style( \"margin-left\", \"5px\")\n                    .on(\"click\", function(k) { // is attribute object\n                        selections.removeSelection( k );\n                    });\n    }\n\n\n\n    d3.select('#selection-controls').html(\"\");\n    d3.select('#selection-controls')\n        .append('div')\n        .attr('class', 'selection-button level-1-button')\n        .attr('title', 'Create element query' )\n        .html('<i class=\"fa fw fa-plus\"></i>')\n        .on(\"click\", function(event){\n            createInitialSelection();\n        });\n}\n\n\nfunction plotSelectedItems( elementId, selection ) {\n\n    var element = d3.select(elementId);\n    // clear target element\n    element.html(\"\");\n\n    if ( !selection || selections.getSize() === 0 || !selections.getColor( selection ) ) {\n        element.append( \"div\" ).attr( \"class\", \"info-message\" ).html( '' );\n        return;\n    }\n\n    //d3.select(element).html('<p>' + selection.items.length + ' of ' + depth + ' selected</p>')\n\n    /*\n    for ( var i = 0; i < selection.filters.length; ++i ) {\n        filter.renderViewer(element, selection, selection.filters[i].uuid );\n    }\n    */\n    selection.filterCollection.renderController(d3.select(\"filters-controller\"));\n\n    var table = element.append(\"table\");\n    var thead = table.append(\"thead\");\n    var tbody = table.append(\"tbody\");\n\n    var selectionColor = parseInt( selections.getColor( selection ).substring(1), 16 );\n    //console.log( selectionColor + \" --- \" + selections.getColor( selection ) + \" --- \" + ( ( selectionColor << 24 ) >>> 24 ).toString(16) );\n    //console.log( 'rgba(' + ( ( ( selectionColor << 8 ) >> 24 ) >>>0 ) + ',' + ( ( ( selectionColor << 16 ) >> 24 ) >>> 0 ) + ',' + ( ( ( selectionColor << 24 ) >> 24 ) >>> 0 ) + ', 0.25)' );\n\n    var renderedAttributes = attributes.filter(function(_attribute){\n      if (_attribute.hidden) {\n        return false\n      }\n      return true\n    })\n    var idAttribute = attributes.find(function(_attribute){\n      return _attribute.type === 'id'\n    })\n    thead.append(\"tr\")\n            .selectAll(\"th\")\n            .data(renderedAttributes.slice(0,renderedAttributes.length-1)) // don't show set column\n        .enter()\n            .append(\"th\")\n                .style(\"background-color\", 'rgba(' + ( ( ( selectionColor << 8 ) >> 24 ) >>>0 ) + ',' + ( ( ( selectionColor << 16 ) >> 24 ) >>> 0 ) + ',' + ( ( selectionColor << 24 ) >>> 24 ) + ', 0.5)' )\n                .style(\"border-bottom\", \"3px solid \" + selections.getColor( selection ) )\n                .attr(\"class\", \"item-table-header\" )\n                .text(function(d) { return d.name; })\n                .on(\"click\", function(k) { // is attribute object\n\n                    thead.selectAll('th').data(renderedAttributes).text(function(d) { return d.name; });\n                    d3.select(this).html( ( k.sort > 0 ? \"&#x25B2;\" : \"&#x25BC;\" ) + \" \" + k.name );\n                    rows.sort( function(a, b) {\n                        switch ( k.type ) {\n                            case 'integer':\n                                // fall-through\n                            case 'float':\n                                return k.sort * ( k.values[a] - k.values[b] );\n                            case 'id':\n                                // fall-through\n                            case 'string':\n                                // fall-through\n                            default:\n                                if ( k.values[a] < k.values[b] ) {\n                                    return k.sort * -1;\n                                }\n                                if ( k.values[a] > k.values[b] ) {\n                                    return k.sort * 1;\n                                }\n\n                                return 0;\n                        }\n                    });\n                    // switch sort order\n                    k.sort = k.sort * -1;\n                });\n\n    var rows = tbody.selectAll(\"tr\")\n            .data(selection.items.slice(0,1000))\n        .enter()\n            .append(\"tr\").attr('data-item-id', function(d){\n              if (idAttribute) {\n                return idAttribute.values[d]\n              }\n            }).attr('class', 'table-element-item')\n            .each(function(d,i) {\n                d3.select(this).selectAll(\"td\")\n                    .data(renderedAttributes.slice(0,renderedAttributes.length-1))\n                .enter()\n                    .append(\"td\")\n                    .text(function(a) { return a.values[selection.items[i]] });\n            });\n}\n"

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(55))

/***/ }),
/* 55 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Created by Hendrik Strobelt on 3/11/14.\n */\n\n\n\nfunction SetGrouping(params){\n    var width = params.width+10;\n    var gQuery = params.queryElement;\n    var vis = params.visElement;\n    var cellSize = params.cellSize;\n    var usedSets = params.usedSets;\n\n//    console.log(globalContext);\n\n    // to be bound !!\n    var grays = ['#f0f0f0', '#636363'];\n    var groupingByList = [\n        {name:\"by set size\", groupFunction:function(){console.log(\"by set size\");}},\n        {name:\"by sets\", groupFunction:function(){console.log(\"by size\");}},\n        {name:\"by weather\", groupFunction:function(){console.log(\"by size\");}}\n    ]\n\n\n\n    var collapseHeight = cellSize+5;\n    var uncollapseHeight = 70;\n    var isCollapsed = true;\n\n    var toggleState = {}\n\n\n\n\n\n    var init = function(){\n\n//        vis.attr({\n//            \"transform\":\"translate(\"+0+\",\"+(collapseHeight+6)+\")\"\n//        })\n\n        gQuery.append(\"rect\").attr({\n            class:\"menuPlaceholder menuPlaceholderRect\",\n            width:width,\n            height:collapseHeight\n        })\n        .style({\n            fill:\"none\",\n            stroke: grays[1]\n        })\n\n\n        gQuery.append(\"rect\").attr({\n            class:\"menuPlaceholder collapseButton\",\n            x:width/2-50,\n            y:2,\n            width:100,\n            height: collapseHeight-4\n        })\n            .style({\n                \"fill\":\"white\"\n            }).on({\n                \"click\":function(d){ toggleMenu()}\n\n            })\n\n        gQuery.append(\"text\").text(\"vvvv  detail\").attr({\n            class:\"menuPlaceholder menuPlaceholderText columnLabel\",\n            \"text-anchor\":\"middle\",\n            \"transform\":\"translate(\"+(width-10)+\",\"+(collapseHeight/2)+\")\"\n        })\n            .style({\n//                \"font-size\":\"8pt\",\n                \"text-anchor\":\"end\"\n            })\n            .on({\n                \"click\":function(d){toggleMenu()}\n\n            })\n\n\n        var patternDef = gQuery.append(\"defs\").append(\"pattern\").attr({\n            id:\"HalfSelectPattern\",\n            patternUnits:\"userSpaceOnUse\",\n            x:\"0\",\n            y:\"0\",\n            width:cellSize,\n            height:cellSize\n        })\n        patternDef.append(\"rect\").attr({\n                x:cellSize/2,\n                y:\"0\",\n                width:cellSize/2,\n                height:cellSize\n\n            }).style({\n                fill: grays[1]\n            })\n        patternDef.append(\"rect\").attr({\n            x:0,\n            y:\"0\",\n            width:cellSize/2,\n            height:cellSize\n\n        }).style({\n                fill: grays[0]\n            })\n\n\n        var groupSelector = gQuery.append(\"g\").attr({\n           class:\"groupSelector\",\n            \"transform\":\"translate(\"+5+\",\"+2+\")\"\n\n        })\n        usedSets.forEach(function(d){\n            toggleState[d.id]=2;\n        })\n\n        groupSelector.selectAll(\".selectorCircle\").data(usedSets.map(function(d){return d.id;})).enter()\n           .append(\"circle\").attr({\n                class:\"selectorCircle\",\n                cx:function(d,i){return (i*cellSize)+cellSize/2},\n                cy:function(d,i){return cellSize/2},\n                r: cellSize/2-1\n            })\n            .style({\n//                stroke:grays[1],\n                fill:function(d){\n                    switch(toggleState[d])\n                    {\n                        case 0:\n                            return grays[0]\n                            break;\n                        case 1:\n                            return grays[1]\n                            break;\n                        default:\n                            return \"url(#HalfSelectPattern)\"\n                    }}\n            })\n            .on({\n                \"click\":function(d){toggleCircle(d);}\n\n            })\n\n        var xoffset = usedSets.length*cellSize +5;\n        var buttonWidth = 70\n        groupSelector.append(\"text\").text(\"filter\").attr({\n            class:\"columnLabel\",\n            x: xoffset,\n            y: cellSize/2\n        }).style({\n                \"text-anchor\":\"start\"\n        })\n\n        groupSelector.selectAll(\".groupAction\").data(groupingByList).enter()\n            .append(\"text\")\n            .text(function(d){return d.name})\n            .attr({\n                class:\"groupAction columnLabel\",\n                x: function(d,i){return xoffset + (i+1)*(buttonWidth+3)},\n                y: cellSize/2\n            })\n\n\n\n\n    }\n\n    init();\n\n\n\n\n    var toggleCircle= function(id){\n        toggleState[id] = (toggleState[id]+1) % 3;\n\n        gQuery.selectAll(\".selectorCircle\").style({\n            fill:function(d){\n       //         console.log(d);\n                switch(toggleState[d])\n            {\n                case 0:\n                    return grays[0]\n                    break;\n                case 1:\n                    return grays[1]\n                    break;\n                default:\n                    return \"url(#HalfSelectPattern)\"\n            }}\n        })\n\n\n    }\n\n\n    var toggleMenu= function(){\n\n        if (isCollapsed){\n            gQuery.select(\".menuPlaceholderRect\").transition().attr({\n                height:uncollapseHeight\n            })\n\n            gQuery.select(\".menuPlaceholderText\").text(\" ^^^^  detail\")\n\n            vis.transition().attr({\n                \"transform\":\"translate(\"+0+\",\"+(uncollapseHeight+2)+\")\"\n            })\n\n\n            isCollapsed=false;\n        }else{\n            gQuery.select(\".menuPlaceholderRect\").transition().attr({\n                height:collapseHeight\n            })\n\n            gQuery.select(\".menuPlaceholderText\").text(\"vvvv  detail\")\n\n            vis.transition().attr({\n                \"transform\":\"translate(\"+0+\",\"+(collapseHeight+2)+\")\"\n            })\n\n            isCollapsed=true;\n\n        }\n\n\n\n\n\n    }\n\n\n//    vis.append(\"rect\").attr({\n//\n//\n//\n//    })\n//\n\n\n\n\n\n\n\n}\n"

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(57))

/***/ }),
/* 57 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Created by hen (hendrik.strobelt.com)\n */\n\nfunction LogicPanel(params){\n\n    var width = params.width;          // width for the whole row\n    var vis = params.visElement;       // the node for whole vis\n    var panel = params.panelElement;    // panel element\n    var cellSize = params.cellSize;     // cell size for a particular subset indicator (circle)\n    var usedSets = params.usedSets;     // all used Sets\n    var grays = params.grays;           // range of grays used for dot labeling\n    var belowVis = params.belowVis;     // the vis node below the panel (to be translated)\n    var buttonX = params.buttonX;       // button X coordinate\n    var buttonY = params.buttonY;       // button Y coordinate\n    var subsets = params.subsets;\n    var cellWidth = params.cellWidth; // width of cells\n    var ctx = params.ctx\n\n    var stateObject= params.stateObject\n    var callAfterSubmit = params.callAfterSubmit;\n\n\n    // to be bound !!\n//    var grays = ['#f0f0f0', '#636363'];\n//    var groupingByList = [\n//        {name:\"by set size\", groupFunction:function(){console.log(\"by set size\");}},\n//        {name:\"by sets\", groupFunction:function(){console.log(\"by size\");}},\n//        {name:\"by weather\", groupFunction:function(){console.log(\"by size\");}}\n//    ]\n\n\n    this.logicState = ctx.logicStates;\n\n    var me = this;\n\n\n    var setNames= {}\n    var collapseHeight = cellSize;\n    var uncollapseHeight = 95;\n    var isCollapsed = true;\n    var toggleState = {}\n    var isNewPanel = true;\n    var belowVisRestoreTranslate = \"translate(0, 90)\"\n\n    var actualGroupLabel = \"Query\"\n\n//    var getListOfValues = function(){\n//        console.log(this);\n//        var compareList= []\n//        this.orClauses.forEach(function(orClause){\n//\n//            var compareObject = []\n//            for (key in orClause){\n//                compareObject.push(orClause[key].state);\n//            }\n//            compareList.push(compareObject)\n//        })\n//\n//        return compareList;\n//    }\n\n\n    var logicExpression = {}\n    var actualOrClause = 1;\n\n    var initLogicExpression = function(){\n        logicExpression = {\n            groupName:\"\",\n            orClauses:[],\n            getListOfValues:function(){\n\n                var compareList= []\n                this.orClauses.forEach(function(orClause){\n\n                    var compareObject = []\n                    for (key in orClause){\n                        compareObject.push(orClause[key].state);\n                    }\n                    compareList.push(compareObject)\n                })\n\n                return compareList;\n            }\n        }\n\n\n    }\n\n\n\n    // the color for logic related stuff (highlighting & button)\n    const logicColor = \"#a1d99b\";\n\n    var addLogicButton = {}\n\n\n    var init = function(){\n        //### add button ##\n        addLogicButton = vis.append(\"g\").attr({\n            class:\"logicAddButton\",\n            \"transform\":\"translate(\"+buttonX+\",\"+buttonY+\")\"\n        })\n\n//        addLogicButton.append(\"rect\").attr({\n//            width:60,\n//            height:18\n//        }).style({fill: logicColor })\n//            .on(\"click\", addLogic)\n\n        addLogicButton.append(\"rect\").attr({\n            width:20,\n            height:20,\n            x:0,\n            y:0,\n            rx:5,\n            ry:5\n\n        }).style({fill: logicColor, \"cursor\":\"pointer\", opacity:.5 })\n            .on(\"click\", addLogic)\n            .on(\"mouseover\",function(){d3.select(this).style(\"opacity\",1);})\n            .on(\"mouseout\",function(){d3.select(this).style(\"opacity\",.5);})\n\n        addLogicButton.append(\"text\").attr({\n            class:\"selection-button\",\n            \"transform\":\"translate(\"+3+\",\"+16+\")\",\n            \"pointer-events\":\"none\"\n        }).style({\n                \"font-family\":\"FontAwesome\"\n\n            })\n            .text('\\uf067')\n\n\n\n        addLogicButton.append(\"text\").attr({\n            class:\"addButton\",\n            x:25,\n            y:10\n        }).style({ fill:\"black\", \"text-anchor\":\"start\", \"cursor\":\"auto\" })\n            .text(\"Query\")\n//            .on(\"click\", addLogic)\n\n\n        defineDontCarePattern(panel,cellSize,grays);\n\n        initLogicExpression();\n\n    }\n\n\n    var defineDontCarePattern = function(gQuery, cellSize, grays){\n        var patternDefAll = gQuery.selectAll(\"defs\").data([cellSize], function(d){return d;})\n        patternDefAll.exit().remove();\n\n\n//        if (removed.length<1){\n        var patternDef = patternDefAll.enter().\n        append(\"defs\").append(\"pattern\").attr({\n                id:\"DontCarePattern\",\n//            patternUnits:\"userSpaceOnUse\",\n                patternContentUnits:\"objectBoundingBox\",\n                x:\"0\",\n                y:\"0\",\n                width:1,\n                height:1\n            })\n\n\n        patternDef.append(\"rect\").attr({\n            x:0,\n            y:0,\n            width:1,\n            height:1,\n            fill: grays[0]\n        })\n        patternDef.append(\"circle\").attr({\n            cx:.5,\n            cy:.5,\n            r:.2,\n            fill: grays[1]\n\n        })\n\n\n\n\n//        patternDef.append(\"rect\").attr({\n//            x:.5,\n//            y:0,\n//            width:.5,\n//            height:1,\n//            fill: grays[1]\n//        })\n//        patternDef.append(\"rect\").attr({\n//            x:0,\n//            y:0,\n//            width:.5,\n//            height:1,\n//            fill: grays[0],\n//            transform:\"rotate(45)\"\n//        })\n    }\n\n\n    var addLogic = function(){\n\n        addLogicButton.attr({\n            \"opacity\":0\n        })\n        belowVisRestoreTranslate= +belowVis.attr(\"y\");\n\n\n        // define first orClause as dontcare ANDs\n        logicExpression.orClauses[0] = {};\n        usedSets.forEach(function(d){\n            logicExpression.orClauses[0][d.id]={state:me.logicState.DONTCARE};\n//            logicExpression.orClauses[0][d.id]={state:Math.floor(Math.random()*3)};\n        })\n\n        logicExpression[\"id\"] = \"LogicGroup_\"+(new Date().getTime())\n\n        actualOrClause=0;\n        isNewPanel= true;\n\n        setNames={}\n        usedSets.forEach(function(d){\n            setNames[d.id] = d.elementName\n        })\n        actualGroupLabel = \"Query\"\n\n        renderActualPanel();\n    }\n\n    var addOrClause = function(){\n\n        var id = logicExpression.orClauses.length;\n        logicExpression.orClauses[id] = {};\n        usedSets.forEach(function(d){\n            logicExpression.orClauses[id][d.id]= {state:me.logicState.DONTCARE};\n//            logicExpression.orClauses[id][d.id]={state:Math.floor(Math.random()*3)};\n        })\n        actualOrClause= id;\n        renderActualPanel();\n    }\n\n\n    var selectRow = function(index){\n        if (index != actualOrClause){\n            actualOrClause= index;\n            renderActualPanel();\n        }else{\n            actualOrClause = -1;\n            renderActualPanel();\n        }\n    }\n\n    var removeRow = function(index){\n        logicExpression.orClauses.splice(index,1)\n        actualOrClause=actualOrClause-1;\n        if (logicExpression.orClauses.length==0) destroyPanel();\n        else renderActualPanel();\n    }\n\n\n    function changeState(orClause, id, state) {\n         logicExpression.orClauses[actualOrClause][id] = {state:state};\n\n//        console.log(\"here\");\n         panel.selectAll(\".logicPanelRow\").filter(function(d,i){return (i==actualOrClause)})\n             .each(function(d){\n                 renderSelectorTable(this, true, false, actualOrClause);\n                })\n\n    }\n\n    this.getTextDescription = function(actualOrClause){\n        var actualClause = logicExpression.orClauses[actualOrClause]\n        var collectExpressions = {}\n\n        Object.keys(actualClause).forEach(function(d){\n\n            var setList = collectExpressions[actualClause[d].state]\n            if (setList==null){\n                setList=[setNames[d]]\n            }else{\n                setList.push(setNames[d])\n            }\n            collectExpressions[actualClause[d].state] = setList\n\n        })\n\n        //console.log(\"expression\",collectExpressions);\n\n        var setNameListLength = Object.keys(setNames).length;\n        var expression = \"\";\n\n        Object.keys(me.logicState).forEach(function (dd){\n            var d = me.logicState[dd];\n            if (collectExpressions[d]!=null && collectExpressions[d].length ==setNameListLength){\n                switch(d){\n                    case me.logicState.NOT:\n                        expression=  \"the intersection that does not intersect with any selected set\";\n                        break;\n                    case me.logicState.DONTCARE:\n                        expression =  \"all intersections of all selected sets\";\n                        break;\n                    case me.logicState.MUST:\n                        expression = \"the intersection of all selected sets\";\n                        break;\n                    default : break;\n                }\n            }\n        })\n\n        if (expression.length<1){\n            expression = \"intersections of  \";\n\n            var but = \"\";\n            if (collectExpressions[me.logicState.MUST]!=null){\n                expression += \"set\"+((collectExpressions[me.logicState.MUST].length>1)?\"s \":\" \")\n                expression += collectExpressions[me.logicState.MUST].map(function(d){return \"[\"+d+\"]\"}).join(\" and \")\n                but=\" but \"\n            }\n            if (collectExpressions[me.logicState.NOT]!=null){\n                expression += but+\"excluding \"+ \"set\"+((collectExpressions[me.logicState.NOT].length>1)?\"s \":\" \");\n                expression += collectExpressions[me.logicState.NOT].map(function(d){return \"[\"+d+\"]\"}).join(\" and \")\n            }\n\n\n        }\n\n\n//            console.log(collectExpressions);\n\n        return expression;\n\n\n    }\n\n\n\n    function changeStateAll(actualOrClause, state) {\n        var actualClause = logicExpression.orClauses[actualOrClause]\n        Object.keys(actualClause).forEach(function(d){\n           actualClause[d]= {state:state};\n        })\n\n        //console.log(\"here\");\n        panel.selectAll(\".logicPanelRow\").filter(function(d,i){return (i==actualOrClause)})\n            .each(function(d){\n                renderSelectorTable(this, true, false, actualOrClause);\n            })\n    }\n\n\n//    function createLineWrapperField(d3Node){\n//        d3Node.html(\n//                '<g requiredFeatures=\"http://www.w3.org/Graphics/SVG/feature/1.2/#TextFlow\"> \\\n//                    <textArea width=\"200\" height=\"auto\" class=\"logicPanelActualText\"> \\\n//                    Text goes here \\\n//                    </textArea>\\\n//                </g>\\\n//                <foreignObject width=\"200\" height=\"200\" class=\"logicPanelActualText\"\\\n//                requiredFeatures=\"http://www.w3.org/TR/SVG11/feature#Extensibility\">\\\n//                    <p xmlns=\"http://www.w3.org/1999/xhtml\">Text goes here</p>\\\n//                </foreignObject>'\n//        )\n//\n//\n//\n//\n//    }\n\n    function wrap(text, width) {\n\n        text.each(function() {\n            var text = d3.select(this),\n                words = text.text().split(/\\s+/).reverse(),\n                word,\n                line = [],\n                lineNumber = 0,\n                lineHeight = 1.1, // ems\n                y = text.attr(\"y\"),\n                dy = parseFloat(text.attr(\"dy\")),\n                tspan = text.text(null).append(\"tspan\").attr(\"x\", 0).attr(\"y\", y).attr(\"dy\", dy + \"em\");\n\n            while (word = words.pop()) {\n                line.push(word);\n                tspan.text(line.join(\" \"));\n                if (tspan.node().getComputedTextLength() > width) {\n                    line.pop();\n                    tspan.text(line.join(\" \"));\n                    line = [word];\n                    tspan = text.append(\"tspan\").attr(\"x\", 0).attr(\"y\", y).attr(\"dy\", ++lineNumber * lineHeight + dy + \"em\").text(word);\n                }\n            }\n        });\n    }\n\n\n    function renderSelectorTable(node, isExpanded, animated, rowIndex) {\n        //console.log(\"textexprssion\",getTextDescription(actualOrClause));\n\n//        logicPanelSelectionTable\n//        logicPanelSelectionHeader\n//\n\n        var nodeSelector = d3.select(node);\n        var noOfSets = Object.keys(node.__data__).length\n\n//        console.log(node.__data__);\n        var panelTableHeader = nodeSelector.select(\".logicPanelSelectionHeader\");\n        panelTableHeader.attr({\n            \"transform\":\"translate(\"+90+\",\"+0+\")\"\n        })\n        panelTableHeader.on({\n            click:function(d) {selectRow(rowIndex);}\n        })\n        var infoBarGroup = panelTableHeader.selectAll(\".logicPanelHeaderBarGroup\").data(function(){\n            var countRation =0;\n            var count =0;\n            getSubsetsForMaskList(subsets,[logicExpression.getListOfValues()[rowIndex]], function(d){\n//                console.log(d);\n                countRation+= d.dataRatio;\n                count+= d.items.length;\n            })\n\n        //    console.log(countRation,logicExpression.getListOfValues()[rowIndex] );\n            return [{countRatio:countRation,count:count}]; ///subsets.length\n        })\n            infoBarGroup.enter().append(\"g\").attr({\n                class:\"logicPanelHeaderBarGroup\"\n            })\n\n        var infoBar =  infoBarGroup.selectAll(\".logicPanelHeaderBar\").data(function(d){return [d]})\n\n        infoBar.enter().append(\"rect\").attr({\n            class:\"logicPanelHeaderBar\",\n            x:function(d){return (ctx.xStartSetSizes);},\n            y:2,\n            height:cellSize-4\n        }).style({\n                fill:logicColor\n            })\n\n        infoBar.transition().attr({\n            width:(function(d){return d.countRatio*ctx.subSetSizeScale.range()[1]})\n        })\n\n\n\n        infoBarGroup.selectAll(\".logicPanelHeaderBarLabel\").data(function(d){return [d]}).enter().append(\"text\").attr({\n            class:\"logicPanelHeaderBarLabel addButton\",\n            y:(cellSize-4),\n            x:function(d){return (ctx.xStartSetSizes) + d.countRatio*ctx.subSetSizeScale.range()[1]+5;}\n        })\n        .style({\n            \"text-anchor\":\"start\",\n            \"dominant-baseline\": \"auto\"\n        })\n        .text(function(d){return d.count;})\n\n        infoBarGroup.selectAll(\".logicPanelHeaderBarLabel\").transition().attr({\n            x:function(d){return (ctx.xStartSetSizes) + d.countRatio*ctx.subSetSizeScale.range()[1]+5;}\n        })\n            .text(function(d){return d.count;})\n\n\n\n        var headerCircles = panelTableHeader\n            .selectAll(\".logicPanelHeaderCircle\")\n            .data(function(d){return Object.keys(d).map(function(dd){\n                        return {subsetID:dd, state: d[dd].state}\n                    })})\n         headerCircles.enter().append(\"circle\").attr({\n                class:\"logicPanelHeaderCircle\",\n                cx:function(d,i){return (i*cellWidth)+cellWidth/2}, // TODO: add 90 as params!!\n                cy:function(d,i){return cellSize/2},\n                r: cellSize/2-3\n            })\n         headerCircles.style({\n//                stroke:grays[1],\n                fill:function(d){\n                    switch(d.state)\n                    {\n                        case me.logicState.NOT:\n                            return grays[0]\n                            break;\n                        case me.logicState.MUST:\n                            return grays[1]\n                            break;\n                        default: // me.logicState.DONTCARE\n                            return \"url(#DontCarePattern)\"\n                    }},\n                stroke:grays[1]//function(){if (isExpanded) return logicColor; else return grays[1];}\n            })\n\n\n    if (isExpanded){\n        var textDescriptionPanel = nodeSelector.selectAll(\".logicPanelActualText\").data(function(d){\n            return [me.getTextDescription(actualOrClause)]\n        });\n        textDescriptionPanel.enter().append(\"text\").attr({\n            class:\"logicPanelActualText addButton\",\n            \"transform\":\"translate(\"+(noOfSets*cellWidth+5+90)+\",\"+0+\")\",\n            y:cellSize,\n            dy:1\n        }).style({\n                \"text-anchor\":\"start\",\n                \"dominant-baseline\": \"auto\"\n            });\n\n        textDescriptionPanel.text(function(d){return d}).call(wrap,width-((noOfSets*cellSize+5+90+100)));\n\n        var g= nodeSelector.select(\".logicPanelSelectionTable\");\n        var nodeData = g.node().__data__\n        var clausesList = Object.keys(nodeData).map(function(d){\n            return {subsetID:d, state:nodeData[d].state}\n        })\n\n\n\n\n//        console.log(\"clist:\",clausesList);\n        var matrix = Object.keys(me.logicState).map(function(d){\n            return {\n\n                state:me.logicState[d],\n                selectors:clausesList.map(function(dd){\n\n                    return{\n                        state:me.logicState[d],\n                        id:dd.subsetID,\n                        isSelected:function(){return (me.logicState[d]==dd.state)}\n                    }\n                })\n\n            }\n        })\n\n\n\n        var tableRows = g.selectAll(\".logicTableRow\").data(matrix)\n\n        var trEnter =tableRows.enter().append(\"g\").attr({\n            \"class\":\"logicTableRow\"\n        })\n        trEnter.append(\"text\").text(function(d,i){\n            switch(d.state)\n            {\n                case me.logicState.NOT:\n                    return \"not\";\n                    break;\n                case me.logicState.MUST:\n                    return \"must\";\n                    break;\n                default: // me.logicState.DONTCARE\n                    return \"maybe\"\n            }}).attr({\n                x:-4,\n                y:cellSize/2,\n                class:\"addButton\"\n            }).style({\n                    \"text-anchor\":\"end\"\n            }).on({\n                click:function(d){changeStateAll(actualOrClause, d.state)}\n\n            })\n\n        trEnter.each(function(d,i){\n            if (i==0)\n                    d3.select(this).append(\"rect\").attr({\n                        x: 0,\n                        y: -3,\n                        width: cellSize*(clausesList.length),\n                        height: 1\n\n                    })\n            })\n\n\n        tableRows.exit().remove();\n        tableRows.attr({\n            \"transform\":function(d,i){return \"translate(\"+(90)+\",\"+\n                ((animated)?(0.0*cellSize):((i+1.0)*cellSize +5))\n//                ((i+1.0)*cellSize +5)\n                +\")\"}\n//            ,opacity:0.0001\n\n        })\n\n\n\n        var circles = tableRows.selectAll(\"circle\").data(function(d){return d.selectors})\n        circles.enter()\n            .append(\"circle\").attr({\n            class:\"logicPanelCircle\",\n            cx:function(d,i){return (i+.5)*cellWidth}, // TODO: add 90 as params!!\n            cy: .5*cellSize,\n//                if (animated) return 0.5*cellSize;\n//                else return (i+1.5)*cellSize +5},\n            r: cellSize/2-2\n        })\n\n         circles.style({\n                fill:function(d){\n                    switch(d.state)\n                    {\n                        case me.logicState.NOT:\n                            return grays[0]\n                            break;\n                        case me.logicState.MUST:\n                            return grays[1]\n                            break;\n                        default: // me.logicState.DONTCARE\n                            return \"url(#DontCarePattern)\"\n                    }},\n                stroke:function(d){\n                    if (d.isSelected()) return logicColor;\n                    else return grays[1];\n                }\n\n         })  .on({\n                 \"click\":function(d){changeState(actualOrClause, d.id, d.state)}\n             })\n\n\n           if (animated){\n               tableRows.transition().attr({\n                   \"transform\":function(d,i){return \"translate(\"+(90)+\",\"+\n                       ((i+1.0)*cellSize +5)\n                       +\")\"}\n               })\n           }\n\n\n//          .style({\n//                \"stroke-width\":2,\n//                fill:\"red\"\n//            })\n\n//        columns.transition().delay(50).attr({\n//            opacity:1\n//        })\n\n\n        }else{\n            d3.select(node).select(\".logicPanelSelectionTable\").selectAll(\".logicTableRow\").remove();\n            d3.select(node).select(\".logicPanelActualText\").remove();\n        }\n\n    }\n\n    function submitExpression() {\n        logicExpression.groupName = actualGroupLabel;\n\n        stateObject.logicGroups.push(logicExpression);\n        stateObject.logicGroupChanged=true;\n        stateObject.forceUpdate= true;\n        if (callAfterSubmit!=null)\n            callAfterSubmit.forEach(function(d){\n                d();\n            })\n\n       // console.log(logicExpression);\n//        console.log(logicExpression.getListOfValues())\n        destroyPanel();\n    }\n\n    function changeGroupLabel() {\n//        console.log(\"enter\");\n        var label = prompt(\"Group label:\",actualGroupLabel);\n        if (label !=null){\n            actualGroupLabel = label\n            panel.select(\"#fakeGroup\").select(\".groupLabel\").text(actualGroupLabel);\n        }\n\n    }\n\n    var renderActualPanel= function(){\n        cellSize = ctx.cellDistance\n\n        defineDontCarePattern(panel,cellSize,grays);\n\n        if (isNewPanel){\n            var fakeGroup = panel.append(\"g\").attr({id:\"fakeGroup\"})\n            fakeGroup.append(\"rect\").attr({\n                x:0,\n                y:0,\n                width:width,\n                height:cellSize,\n                class:\"groupBackGround\"\n            })\n            var labelText = fakeGroup.append(\"text\")\n            labelText.append(\"tspan\").attr({\n                x:12,\n                y:cellSize-3,\n                class:\"groupLabel\"\n            }).text(actualGroupLabel)\n\n\n            fakeGroup.append(\"text\").text(\"\\uf057\").attr({\n                id:\"logicPanelCancelText\",\n                class:\"groupDeleteIcon\",\n                \"transform\": \"translate(\" + (ctx.xStartSetSizes +ctx.leftOffset- 12) + \",\" + (ctx.cellSize / 2 + 4) + \")\" //TODO: needs context\n            }).style({\n                  \"fill\": \"#f46d43\"\n                })\n                .on({\n                    \"click\":function(){destroyPanel();}\n                })\n\n            labelText.append(\"tspan\").text(\" \\uf040\").attr({\n                id:\"logicPanelLabelChangeText\",\n                class:\"logicButton filter-button\"\n            }).style({\n                    \"font-size\":\"9pt\",\n                    \"dominant-baseline\":\"auto\"\n                })\n                .on({\n                    \"click\":function(){changeGroupLabel();}\n                })\n        }\n\n\n        // calculate y positions\n        var yCummulate =cellSize;\n        var yOffsets = logicExpression.orClauses.map(function(d,i){\n                var returnValue = yCummulate;\n                yCummulate+=(i==actualOrClause)?uncollapseHeight:collapseHeight;\n                return returnValue;\n        })\n\n        var logicPanelRows = panel.selectAll(\".logicPanelRow\").data(logicExpression.orClauses)\n\n        // the newly appended row is allways uncollapsed !!\n        var logicPanelRowEnter = logicPanelRows.enter().append(\"g\").attr({\n            class:\"logicPanelRow\",\n            \"transform\":function(d,i){\n                return \"translate(\"+0+\",\"+yOffsets[i]+\")\"\n            }\n        }).style(\"opacity\",0.000001)\n\n        // add row buttons\n        logicPanelRowEnter.append(\"text\").text(\"V\")\n            .attr(\"class\",\"logicButton logicPanelSelect \")\n            .style(\"text-anchor\",\"start\")\n            .on(\"click\", function(d,i){selectRow(i)});\n        logicPanelRowEnter.append(\"text\").text(\"\\uf057\")\n            .attr(\"class\",\"logicButton logicPanelRemove\")\n            .style(\"text-anchor\",\"start\")\n            .on(\"click\", function(d,i){removeRow(i)});\n\n\n\n\n\n\n\n        logicPanelRowEnter.append(\"rect\").attr({\n            class:\"logicPanelRect\",\n            width:width,\n            height:function(d,i){\n                return uncollapseHeight\n            }\n            }).style({\n                fill:\"none\",\n                stroke:\"lightgray\"\n            })\n        logicPanelRowEnter.append(\"g\").attr(\"class\",\"logicPanelSelectionTable\")\n        logicPanelRowEnter.append(\"g\").attr(\"class\",\"logicPanelSelectionHeader\")\n\n\n        logicPanelRows.exit().remove();\n\n        logicPanelRows.transition().attr({\n            \"transform\":function(d,i){\n                return \"translate(\"+0+\",\"+(yOffsets[i])+\")\"\n            },\n            height:function(d,i){\n                return (i==actualOrClause)?uncollapseHeight:collapseHeight\n            }\n        }).style(\"opacity\",1);\n\n        logicPanelRows.select(\".logicPanelSelect\").transition().attr({\n            x:10,\n            y: function(d,i){\n//                if (actualOrClause==i) return uncollapseHeight/2;\n//                else\n                    return collapseHeight/2;\n            }\n        }).text(function(d,i){\n                if (actualOrClause==i) return \"^\";\n                else return \"\";\n            })\n\n        logicPanelRows.select(\".logicPanelRemove\").transition().attr({\n            x:ctx.leftOffset-14,\n            y: function(d,i){\n//                if (actualOrClause==i) return uncollapseHeight/2;\n//                else\n                    return collapseHeight/2;\n            }\n        })\n\n        logicPanelRows.select(\".logicPanelRect\").transition().attr({\n                height:function(d,i){\n                    return (i==actualOrClause)?uncollapseHeight:collapseHeight}\n        })\n\n\n        logicPanelRows.each(function(d,i){\n            renderSelectorTable(this, i==actualOrClause, true, i);\n        })\n\n\n        var endOfPanel = yCummulate+10\n        if (isNewPanel){\n            var buttonGroup =  panel.append(\"g\").attr({\n                id:\"logicPanelButtons\"\n            }).attr({\n                    \"transform\":\"translate(\"+0+\",\"+endOfPanel+\")\"\n                })\n\n            buttonGroup.append(\"text\").text(\"\\uf067\").attr({\n                id:\"logicPanelAddText\",\n                class:\"logicButton\",\n                x:25\n//                \"transform\":\"translate(\"+0+\",\"+endOfPanel+\")\"\n            }).style({\n//                    \"text-anchor\":\"start\"\n                })\n                .on({\n                    \"click\":function(){addOrClause();}\n                })\n\n            buttonGroup.append(\"text\").text(\"\\uf00c\").attr({\n                id:\"logicPanelSubmitText\",\n                class:\"logicButton\",\n                x:70\n//                \"transform\":\"translate(\"+35+\",\"+endOfPanel+\")\"\n            }).style({\n                   \"fill\":logicColor\n                })\n                .on({\n                    \"click\":function(){submitExpression();}\n                })\n\n\n\n        }else{\n            panel.select(\"#logicPanelButtons\").transition().attr({\n                \"transform\":\"translate(\"+0+\",\"+endOfPanel+\")\"\n            })\n        }\n\n        isNewPanel=false;\n\n\n\n\n//\n//        // add uncollapsed panel\n//        panel.append(\"rect\").attr({\n//            class:\"menuPlaceholder menuPlaceholderRect\",\n//            width:width,\n//            height:uncollapseHeight\n//        })\n//            .style({\n//                fill:\"none\",\n//                stroke: grays[1]\n//            })\n//\n        belowVis.transition().attr({\n            \"transform\":\"translate(\"+params.leftAlignment+\",\"+(endOfPanel+15)+\")\"\n        })\n\n//        belowVis.transition().attr({\n//            \"y\":+(endOfPanel+belowVisRestoreTranslate+15)\n//        })\n\n\n\n\n\n\n    }\n\n    var destroyPanel = function(){\n        panel.selectAll(\".logicPanelRow\").remove();\n        panel.select(\"#logicPanelButtons\").remove();\n        panel.select(\"#fakeGroup\").remove();\n\n\n        belowVis.transition().attr({\n            \"transform\":\"translate(\"+params.leftAlignment+\",\"+0+\")\"\n        })\n//        belowVis.transition().attr({\n//            \"y\":belowVisRestoreTranslate\n//        })\n        addLogicButton.attr({\n            \"opacity\":1\n        })\n        initLogicExpression();\n    }\n\n\n    init();\n\n\n}\n"

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(59))

/***/ }),
/* 59 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Created by hen on 3/18/14.\n */\n\nfunction BrushableScale(ctx, svg, width, updateFunctionNameInCtx, redrawFunctionNameInCtx, scaleNameInCtx, params){\n\n\n\n//    var svg = d3.select(\"#vis\").append(\"svg\").attr({\n//        width:800,\n//        height:800\n//    })\n\n    var offsetX=0,\n        offsetY=0;\n\n    var distanceBetweenAxis = 25; // distance between two scales\n    var distanceBetweenUpperAndLower = 20 // should be fix !!\n//        height=20;\n\n\n    var width = width;\n\n    var xScale = d3.scale.pow().exponent(2).domain([1,width]).range([0, width])\n    var xOverViewAxisUpper = d3.svg.axis().scale(xScale);\n    var xOverViewAxisLower = d3.svg.axis().scale(xScale).orient(\"top\").tickFormat(function(d){return \"\"});\n\n\n    var xDetailScale = d3.scale.linear().domain([0,width]).range([0,width]).clamp(true)\n    var xDetailAxisUpper = d3.svg.axis().scale(xDetailScale).ticks(5);\n    var xDetailAxisLower = d3.svg.axis().scale(xDetailScale).orient(\"top\").tickFormat(function(d){return \"\"}).ticks(5);\n\n    var param = param\n\n    var columnLabel =\"ABC\";\n\n    var maxValue = 100;\n\n    var labels=[\n        {name: \"largest intersection\",id:\"I\", value:100 },\n        {name: \"largest group\",id:\"G\", value:200 },\n        {name: \"largest set\",id:\"S\", value:300 },\n        {name: \"all items\",id:\"A\", value:400 }\n    ]\n\n\n    var actionsTriggeredByLabelClick=params.actionsTrioggeredByLabelClick;\n\n\n    var connectionAreaData =[\n        [0,-distanceBetweenAxis],\n        [100,-distanceBetweenAxis],\n        [width,0]\n    ]\n\n\n    // add axis\n    svg.append(\"g\").attr({\n        \"class\":\"x overviewAxisUpper axis\",\n        \"transform\":\"translate(\"+offsetX+\",\"+offsetY+\")\"\n    }).call(xOverViewAxisUpper)\n\n\n    svg.append(\"g\").attr({\n        \"class\":\"x overviewAxisLower axis\",\n        \"transform\":\"translate(\"+offsetX+\",\"+(offsetY+distanceBetweenUpperAndLower)+\")\"\n    }).call(xOverViewAxisLower)\n\n    svg.append(\"g\").attr({\n        \"class\":\"x detailAxisUpper axis\",\n        \"transform\":\"translate(\"+offsetX+\",\"+(offsetY+distanceBetweenAxis+distanceBetweenUpperAndLower)+\")\"\n    }).call(xDetailAxisUpper)\n\n    svg.append(\"g\").attr({\n        \"class\":\"x detailAxisLower axis\",\n        \"transform\":\"translate(\"+offsetX+\",\"+(offsetY+distanceBetweenAxis+2*distanceBetweenUpperAndLower)+\")\"\n    }).call(xDetailAxisLower)\n\n//    svg.append(\"path\").attr({\n//        class:\"connectionArea\",\n//        \"transform\":\"translate(\"+offsetX+\",\"+offsetY+\")\"\n//    })\n\n\n    var sliders;\n    var overViewBrushDef;\n    var overviewBrush;\n    var redrawFunction = ctx[redrawFunctionNameInCtx];\n\n\n    // brushed function\n    var brushed = function(){\n        var endRange = overViewBrushDef.extent()[1];\n        if (endRange<5){\n            endRange =5;\n            overViewBrushDef.extent([0,5]);\n\n        }\n\n\n        svg.select(\".drawBrush\").attr({\n            width:xScale(endRange)\n        });\n\n        xDetailScale.domain([0,endRange]);\n        xDetailAxisUpper.scale(xDetailScale);\n        xDetailAxisLower.scale(xDetailScale);\n\n        svg.selectAll(\".detailAxisUpper\").call(xDetailAxisUpper);\n        svg.selectAll(\".detailAxisLower\").call(xDetailAxisLower);\n\n        connectionAreaData[1][0]= xScale(endRange);\n        updateConnectionArea()\n        if (redrawFunction!=null) redrawFunction();\n        ctx[scaleNameInCtx] = xDetailScale;\n    };\n\n    var setBrush= function(size){\n//        var sizeB =xScale(size);\n        overViewBrushDef.extent([0,size]);\n//        overviewBrush.select(\".e\").attr({\n//            \"transform\":\"translate(\"+xScale(size)+\",\"+0+\")\"\n//        })\n        overviewBrush.call(overViewBrushDef)\n        brushed();\n    }\n\n\n    function updateColumnLabel() {\n        svg.select(\".columnLabelGroup\").select(\"rect\").attr({\n            width:width\n        })\n\n        svg.select(\".columnLabelGroup\").select(\"text\").attr({\n            x:width/2\n        })\n\n    }\n\n    var update = function(params){\n\n        if (params.maxValue !=null) maxValue= params.maxValue;\n        if (params.labels !=null) labels = params.labels;\n        if (params.width != null) width = params.width;\n\n        updateScales();\n        updateSliderLabels();\n        updateColumnLabel();\n    }\n\n    function init(){\n        if (params.columnLabel != null) columnLabel = params.columnLabel;\n\n        // define slider\n        overViewBrushDef = d3.svg.brush()\n            .x(xScale)\n            .extent([0, 100])\n            .on(\"brush\", brushed)\n            .on(\"brushstart\", function(){\n                svg.selectAll(\".columnLabelGroup\").transition().duration(100).style({\n                    opacity:0\n                })\n                svg.selectAll(\".connectionArea\").transition().duration(100).style({\n                    opacity:.2\n                })\n\n            })\n            .on(\"brushend\", function(){\n                svg.selectAll(\".columnLabelGroup\").transition().duration(500).style({\n                    opacity:1\n                })\n                svg.selectAll(\".connectionArea\").transition().duration(500).style({\n                    opacity:.00001\n                })\n            });\n\n        sliders = svg.append(\"g\").attr({\n            class: \"sliderGroup\",\n            \"transform\": \"translate(\" + offsetX + \",\" + (offsetY) + \")\"\n        });\n\n        sliders.append(\"path\").attr({\n            class:\"connectionArea\"\n        }).style({\n                opacity:.00001\n            })\n\n        var labelHeight = 20;\n\n        var columnLabelGroup = svg.append(\"g\").attr({\n            class:\"columnLabelGroup\",\n            \"transform\":\"translate(\"+(0)+\",\"+(distanceBetweenUpperAndLower+(distanceBetweenAxis-labelHeight)/2)+\")\" //Math.floor\n        })\n\n        columnLabelGroup.append(\"rect\").attr({\n            class:\"labelBackground\",\n            x:0,\n            y:0,\n            width:width,\n            height:labelHeight// TODO magic number\n        }).on({\n                \"click\": function(){ actionsTriggeredByLabelClick.forEach(function(d){d();})}\n            })\n\n        columnLabelGroup.append(\"text\").attr({\n            class:\"columnLabel\",\n            \"pointer-events\":\"none\",\n            x:width/2,\n            y:labelHeight/2\n        })\n//            .style({\n//                \"font-size\":\"1em\"\n//            })\n            .text(columnLabel);\n\n\n        sliders.append(\"rect\").attr({\n            class:\"drawBrush\",\n            x:0,\n            y:0,\n            height:distanceBetweenUpperAndLower,\n            width:overViewBrushDef.extent()[1]\n        })\n\n        overviewBrush = sliders.append(\"g\").attr({\n            class:\"slider\"\n        }).call(overViewBrushDef)\n\n        overviewBrush.selectAll(\".w, .extent,  .background\").remove();\n\n        overviewBrush.selectAll(\"rect\").attr({\n            height:50,\n            width:20\n        })\n        overviewBrush.selectAll(\".e\")\n            .append(\"rect\")\n            .attr({\n                \"class\":\"handle\"\n            })\n        overviewBrush.selectAll(\"rect\").attr({\n            transform:\"translate(0,\"+(distanceBetweenUpperAndLower/2)+\")rotate(45)\",\n            x:-5,\n            y:-5,\n            height:10,\n            width:10\n        })\n\n        sliders.append(\"g\").attr({\n            class:\"labels\"\n        })\n\n    }\n\n    function updateScales(){\n\n        var brushedValue = d3.min([overViewBrushDef.extent()[1], maxValue]);\n        var optimalExponent = getOptimalExponent(maxValue,width);\n        xScale.domain([0,maxValue]).range([0, width]).exponent(optimalExponent);\n\n        // Heavy label stuff\n        var formatFunction = null;\n        var tickValues = xScale.ticks(10);\n        tickValues.push(maxValue);\n        var tickValuesReverse = tickValues.reverse();\n        var drawLabels = {};\n\n        var numberWidth = 6/2;// TODO magic Number 6\n        var maxSpace = width-maxValue.toString(10).length* numberWidth;\n\n        drawLabels[maxValue]=true;\n        tickValuesReverse.forEach(function(label){\n\n            if (xScale(label)+label.toString(10).length*numberWidth<maxSpace){\n                maxSpace = xScale(label)-label.toString(10).length*numberWidth;\n                drawLabels[label] = true;\n            }\n        })\n\n        formatFunction = function(d,i){return (d in drawLabels)?d:\"\";}\n        // kill last regular tick if too close to maxValue\n//        if (xScale(tickValuesReverse[0])<  width-maxValue.toString(10).length* numberWidth){\n//            tickValues.slice()\n//        }\n\n\n\n\n//        if (optimalExponent>.8){\n//            tickValues = xScale.ticks(6);\n//            formatFunction = function(d,i){return d;}\n//             //[0,Math.floor(maxValue/3),Math.floor(maxValue*2/3),maxValue]\n//        }else{\n//            tickValues = xScale.ticks(8);\n//            formatFunction = function(d,i){return (i%2==0 || i<4 || i==(tickValues.length-1))?d:\"\";}\n//        }\n//        tickValues.pop();\n        tickValues.push(maxValue);\n\n\n        xOverViewAxisUpper.scale(xScale).tickValues(tickValues).tickFormat(formatFunction);\n        xOverViewAxisLower.scale(xScale).tickValues(tickValues);\n\n        xDetailScale.range([0,width])\n        xDetailAxisUpper.scale(xDetailScale);\n        xDetailAxisLower.scale(xDetailScale);\n        connectionAreaData[2] =  [width,0];\n\n        svg.select(\".x.overviewAxisUpper.axis\").call(xOverViewAxisUpper)\n        svg.select(\".x.overviewAxisLower.axis\").call(xOverViewAxisLower)\n        svg.select(\".x.detailAxisUpper.axis\").call(xDetailAxisUpper)\n        svg.select(\".x.detailAxisLower.axis\").call(xDetailAxisLower)\n\n        // do NOT redraw !\n        overViewBrushDef.x(xScale)\n        var saveRedraw = redrawFunction;\n        redrawFunction = null;\n        setBrush(brushedValue);\n        redrawFunction = saveRedraw;\n\n    }\n\n    function updateSliderLabels(){\n\n\n        // slider labels\n        var sliderLabels = sliders.select(\".labels\").selectAll(\".sliderLabel\").data(labels, function(d){return d.name})\n        sliderLabels.exit().remove();\n        var sliderLabelsEnter = sliderLabels.enter().append(\"g\").attr({\n            class:\"sliderLabel\"\n        });\n\n        sliderLabelsEnter.append(\"rect\").attr({\n            x:-5,\n            y:0,\n            width:10,\n            height:15\n        })\n\n            .append(\"svg:title\").text( function(d){return d.name})\n\n        sliderLabelsEnter.append(\"line\").attr({\n            x1:0,\n            x2:0,\n            y1:15,\n            y2:20\n        })\n        sliderLabelsEnter.append(\"text\").text(function(d){return d.id}).attr({\n            dy:\"1em\",\n            \"pointer-events\":\"none\"\n        })\n\n        sliderLabels.attr({\n            \"transform\":function(d){return \"translate(\"+xScale(d.value)+\",\"+(-20)+\")\"}\n        }).on({\n                \"click\":function(d){setBrush(d.value);}\n            })\n\n    }\n\n\n    function getOptimalExponent(maxValue, width){\n\n        if (maxValue<=width) return 1;\n        else{\n            // ensure that value 5 has at least 5 pixel\n            var deltaValue = 5;\n            var deltaPixel = 5;\n\n\n            var optimalExponent = Math.log(deltaPixel/width)/Math.log(deltaValue/maxValue);\n\n            return optimalExponent;\n\n        }\n\n\n\n\n    }\n\n\n    function updateConnectionArea(){\n        var cAreaNode = svg.selectAll(\".connectionArea\").data([connectionAreaData])\n        cAreaNode.exit().remove();\n        cAreaNode.enter().append(\"path\")\n            .attr({\n                class:\"connectionArea\",\n                 \"transform\":\"translate(\"+offsetX+\",\"+(offsetY+distanceBetweenUpperAndLower+distanceBetweenAxis)+\")\"\n\n            })\n        cAreaNode.attr({\n            \"transform\":\"translate(\"+offsetX+\",\"+(offsetY+distanceBetweenUpperAndLower+distanceBetweenAxis)+\")\",\n            d:d3.svg.area()\n        })\n\n    }\n\n\n    init();\n\n    updateSliderLabels();\n    updateConnectionArea();\n//    updateScales();\n\n    ctx[updateFunctionNameInCtx]=function(d,params){update(params);};\n\n}\n"

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(61))

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Created by hen on 3/24/14.\n */\n\n\nfunction StatisticGraphs(attribute){\n    this.statistics = {};\n    this.attribute = attribute\n\n    this.scale = d3.scale.linear().domain([0,1]).rangeRound([0,1]);\n    this.axis = d3.svg.axis().scale(this.scale).orient(\"top\");\n    if (attribute.format && attribute.format.indexOf(\"date\") >= 0) {\n      formatParse = d3.time.format(attribute.format.substring('date:'.length)).parse\n      format = d3.time.format(\"%Y-%m-%d\")\n      this.axis = this.axis.tickFormat(function(d){\n        var dStr = d + '';\n        if (/^\\d{8}$/.test(dStr)) {\n          return format(formatParse(d + ''))\n        } else {\n          return d;\n        }\n      })\n    }\n\n\n    // expects a list of data containing key and value attributes\n    // creates an internal map with statistics\n\n\n\n}\n\nStatisticGraphs.prototype.updateStatistics= function(subsetData, subsetIDselector, itemIDselector, itemData, attributeIDSelector,attributeValueSelector, attributeID ){\n\n    var min = undefined;\n    var max = undefined;\n\n    var collector= {}\n\n    subsetData.forEach(function(subset){\n\n        var attributeColumn = {}\n        itemData.forEach(function(d){\n            if (d[attributeIDSelector]== attributeID) attributeColumn =d[attributeValueSelector];\n        })\n\n//        console.log(\"attr\",attributeColumn);\n\n        var itemIDSelectors = itemIDselector.split(\".\")\n\n        var actualSubset = subset;\n        itemIDSelectors.forEach((function(selector){\n            actualSubset = actualSubset[selector];\n        }))\n//        console.log(actualSubset);\n\n        var itemList = actualSubset.map(function(itemID){\n            return +attributeColumn[itemID]\n        })\n\n//        console.log(itemList);\n\n        var summaryStatistics ={\n            min:0,\n            max:0,\n            median:0,\n            lowerQuartile:0,\n            upperQuartile:0\n\n        }\n        itemList.sort(d3.ascending);\n\n\n        if (itemList.length!=0){\n            var extent = d3.extent(itemList)\n            summaryStatistics.min = extent[0];\n            summaryStatistics.max = extent[1];\n\n            summaryStatistics.median =d3.median(itemList);\n            summaryStatistics.lowerQuartile =d3.quantile(itemList,0.25);\n            summaryStatistics.upperQuartile =d3.quantile(itemList, 0.75);\n            //.. see D3\n\n            summaryStatistics.numberElements = itemList.length;\n\n\n            if (min==undefined || min>summaryStatistics.min){\n                min = summaryStatistics.min;\n            }\n            if (max==undefined || max<summaryStatistics.max){\n                max = summaryStatistics.max;\n            }\n\n\n        }\n\n\n\n\n        collector[subset[subsetIDselector]] = summaryStatistics;\n\n    })\n\n    this.statistics=collector;\n    this.scale.domain([min,max]);\n    this.axis.scale(this.scale)\n\n}\n\nStatisticGraphs.prototype.renderAxis = function(g,x,y,w){\n\n    this.scale.rangeRound([0,w]);\n    this.axis.scale(this.scale).ticks(Math.ceil(w/50)); //Math.ceil(w/50)\n\n    var detailStatAxisVis = g.selectAll(\".axis\").data([\"summary\"])\n    detailStatAxisVis.enter().append(\"g\").attr({\n        class:\"axis\",\n        \"transform\":\"translate(\"+x+\",\"+y+\")\"\n    }).call(this.axis)\n\n    detailStatAxisVis.exit().remove();\n    detailStatAxisVis.transition().call(this.axis);\n\n}\n\n\nStatisticGraphs.prototype.renderBoxPlot = function(id, g, x,y,w,h,classID){\n    var actualStat = this.statistics[id];\n    var diffY=2;\n\n\n    if (actualStat!=null){\n        var dS = g.selectAll(\".\"+classID).data([actualStat])\n        dS.exit().remove();\n\n\n        var dSEnter = dS.enter().append(\"g\").attr({\n            class:\"\"+classID\n        })\n        dSEnter.append(\"line\").attr({\n            class:\"boxPlot centralLine\"\n        })\n        dSEnter.append(\"line\").attr({\n            class:\"boxPlot minLine\"\n        })\n        dSEnter.append(\"line\").attr({\n            class:\"boxPlot maxLine\"\n        })\n        dSEnter.append(\"rect\").attr({\n            class:\"boxPlot quartile\"\n        }).append(\"title\").text(function(d){\n          return \"|\"+ d.min+\" --[\"+ d.lowerQuartile+\" |\"+ d.median+\"| \"+ d.upperQuartile+\"]-- \"+ d.max+\"|\"\n        })\n\n        dSEnter.append(\"line\").attr({\n            class:\"boxPlot medianLine\"\n        })\n\n\n        var localScale = this.scale\n\n        dS.select(\"rect\").transition().attr({\n            x:function(d){\n                return x+localScale(d.lowerQuartile)\n            },\n            y:(y+diffY),\n            width:function(d){\n                return localScale(d.upperQuartile)-localScale(d.lowerQuartile);\n            },\n            height:(h-(2*diffY))\n        }).attr({\n                opacity:function(d){return (d.numberElements>4)?1:0.0001}\n            })\n\n        dS.select(\".boxPlot.centralLine\").transition().attr({\n            x1:function(d){return x+localScale(d.min)},\n            x2:function(d){return x+localScale(d.max)},\n            y1:(y+h/2),\n            y2:(y+h/2)\n        })\n\n        dS.select(\".boxPlot.minLine\").transition().attr({\n            x1:function(d){return x+localScale(d.min)},\n            x2:function(d){return x+localScale(d.min)},\n            y1:(y+diffY),\n            y2:(y+h-diffY)\n        })\n\n        dS.select(\".boxPlot.maxLine\").transition().attr({\n            x1:function(d){return x+localScale(d.max)},\n            x2:function(d){return x+localScale(d.max)},\n            y1:(y+diffY),\n            y2:(y+h-diffY)\n        })\n\n        dS.select(\".boxPlot.medianLine\").transition().attr({\n            x1:function(d){return x+localScale(d.median)},\n            x2:function(d){return x+localScale(d.median)},\n            y1:y,\n            y2:y+h\n        }).attr({\n                opacity:function(d){return (d.numberElements==3 || d.numberElements >4)?1:0}\n            })\n\n\n\n    }else{\n        var nullVis =  g.selectAll(\".detailStatistics\").data(\"null\")\n        nullVis.exit().remove();\n        nullVis.enter().append(\"g\").attr({\n            class:\"detailStatistics\"\n        }).append(\"line\").attr({\n                x1:x+1,\n                x2:x+w-1,\n                y1:y+h/2,\n                y2:y+h/2\n            })\n\n        nullVis.select(\"line\").attr({\n            x1:x+1,\n            x2:x+w-1,\n            y1:y+h/2,\n            y2:y+h/2\n        })\n\n\n\n    }\n\n\n\n\n}\n\nwindow.StatisticGraphs = StatisticGraphs;\n"

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10)(__webpack_require__(63))

/***/ }),
/* 63 */
/***/ (function(module, exports) {

	module.exports = "/**\n * Created by alex,nils,romain,hen\n */\n\n\nvar ctx = {\n    majorPadding: 25,\n    minorPadding: 2,\n    cellDistance: 20,\n    textHeight: 90,\n    textSpacing: 3,\n\n    setSizeWidth: 700,\n    subSetSizeWidth: 200,\n    subSetSizeWidthMax: 200,\n\n    leftOffset: 90,\n    leftIndent: 10,\n    topOffset: 120,\n\n    /** The width from the start of the set vis to the right edge */\n\n    cellSizeShrink: 3,\n    maxLevels: 3,\n\n    expectedValueWidth: 150,\n    expectedValueWidthMax: 150,\n\n    labelTopPadding: 20+22,\n\n    paddingTop: 30,\n    paddingSide: 20,\n\n\n\n    truncateAfter: 20,\n    truncateGroupAfter: 30,\n\n    setCellDistance: 12,\n    setCellSize: 10,\n    cellWidth: 20,\n\n//         tableBodyHeight;\n//         h;\n//         rowScale;\n\n    svgHeight: 600, //height || 600;\n\n    grays: [ '#f0f0f0', '#636363'],\n\n    backHighlightColor: '#fed9a6',//'#fdbf6f'\n    rowTransitions: true,\n    barTransitions: true,\n\n    globalStatistics: [\n        {name: \"largest intersection\", id: \"I\", value: 100 },\n        {name: \"largest aggregate\", id: \"A\", value: 200 },\n        {name: \"largest set\", id: \"S\", value: 300 },\n        {name: \"universal set\", id: \"U\", value: 400 }\n    ],\n\n    nameForRelevance:\"Disproportionality\",\n\n    summaryStatisticVis : [{\n        attribute:\"\",\n        visObject:{}\n    }],// list of all statistic graphs TODO: make dynamic !!!\n    summaryStatisticsWidth:100,\n\n\n    // GROUPING OPTIONS\n    groupingOptions : {},\n\n    setSelection: {\n        paginationStart:0,\n        paginationEnd:10,\n        mode:\"none\", // special modes are: \"multiSel\", \"sortFilter\"\n        modeChange: false,// only true if mode changed and re-rendering\n        multiSelIn:d3.set(),\n        multiSelOut:d3.set(),\n        setOrder: 'size' // options: size or name\n    },\n\n    logicStates: {\n        NOT:0,\n        DONTCARE:2,\n        MUST:1\n    }\n\n\n};\n\n//bindEvents();\n\nfunction plot() {\n    ctx.plot();\n}\n\nfunction UpSet(datasets) {\n\n    // FAKE:\n//    var usedSets = [\"xx\",\"zzz\"];\n\n    bindEvents();\n\n    function setDynamicVisVariables() {\n\n        ctx.tableBodyHeight = renderRows.length * (ctx.cellDistance+4);\n//        ctx.h = ctx.tableBodyHeight + ctx.textHeight;\n\n        ctx.rowScale = d3.scale.ordinal().rangeRoundBands([ 0, ctx.tableBodyHeight], 0, 0);\n        ctx.rowScale.domain(renderRows.map(function (d) {\n            return d.id;\n        }));\n\n\n        // dynamic context variables\n        ctx.cellSize = ctx.cellDistance; // - minorPadding,\n\n        ctx.xStartSetSizes = ctx.cellWidth * usedSets.length + ctx.majorPadding;\n\n\n\n        ctx.xStartExpectedValues = ctx.xStartSetSizes + ctx.subSetSizeWidth + ctx.majorPadding;\n\n        ctx.setVisWidth = ctx.expectedValueWidth + ctx.subSetSizeWidth\n            + ctx.majorPadding + ctx.cellDistance + ctx.xStartSetSizes+ctx.summaryStatisticVis.length*(ctx.summaryStatisticsWidth+ctx.majorPadding);// TODO HACK !!!\n\n        ctx.w = ctx.cellWidth * usedSets.length + ctx.majorPadding + ctx.leftOffset\n            + ctx.subSetSizeWidth + ctx.expectedValueWidth + 50 +ctx.summaryStatisticVis.length*(ctx.summaryStatisticsWidth+ctx.majorPadding);\n        ctx.setMatrixHeight = ctx.setCellDistance + ctx.majorPadding;\n\n        ctx.svgHeight = /*renderRows.length * ctx.cellSize*/ctx.rowScale.rangeExtent()[1];// TODO: Duplicate to ctx.tableBodyHeight\n\n        ctx.intersectionClicked = function (d) {\n          if (d.data && d.data.type === 'SUBSET_TYPE') {\n            var selection = Selection.fromSubset(d.data);\n            selections.addSelection(selection, false);\n            selections.setActive(selection);\n          }\n        }\n\n\n        ctx.xStartStatisticColumns = ctx.xStartExpectedValues+ ctx.expectedValueWidth+ctx.majorPadding // TODO: HACK!!!\n\n\n        ctx.horizonBarGrays = d3.scale.linear().domain([0,1,2]).range([\"#bdbdbd\",\"#888888\",\"#252525\" ])\n\n    }\n\n    function calculateGlobalStatistics() {\n        var collector = {allItems: 1};\n        dataRows.forEach(function (d) {\n\n            var setSize = d.setSize;\n            var type = d.type;\n\n            var maxValue = collector[ type];\n            if (maxValue == null) {\n                collector[type] = setSize;\n            }\n            else if (maxValue < setSize) {\n                collector[type] = setSize;\n            }\n//            console.log(d.type);\n//            if (d.type === ROW_TYPE.SUBSET) {\n//                console.log(\"iS Before\", collector.allItems);\n//                collector.allItems += setSize;\n//                console.log(\"iS\", collector.allItems);\n//            }\n\n        })\n\n//        d3.max(usedSets, function(d){})\n\n//    console.log(usedSets);\n\n//        {name: \"largest intersection\",id:\"I\", value:100 },\n//        {name: \"largest group\",id:\"G\", value:200 },\n//        {name: \"largest set\",id:\"S\", value:300 },\n//        {name: \"all items\",id:\"A\", value:400 }\n\n        ctx.globalStatistics.forEach(function (d) {\n            switch (d.id) {\n                case \"I\":\n                    d.value = collector[ROW_TYPE.SUBSET];\n                    break;\n                case \"A\":\n                    d.value = collector[ROW_TYPE.GROUP];\n                    break;\n                case \"U\":\n                    d.value = allItems.length;\n                    break;\n                case \"S\":\n                    d.value = d3.max(usedSets, function (d) {\n                        return d.items.length\n                    })\n                    break;\n                default:\n                    break;\n            }\n\n        })\n\n    }\n\n    // All global variables and SVG elements\n    function init() {\n\n        setDynamicVisVariables();\n\n        // create SVG and VIS Element\n        d3.select('#bodyVis').select('svg').remove();\n        ctx.svgBody = d3.select('#bodyVis')\n//            .style('width', ctx.w + \"px\")\n            .append('svg')\n            .attr('width', ctx.w)\n            .attr('height', renderRows.length * ctx.cellDistance);\n\n//        ctx.vis = ctx.svgBody.append(\"g\").attr({\n//            class: \"svgRows\",\n//            \"transform\": \"translate(\" + ctx.leftOffset + \",\" + ctx.topOffset + \")\"\n//        });\n\n        // -- the background highlights\n        ctx.columnBackgroundNode = ctx.svgBody.append(\"g\").attr({\n            class: \"columnBackgroundsGroup\"\n\n        }).attr({\n           \"transform\":\"translate(\"+ctx.leftOffset+\",\"+0+\")\"\n        })\n\n        // Rows container for vertical panning\n        ctx.gRows = ctx.svgBody\n            .append('g')\n            .attr({\n                'class': 'gRows',\n                \"transform\":\"translate(\"+ctx.leftOffset+\",\"+0+\")\"\n            })\n\n        // tooltips on top !\n        ctx.toolTipLayer = ctx.svgBody.append(\"g\").attr({class:\"toolTipLayer\"});\n\n\n\n        d3.select(\"#headerVis\").select(\"svg\").remove();\n        ctx.svgHeader = d3.select(\"#headerVis\").append('svg')\n            .attr('width', ctx.w)\n            .attr('height', 65+ctx.textHeight);\n//            .style({\n//                \"top\":\"\",\n//                \"position\":\"relative\"\n//            });\n\n\n        //####################### LogicPanel ##################################################\n\n        ctx.logicPanelNode = ctx.svgBody.append(\"g\").attr({\n            class: \"logicPanel\",\n            \"transform\": \"translate(\" + 0 + \",\" + 0 + \")\"\n        })\n\n        // TODO: give only context\n        ctx.logicPanel = new LogicPanel(\n            {width: ctx.setVisWidth + ctx.leftOffset,\n                visElement: ctx.svgHeader,\n                panelElement: ctx.logicPanelNode,\n                cellSize: ctx.cellSize,\n                usedSets: usedSets,\n                grays: ctx.grays,\n                belowVis: ctx.gRows,\n                buttonX: 0,\n                buttonY: ctx.svgHeader.attr(\"height\")-20,\n                stateObject: UpSetState,\n                subsets: subSets,\n                callAfterSubmit: [updateState, updateStatistics, rowTransition],\n                leftAlignment:ctx.leftOffset,\n                ctx: ctx,\n                cellWidth: ctx.cellWidth\n\n            });\n//            {\n//                ctx:ctx\n//            }\n//        );\n\n\n\n\n        ctx.tableHeaderNode = ctx.svgHeader.append(\"g\").attr({\n            class: \"tableHeader\",\n            \"transform\":\"translate(\"+ctx.leftOffset+\",\"+(ctx.svgHeader.attr(\"height\")-ctx.textHeight)+\")\"\n        })\n\n//        ctx.tableHeaderNode.append(\"g\")\n\n//        ctx.vis.append\n//        ctx.brushedScale = new BrushableScale(ctx,)\n\n        // For horizon subset size\n        ctx.svgBody.append('defs')\n            .append('pattern')\n            .attr('id', 'diagonalHatch_0')\n            .attr('patternUnits', 'userSpaceOnUse')\n            .attr('width', 8)\n            .attr('height', 8)\n            .append('path')\n            .attr('d', 'M-2,2 l4,-4 M0,8 l8,-8 M6,10 l4,-4')\n            .attr('stroke', \"blue\")\n            .attr('stroke-width', 1);\n\n\n\n\n//        ctx.summaryStatisticVis[0].attribute = attributes.filter(function(d){\n//            return d.type==\"integer\" || d.type==\"float\"\n//        })[0].name\n//        ctx.summaryStatisticVis[0].visObject = new StatisticGraphs();\n\n//        updateStatistics();\n\n        dataSetChanged();\n\n        updateSetsLabels(ctx.tableHeaderNode);\n\n        updateHeaders();\n\n        plotSubSets();\n\n        initCallback = [dataSetChanged] //TODO: bad hack !!!\n\n        updateFrames($(window).height(), null);\n\n        updateFrames(null,$(\".ui-layout-center\").width());\n\n//        updateWidthHandle()\n    }\n\n//    // update svg size\n//    var updateSVG = function (width, height) {\n//        ctx.w = width;\n//        ctx.svgHeight = height;\n//\n//        ctx.svg\n//            .attr('width', ctx.w)\n//            .attr('height', ctx.svgHeight)\n//\n//    }\n\n\n    function dataSetChanged(){\n//        ctx.summaryStatisticVis[0].attribute = attributes.filter(function(d){\n//            return d.type==\"integer\" || d.type==\"float\"\n//        })[0].name\n\n        ctx.summaryStatisticVis=[];\n        attributes.filter(function(d){\n            return (d.type==\"integer\" || d.type==\"float\") && (d.name!=\"Set Count\") && (!d.hideStatics)\n        }).forEach(function(attribute,i){\n\n                ctx.summaryStatisticVis.push({\n                    attribute: attribute.name,\n                    visObject:new StatisticGraphs(attribute)\n                })\n//                ctx.summaryStatisticVis[i].attribute = name;\n            })\n\n\n\n\n        updateStatistics()\n        setDynamicVisVariables()\n\n        ctx.svgBody.attr({\n            width: (Math.max(ctx.w, 400))\n        })\n\n        updateHeaders();\n        plotSubSets();\n\n        if (usedSets.length > 1 || usedSets.length < 18) {\n            $(\"#venn-diagram-viewer\").fadeIn(500);\n            vennInstance.plot(subSets.filter(function(subSet){\n              return subSet.combinedSets.reduce(function(prev, current){\n                return prev + current;\n              }, 0) === 1;\n            }), usedSets.length);\n        } else  {\n            $(\"#venn-diagram-viewer\").fadeOut(500);\n        }\n\n    }\n\n    //####################### SETS ##################################################\n    function updateSetsLabels(tableHeaderNode) {\n\n        var setRowScale = d3.scale.ordinal().rangeRoundBands([0, usedSets.length * (ctx.cellWidth)], 0);\n        setRowScale.domain(usedSets.map(function (d) {\n            return d.id\n        }))\n\n        var setRows = tableHeaderNode.selectAll('.setRow')\n            .data(usedSets, function (d) {\n                return d.elementName\n            })\n\n        var setRowsEnter = setRows.enter()\n            .append('g').attr({\n                class: \"setRow\"\n            })\n\n        setRows.exit().remove();\n\n        var setRects = setRows.selectAll(\".sortBySet.connection.vertical\").data(function (d, i) {\n            return [d]\n        })\n        setRects.enter().append(\"rect\").attr({\n            class: \"sortBySet connection vertical\"\n        })\n        .on('mouseover', mouseoverColumn)\n        .on('mouseout', mouseoutColumn)\n\n        setRects.exit().remove();\n\n        setRects.attr({\n            transform: function (d, i) {\n                return 'skewX(45) translate(' + (- ctx.leftOffset) + ', 0)';\n            },\n            width: ctx.cellWidth,\n            height: ctx.textHeight - 2\n        })\n\n        var setRowsText = setRows.selectAll(\"text\").data(function (d) {\n            return [d]\n        })\n        setRowsText.enter().append(\"text\").text(\n            function (d) {\n\n              var str = d.elementName.substring(0, ctx.truncateAfter);\n              if(str.length<d.elementName.length)\n                str = str.trim() + \"...\";\n\n              return str;\n            }).attr({\n                class: 'setLabel sortBySet',\n                //  \"pointer-events\": \"none\",\n                id: function (d) {\n                    return d.elementName.substring(0, ctx.truncateAfter);\n                },\n                transform: function (d, i) {\n                    return 'translate(0,' + (ctx.textHeight - ctx.textSpacing - 2) + ')rotate(45)';\n                },\n                'text-anchor': 'end'\n            })\n            .style({\n                'cursor':'s-resize'\n            })\n            .on('mouseover', mouseoverColumn)\n            .on('mouseout', mouseoutColumn)\n            .append(\"svg:title\")\n            .text(function (d, i) {\n                return d.elementName;\n            })\n\n        setRowsText.attr({\n            class: function () {\n                if (ctx.cellWidth > 16) return 'setLabel'; else return 'setLabel small'\n            }\n\n        })\n\n        setRows.attr({transform: function (d, i) {\n\n            return 'translate(' + setRowScale(d.id) + ', 0)';\n            //  return 'translate(0, ' + ( cellDistance * (i)) + ')';\n        },\n            class: 'setRow'});\n\n\n        d3.selectAll('.sortBySet, .setRow .setLabel').on(\n            'click',\n            function (d) {\n                UpSetState.sorting = StateOpt.sortBySetItem;\n                UpSetState.grouping = undefined;\n                UpSetState.levelTwoGrouping = undefined;\n                UpSetState.forceUpdate = true;\n                updateState(d);\n                rowTransition();\n            }).style({\n                'cursor':'s-resize'\n            });\n\n\n    }\n\n\n    function updateStatistics(){\n        ctx.summaryStatisticVis.forEach(function(sumStat,i){\n            sumStat.visObject.updateStatistics(renderRows, \"id\", \"data.items\", attributes,\"name\",\"values\", sumStat.attribute)\n        });\n//        ctx.summaryStatisticVis[0].visObject.updateStatistics(subSets, \"id\", \"items\", attributes,\"name\",\"values\", ctx.summaryStatisticVis[0].attribute)\n    }\n\n\n\n    function addStatisticColumn(){\n        var allAttributes = attributes.filter(function(d){\n            return d.type==\"integer\" || d.type==\"float\"\n        })\n\n        allAttributes.unshift(ctx.nameForRelevance);\n        // find first not-used\n\n\n        var delList = allAttributes.map(function(d){return d})\n\n        ctx.summaryStatisticVis.forEach(function(stat){\n            delList.remove(stat.attribute);\n        })\n\n        //console.log(delList);\n\n\n    }\n\n\n    function updateHeaders() {\n        setDynamicVisVariables()\n        calculateGlobalStatistics();\n\n\n        // -- Create Table Header:\n        var tableHeaderGroup = ctx.tableHeaderNode.selectAll(\".tableHeaderGroup\").data([1]);\n        var tableHeaderGroupEnter = tableHeaderGroup.enter().append(\"g\").attr({class: \"tableHeaderGroup\"});\n\n\n\n        //------------ subSet value header -----------------------\n\n        tableHeaderGroupEnter.append('g').attr()\n            .attr({\n                id: \"subSetSizeAxis\",\n                class: 'axis',\n                \"transform\":\"translate(\"+0+\",\"+20+\")\"\n            }).each(function () {\n                ctx.brushableScaleSubsetUpdate = function () {\n\n                };\n                ctx.brushableScaleSubset = new BrushableScale(\n                    ctx,\n                    d3.select(this),\n                    ctx.subSetSizeWidth,\n                    \"brushableScaleSubsetUpdate\", \"plotTable\", \"subSetSizeScale\", {columnLabel:\"Cardinality\",\n                        actionsTrioggeredByLabelClick:[function(){\n                            UpSetState.sorting = StateOpt.sortBySubSetSize;\n                            UpSetState.grouping = undefined;\n                            UpSetState.levelTwoGrouping = undefined;\n                            UpSetState.forceUpdate = true;\n                            $('#noGrouping').prop('checked', true);\n                            $('#sortRelevanceMeasure').prop('checked', true);\n                            toggleGroupingL2(true);\n                            updateState();\n                            rowTransition();\n                        }]})\n            });\n\n        // *** update Part\n\n//        tableHeaderGroup.selectAll(\"#subSetSizeLabelRect\").attr({\n//            transform: 'translate(' + ctx.xStartSetSizes + ',' + (ctx.labelTopPadding) + ')',\n//            height: '20',\n//            width: ctx.subSetSizeWidth\n//        });\n//\n//        tableHeaderGroup.selectAll(\"#subSetSizeLabelText\").attr({\n//            transform: 'translate(' + (ctx.xStartSetSizes + ctx.subSetSizeWidth / 2) + ','\n//                + (ctx.labelTopPadding + 10) + ')'\n//        });\n\n        var maxValue = d3.max(ctx.globalStatistics, function (d) {\n            return d.value\n        });\n\n        tableHeaderGroup.selectAll(\"#subSetSizeAxis\").transition().attr({\n            transform: 'translate(' + ctx.xStartSetSizes + ',' + (ctx.textHeight - 70) + ')' // TODO magic number\n        }).call(ctx.brushableScaleSubsetUpdate,\n            {\n                maxValue: maxValue,\n                labels: ctx.globalStatistics\n\n            })\n\n\n        // ------------ expected value header -----------------------\n\n        // *** init Part\n        tableHeaderGroupEnter.append('rect')\n            .attr({\n                id: \"expectedValueLabelRect\",\n                class: 'labelBackground expectedValueLabel sortRelevanceMeasureGlobal'\n            }).on(\n            'click',\n            function () {\n                UpSetState.sorting = StateOpt.sortByExpectedValue;\n                UpSetState.grouping = undefined;\n                UpSetState.levelTwoGrouping = undefined;\n                UpSetState.forceUpdate = true;\n                $('#noGrouping').prop('checked', true);\n                $('#sortRelevanceMeasure').prop('checked', true);\n                toggleGroupingL2(true);\n                updateState();\n                rowTransition();\n            });\n\n        tableHeaderGroupEnter.append('text').text('Deviation')\n            .attr({\n                id: \"expectedValueLabelText\",\n                class: 'columnLabel sortRelevanceMeasureGlobal',\n                \"pointer-events\": \"none\"\n            });\n\n        tableHeaderGroupEnter.append('g').attr()\n            .attr({\n                id: \"expectedValueAxis\",\n                class: 'axis'\n            });\n\n        // *** update Part\n        tableHeaderGroup.selectAll(\"#expectedValueLabelRect\").attr({\n            transform: 'translate(' + ctx.xStartExpectedValues + ',' + ( ctx.labelTopPadding) + ')',\n            height: '20',\n            width: ctx.expectedValueWidth\n        });\n\n        tableHeaderGroup.selectAll(\"#expectedValueLabelText\").attr({\n            transform: 'translate(' + (ctx.xStartExpectedValues + ctx.expectedValueWidth / 2) + ','\n                + ( ctx.labelTopPadding + 10) + ')'\n        });\n\n        // scale for the size of the plottingSets\n        var minDeviation = d3.min(dataRows, function (d) {\n            return d.disproportionality;\n        });\n        if (minDeviation > 0) {\n            minDeviation = 0;\n        }\n        var maxDeviation = d3.max(dataRows, function (d) {\n            return d.disproportionality;\n        });\n\n        var bound = d3.max([Math.abs(minDeviation), Math.abs(maxDeviation)]);\n        if (bound < 0.1) {\n            bound = 0.1;\n        }\n\n        ctx.expectedValueScale = d3.scale.linear().domain([-bound, bound]).nice().range([0, ctx.expectedValueWidth]);\n\n//        var formatPercent = d3.format(\".0 \");\n        var formatPercent = d3.format(\"%\");\n\n        var expectedValueAxis = d3.svg.axis().scale(ctx.expectedValueScale).orient('top').ticks(4).tickFormat(formatPercent);\n\n        tableHeaderGroup.select(\"#expectedValueAxis\").transition().attr({\n            transform: 'translate(' + ctx.xStartExpectedValues + ',' + (ctx.textHeight - 5) + ')'\n        }).call(expectedValueAxis);\n\n\n\n        // some statistics\n        var sumStatFO = tableHeaderGroup.selectAll(\".summaryStatisticsFO\").data(ctx.summaryStatisticVis, function(d,i){return d.attribute+i})\n\n        sumStatFO.exit().remove();\n        var sumStatFOHTML = sumStatFO.enter().\n            append(\"foreignObject\").attr({\n                class:\"summaryStatisticsFO\",\n                width:120,\n                height:30,\n                x:function(d,i){return ctx.xStartStatisticColumns+i*(ctx.summaryStatisticsWidth+ctx.majorPadding)},\n                y:ctx.labelTopPadding-5\n\n            }).append(\"xhtml:body\")//.attr(\"xmlns\",\"http://www.w3.org/1999/xhtml\")\n\n        sumStatFO.attr({\n            x:function(d,i){return ctx.xStartStatisticColumns+i*(ctx.summaryStatisticsWidth+ctx.majorPadding)}\n        })\n\n\n\n//        sumStatFO.append(\"h1\").text(\"Hal2\")\n//        sumStatFO.html(\"<h1>HALLO</h1>\")\n//\n        sumStatFOHTML.append(\"select\").attr({\n//            id:\"sumStatAttributeSelector\"\n                class:\"columnLabel\"\n        }).style({\n                width:ctx.summaryStatisticsWidth+\"px\",\n                \"background\":\"transparent\",\n                border: \"1px solid #ccc\",\n                \"-webkit-appearance\": \"none\",\n                \"padding\":\"5px\"\n\n            })\n        .on({\n            \"change\":function(d,i){\n\n                d.attribute = d3.event.target.value;\n                updateStatistics();\n                updateHeaders();\n                plotSubSets();\n\n            }\n        })\n\n\n        var attSel = sumStatFO.selectAll(\"select\")\n          .selectAll(\"option\").data(attributes.filter(function(d){return (d.type==\"integer\" || d.type==\"float\") && (d.name!=\"Set Count\") && (!d.hideStatics)}))\n\n\n\n\n        attSel.exit().remove();\n        attSel.enter().append(\"option\")\n        attSel.attr({\n            \"value\":function(d,i){\n                return d.name\n            },\n            \"selected\":function(d,i){\n                return (d.name == d3.select(this.parentNode).datum().attribute)?\"selected\":null;\n            }\n        }).text(function(d){return d.name})\n\n\n        var sumStatAxis = tableHeaderGroup.selectAll(\".summaryStatisticsAxis\").data(ctx.summaryStatisticVis,function(d,i){return d.attribute+i})\n        sumStatAxis.exit().remove();\n        sumStatAxis.enter().append(\"g\").attr({\n            class:\"summaryStatisticsAxis\"\n        })\n        sumStatAxis.attr({\n            \"transform\":function(d,i){return \"translate(\"+(ctx.xStartStatisticColumns+(i*(ctx.summaryStatisticsWidth+ctx.majorPadding)))+\",\"+(ctx.textHeight-5)+\")\"}\n        }).each(function(d,i){\n                d.visObject.renderAxis(d3.select(this),0,0,ctx.summaryStatisticsWidth);\n            })\n\n\n//        ctx.summaryStatisticVis.forEach(function(sumStat,i){\n//            sumStat.visObject.renderAxis(tableHeaderGroup,ctx.xStartStatisticColumns+(i*100),ctx.textHeight-5,95);\n//\n//        })\n\n        updateSetsLabels(ctx.tableHeaderNode)\n\n    }\n\n    function updateSubSetGroups() {\n\n      // ------------------- the rows -----------------------\n      var subSets = ctx.gRows.selectAll('.row')\n          .data(renderRows, function (d, i) {\n              return d.id;\n          });\n\n//        console.log(\"rr:\",renderRows);\n//        console.log(\"rr2:\",ctx.rowScale.domain());\n\n      var rowSubSets = subSets\n          .enter()\n          .append('g')\n          .attr({transform: function (d) {\n\n              if (d.data.type === ROW_TYPE.SUBSET || d.data.type === ROW_TYPE.GROUP) {\n                  return 'translate(0, ' + ctx.rowScale(d.id) + ')';\n              }else {\n                  var offset_y = ctx.textHeight;\n                  if (d.data.level == 2)\n                      offset_y += 10\n                  return 'translate(0, ' + offset_y + ')';\n              }\n          }, class: function (d) {\n              return 'row ' + d.data.type;\n          }\n          }).style(\"opacity\", function (d) {\n              if (d.data.type === ROW_TYPE.SUBSET || d.data.type === ROW_TYPE.GROUP)\n                  return ctx.gRows.selectAll('.row')[0].length == 0 ? 1 : 0;\n              else\n                  return ctx.gRows.selectAll('.row')[0].length ? 0 : 1;\n          })\n\n      // Anticipating future overlays\n      rowSubSets.append(\"g\").attr(\"class\", \"gBackgroundRect\")\n      rowSubSets.append(\"g\").attr(\"class\", \"gHorizon\")\n      rowSubSets.append(\"g\").attr(\"class\", \"gOverlays\")\n      rowSubSets.append(\"g\").attr(\"class\", \"gIndicators\")\n\n      subSets.exit().remove();\n\n      var subSetTransition = subSets\n      if (ctx.rowTransitions && usedSets.length<10)\n          subSetTransition = subSets\n              .transition().duration(function (d, i) {\n                  if (d.data.type === ROW_TYPE.SUBSET)\n                      return queryParameters['duration'];\n                  else\n                      return queryParameters['duration'];\n              })\n      subSetTransition.attr({transform: function (d) {\n        return 'translate(0, ' + ctx.rowScale(d.id) + ')';\n\n      }, class: function (d) {\n          return 'row ' + d.data.type;\n      }}).transition().duration(100).style(\"opacity\", 1);\n\n      return subSets;\n    }\n\n    function updateSubsetRows(subsetRows, setScale) {\n\n        var backgrounds = subsetRows.select(\".gBackgroundRect\").selectAll(\".backgroundRect\").data(function (d) {\n            return [d]\n        })\n        backgrounds.enter()\n            .append(\"rect\").attr({\n                class: \"backgroundRect\",\n                x: 0,\n                y: 0,\n                width: ctx.setVisWidth,\n                height: ctx.cellSize\n            })\n            .style({\n                \"fill-opacity\": 0.0001,\n                fill: ctx.backHighlightColor // for debugging\n            })\n            .on({\n                'mouseover': mouseoverRow,\n                'mouseout': mouseoutRow\n            })\n        backgrounds.exit().remove();\n        backgrounds.attr({\n            width: ctx.setVisWidth,\n            height: ctx.cellSize\n        })\n\n        var combinationGroups = subsetRows.selectAll('g.combination').data(function (d) {\n                // binding in an array of size one\n                return [d.data.combinedSets];\n            }\n        )\n\n        combinationGroups.enter()\n            .append('g')\n            .attr({class: 'combination'\n            })\n        combinationGroups.exit().remove();\n\n        var cells = combinationGroups.selectAll('.cell').data(function (d) {\n            return d.map(function (dd, i) {\n                return {data: usedSets[i], value: dd}\n            });\n        })\n        // ** init\n        cells.enter()\n            .append('circle')\n            .on({\n                'click': function (d) {\n\n                    /* click event for cells*/\n                },\n                'mouseover': function (d, i) {\n                    mouseoverCell(d3.select(this).node().parentNode.parentNode.__data__, i)\n                },\n                'mouseout': mouseoutCell\n            })\n        cells.exit().remove()\n\n        //** update\n        cells.attr('cx', function (d, i) {\n            return (ctx.cellWidth) * i + ctx.cellWidth / 2;\n        })\n            .attr({\n                r: ctx.cellSize / 2 - 1,\n                cy: ctx.cellSize / 2,\n                class: 'cell'\n            })\n            .style('fill', function (d) {\n                return setScale(d.value);\n\n            })\n\n        // add the connecting line for cells\n        var cellConnectors = combinationGroups.selectAll('.cellConnector').data(\n            function (d) {\n                // get maximum and minimum index of cells with value 1\n                var extent = d3.extent(\n                    d.map(function (dd, i) {\n                        if (dd == 1) return i; else return -1;\n                    })\n                        .filter(function (dd, i) {\n                            return dd >= 0;\n                        })\n                )\n\n                // dont do anything if there is only one (or none) cell\n                if (extent[0] == extent[1]) return [];\n                else return [extent];\n            }\n        );\n        //**init\n        cellConnectors.enter().append(\"line\").attr({\n            class: \"cellConnector\",\n            \"pointer-events\": \"none\"\n        })\n            .style({\n                \"stroke\": setScale(1),\n                \"stroke-width\": 3\n            });\n        cellConnectors.exit().remove();\n\n        //**update\n        cellConnectors.attr({\n            x1: function (d) {\n                return (ctx.cellWidth) * d[0] + ctx.cellWidth / 2;\n            },\n            x2: function (d) {\n                return (ctx.cellWidth) * d[1] + ctx.cellWidth / 2;\n            },\n            y1: ctx.cellSize / 2,\n            y2: ctx.cellSize / 2\n        })\n\n        /// --- the sizeBar\n\n/*\n         var sizeBars = subsetRows.selectAll(\".row-type-subset\").data(function (d) {\n         return [d]\n         })\n         sizeBars.enter()\n         .append('rect')\n         .attr(\"class\", 'subSetSize row-type-subset')\n         .attr({\n         transform: function (d) {\n         var y = 1;\n         return   'translate(' + ctx.xStartSetSizes + ', ' + y + ')'; // ' + (textHeight - 5) + ')'\n         },\n\n         width: function (d) {\n         return ctx.subSetSizeScale(d.data.setSize);\n         },\n         height: function (d) {\n         return ctx.cellSize - 2\n         }\n         })\n         .on('click', function (d) {\n         ctx.intersectionClicked(d);\n         })\n         .on('mouseover', mouseoverRow)\n         .on('mouseout', mouseoutRow)\n         sizeBars.exit().remove();\n\n\n         var sizeBarsChanges = sizeBars\n         if (ctx.barTransitions) sizeBarsChanges.transition()\n        sizeBarsChanges.attr({\n         //class: 'subSetSize',\n        transform: function (d) {\n          var y = 1;\n         return   'translate(' + ctx.xStartSetSizes + ', ' + y + ')'; // ' + (textHeight - 5) + ')'\n        },\n        width: function (d) {\n          return ctx.subSetSizeScale(d.data.setSize);\n        },\n        height: function (d) {\n          return ctx.cellSize - 2\n        }\n      })\n\n*/\n\n\n\n        subsetRows.each(function (e, j) {\n\n            var g = d3.select(this);\n            var max_scale = ctx.subSetSizeScale.domain()[1];\n\n            var i = 0, is_overflowing = false;\n            var nbLevels = Math.min(ctx.maxLevels, Math.ceil(e.data.setSize / max_scale));\n\n            var data = d3.range(nbLevels).map(function () {\n\n                var f = {};\n                f.data = {};\n                f.data.type = e.data.type;\n\n               // Prevent empty bar when right on 1-level value\n                if(nbLevels==1 && e.data.setSize > 0 && (e.data.setSize % max_scale == 0)) {\n                  f.data.setSize = e.data.setSize;\n                  return f;\n                }\n\n                if (i == nbLevels - 1 && Math.ceil(e.data.setSize / max_scale) < nbLevels + 1)\n                    f.data.setSize = (e.data.setSize % max_scale);\n                else\n                    f.data.setSize = max_scale;\n                i++;\n                return f;\n            })\n\n            g.selectAll(\".cutlines\").remove();\n\n            if (Math.ceil(e.data.setSize / max_scale) > ctx.maxLevels) {\n                var g_lines = g.selectAll(\".cutlines\").data([e.id]).enter().append(\"g\").attr(\"class\", \"cutlines\")\n\n                g_lines.append(\"line\")\n                    .attr({x1: ctx.xStartSetSizes + ctx.subSetSizeWidth-15, x2: ctx.xStartSetSizes + ctx.subSetSizeWidth-5, y1: 0, y2: 20})\n                    .style({'stroke': 'white', 'stroke-width': 1})\n\n                g_lines.append(\"line\")\n                    .attr({x1: ctx.xStartSetSizes + ctx.subSetSizeWidth-20, x2: ctx.xStartSetSizes + ctx.subSetSizeWidth-10, y1: 0, y2: 20})\n                    .style({'stroke': 'white', 'stroke-width': 1})\n            }\n\n            // Add new layers\n            var layers_enter = g.selectAll(\".gHorizon\").selectAll(\".row-type-subset\").data(data).enter()\n\n            layers_enter.append('rect')\n                .attr(\"class\", function (d) {\n                    return ( 'subSetSize row-type-subset' );\n\n                })\n\n            // Remove useless layers\n            g.selectAll(\".row-type-subset\").data(data).exit().remove()\n\n            // Update current layers\n            g.selectAll(\".row-type-subset\")\n                .attr({\n                    transform: function (d, i) {\n                        var y = 0;\n                        if (d.data.type !== ROW_TYPE.SUBSET)\n                            y = 0;//cellSize / 3 * .4;\n                        return   'translate(' + (ctx.xStartSetSizes) + ', ' + (y + ctx.cellSizeShrink * i + 1) + ')'; // ' + (textHeight - 5) + ')'\n                    },\n\n                    width: function (d, i) {\n                        return ctx.subSetSizeScale(d.data.setSize);\n                    },\n                    height: function (d, i) {\n                        return ctx.cellSize - ctx.cellSizeShrink * 2 * i - 2;\n                    }\n                })\n                .style({\n                    fill:function(d,i){ return ctx.horizonBarGrays(i);}\n                })\n//                .style(\"opacity\", function (d, i) {\n//                    if (nbLevels == 1)\n//                        return .8;\n//                    else if (nbLevels == 2)\n//                        return .8 + i * .2;\n//                    else\n//                        return .4 + i * .4;\n//                })\n                .on('click', function () {\n                  //console.log(\"e\", e, d3.select(this).node().parentNode.__data__)\n                  ctx.intersectionClicked(e);\n                })\n                .on('mouseover', function () {\n                    mouseoverRow(e);\n                })\n                .on('mouseout', function () {\n                    mouseoutRow(e);\n                })\n\n        })\n\n\n\n    }\n\n    function updateGroupRows(groupRows) {\n        var groupsRect = groupRows.select(\".gBackgroundRect\").selectAll(\".groupBackGround\").data(function (d) {\n            return [d];\n        });\n        //**init\n        groupsRect.enter().append('rect').attr({\n            class: function (d) {\n                if (d.data instanceof QueryGroup) {\n                    return 'groupBackGround filterGroup';\n                } else {\n                    if (d.data.level>1) return 'groupBackGround secondLevel';\n                    else return 'groupBackGround'\n                }\n            },\n            rx:5,\n            ry:10,\n            width: ctx.setVisWidth + ctx.leftOffset,\n            height: ctx.cellSize,\n            x: -ctx.leftOffset,\n            y: 0\n        })\n//            .on('click', function (d) {\n//                collapseGroup(d.data);\n//                updateStatistics();\n//\n//                rowTransition(false);\n//            });\n\n        groupsRect.exit().remove();\n        //**update\n        groupsRect.attr({\n            width: function (d) {\n                return ctx.setVisWidth + ctx.leftOffset - (d.data.level - 1) * ctx.leftIndent;\n            },\n            height: ctx.cellSize,\n            x: function (d) {\n                return (d.data.level - 1) * ctx.leftIndent - ctx.leftOffset\n            }\n        });\n\n        //  console.log('g2: ' + groups);\n        var groupsText = groupRows.selectAll(\".groupLabel.groupLabelText\").data(function (d) {\n            return [d];\n        });\n        groupsText.enter().append('text')\n            .attr({class: 'groupLabel groupLabelText',\n                y: ctx.cellSize - 3,\n                x: function (d) {\n                    return (-ctx.leftOffset + 12) + (d.data.level - 1) * ctx.leftIndent;\n                },\n                'font-size': ctx.cellSize - 6\n\n            });\n        groupsText.exit().remove();\n\n        var queryGroupDecoItems = [\n//            {id:\"I\", action:1, color:\"#a1d99b\"},\n            {id: \"X\", action: 2, color: \"#f46d43\"}\n        ];\n\n        //** update\n        groupsText.text(function (d) {\n\n//            if (d.data instanceof QueryGroup){\n//                return \"@ \"+d.data.elementName;\n//            }\n//            if (d.data.type === ROW_TYPE.GROUP)\n//                return d.data.elementName;\n\n            if (d.data.type === ROW_TYPE.AGGREGATE)\n                return String.fromCharCode(8709) + '-subsets (' + d.data.subSets.length + ') ';\n            else {\n                var truncateLength = 0;\n              if (d.data.type === ROW_TYPE.GROUP && typeof(d.data.combinedSets) != \"undefined\") {\n                truncateLength = 10;\n              } else {\n                truncateLength = ctx.truncateGroupAfter;\n              }\n              var str = d.data.elementName.substring(0, truncateLength);\n              if(str.length<d.data.elementName.length)\n                str = str.trim() + \"...\";\n              return str;\n            }\n        }).attr({\n                class: function () {\n                    if (ctx.cellDistance < 14) return 'groupLabel groupLabelText small'; else return 'groupLabel groupLabelText'\n                },\n                y: ctx.cellSize - 3,\n                x: function (d) {\n                    return (-ctx.leftOffset + 15) + (d.data.level - 1) * ctx.leftIndent;\n                }\n\n            })\n        .on('click', function (d) {\n                collapseGroup(d.data);\n                updateStatistics();\n                rowTransition(false);\n            })\n        .append(\"svg:title\")\n            .text(function (d, i) {\n                return d.data.elementName;\n            })\n\n        var collapseIcon = groupRows.selectAll(\".collapseIcon\").data(function (d) {\n            return [d];\n        })\n        collapseIcon.enter()\n            .append(\"text\")\n            .attr({\n                class: \"collapseIcon\"\n            }).on('click', function (d) {\n                collapseGroup(d.data);\n                updateStatistics();\n                rowTransition(false);\n            });\n\n        collapseIcon\n            .text(function (d) {\n                if (d.data.isCollapsed == 0) return \"\\uf0dd\";//return \"\\uf147\";\n                else return \"\\uf0da\";//return \"\\uf196\"\n            })\n            .attr({\"transform\": function (d) {\n                return \"translate(\" + (-ctx.leftOffset + 2 + 5 + (d.data.level - 1) * ctx.leftIndent) + \",\" + (ctx.cellSize / 2 + 5) + \")\"\n            }\n            }).style({\n                \"font-size\": \"10px\"\n            })\n\n        // -- Decoration for Filter Groups\n        var allQueryGroups = groupRows.filter(function (d) {\n            return (d.data instanceof QueryGroup)\n        })\n        var groupDeleteIcon = allQueryGroups.selectAll(\".groupDeleteIcon\").data(function (d) {\n            return [d]\n        })\n        var groupDeleteIconEnter = groupDeleteIcon.enter().append(\"g\").attr({\n            class: \"groupDeleteIcon\"\n        })\n//        groupDeleteIconEnter.append(\"rect\").attr({\n//            x:-5,\n//            y:-10,\n//            width:10,\n//            height:10,\n//            fill:\"#f46d43\"\n//        })\n        groupDeleteIconEnter.append(\"text\")\n            .text(\"\\uf057\") // uf057 uf05e\n            .on({\n                \"click\": function (d) {\n\n                    var index = -1;\n                    UpSetState.logicGroups.forEach(function (dd, i) {\n\n                        if (dd.id == d.id) index = i;\n                    })\n\n                    UpSetState.logicGroups.splice(index, 1);\n\n                    UpSetState.logicGroupChanged = true;\n                    UpSetState.forceUpdate = true;\n\n                    updateState();\n                    rowTransition();\n                }\n            }).style({ \"fill\": \"#f46d43\"})\n\n        groupDeleteIcon.attr({\n            \"transform\": \"translate(\" + (ctx.xStartSetSizes - 12) + \",\" + (ctx.cellSize / 2 + 4) + \")\"\n        })\n\n\n        // --- circles for Groups with combinedSets element set --- ///\n\n        function decorateGroupsWithCells(){\n            var nonLogicGroups =  groupRows.filter(function (d) {\n                return  (\"combinedSets\" in d.data); //!(d.data instanceof QueryGroup) &&\n            })\n            var combinationGroups = nonLogicGroups.selectAll('g.combination').data(function (d) {\n                    // binding in an array of size one\n                    return [d.data.combinedSets];\n                }\n            )\n\n            combinationGroups.enter()\n                .append('g')\n                .attr({class: 'combination'\n                })\n            combinationGroups.exit().remove();\n\n\n            var cells = combinationGroups.selectAll('.cell').data(function (d) {\n\n                return d.map(function (dd, i) {\n                    return {data: usedSets[i], value: dd}\n                });\n            })\n            // ** init\n            cells.enter()\n                .append('circle')\n            .on({\n                'mouseover': function (d, i) {\n                    mouseoverCell(d3.select(this).node().parentNode.parentNode.__data__, i)\n                },\n                'mouseout': mouseoutCell\n            })\n            cells.exit().remove()\n\n            //** update\n            cells.attr('cx', function (d, i) {\n                return (ctx.cellWidth) * i + ctx.cellWidth / 2;\n            })\n                .attr({\n                    r: ctx.cellSize / 2 - 3,\n                    cy: ctx.cellSize / 2,\n                    class: 'cell'\n                })\n                .style('fill', function (d) {\n                    switch(d.value)\n                    {case 0: //logicState.NOT\n                        return ctx.grays[0]\n                        break;\n                        case 1: //logicState.MUST\n                            return ctx.grays[1]\n                            break;\n                        default: // logicState.DONTCARE\n                            return \"url(#DontCarePattern)\"}\n                }\n            )\n                .style({\n                    \"stroke\":function(d){if (d.value ==0) return ctx.grays[1]; else return \"none\"}//ctx.grays[1]\n                })\n\n\n\n        }\n\n        decorateGroupsWithCells();\n\n\n        function decorateComplexQueries() {\n            var complexLogicGroups =  groupRows.filter(function (d) {\n                return  (\"orClauses\" in d.data && d.data.orClauses.length>1); //!(d.data instanceof QueryGroup) &&\n            })\n            var combinationGroups = complexLogicGroups.selectAll('g.complexCombination').data(function (d) {\n                    // binding in an array of size one\n                    return [d.data.orClauses];\n                }\n            )\n            combinationGroups.enter()\n                .append('g')\n                .attr({class: 'complexCombination'\n                })\n            combinationGroups.exit().remove();\n\n\n            combinationGroups.selectAll(\"text\").data(function(d){return [d]}).enter().append(\"text\")\n                .attr({\n                    class: function () {\n                        if (ctx.cellDistance < 14) return 'groupLabel small'; else return 'groupLabel'\n                    },\n                    x:(usedSets.length*ctx.cellWidth *.5),\n                    y: ctx.cellWidth-3\n                })\n                .style({\n                    cursor:\"pointer\",\n                    \"text-anchor\":\"middle\"\n                })\n                .text(function(d){return \"combination\";})\n                .on({\n                    \"mouseover\":function(d){\n                        var xy = d3.select(this.parentNode.parentNode).attr(\"transform\").split(/[,()]/);\n                   //     console.log(d3.select(this.parentNode.parentNode).attr(\"transform\"),d);\n//                        console.log(xy.split(/[,()]/));\n                        if (xy.length==4){\n                            var infoGroup = ctx.toolTipLayer.append(\"g\").attr({\n                                class:\"toolTipQuery\",\n                                \"transform\":\"translate(\"+\n                                    (+xy[1]+ctx.leftOffset-5)+\",\"+\n                                    (+xy[2]-ctx.textHeight+ctx.cellSize+5)+\")\"})\n                            infoGroup.style({\n                                \"opacity\":.00001\n                            }).transition().style({\n                                \"opacity\":1\n                            });\n\n//                            b.append(\"circle\").attr({\n//                                cx:5,\n//                                cy:5,\n//                                r:3\n//                            })\n\n//                            console.log(b);\n\n//                            var infoGroup = ctx.toolTipLayer.select(\"#toolTipQuery\");\n                            infoGroup.append(\"rect\").attr({\n//                                class:\"groupBackGround\",\n                                width:(usedSets.length*ctx.cellWidth+10),\n                                height: d.length*ctx.cellSize+10,\n                                rx:10,\n                                ry:10\n                            }).style({\n                                    \"stroke-width\":2,\n                                    \"stroke\":ctx.grays[1],\n                                    \"fill\":ctx.grays[0]\n                                })\n\n\n\n                       //     console.log(infoGroup);\n\n                            d.forEach(function(row,index){\n                                var y = index*ctx.cellSize;\n\n                                var actualRow = infoGroup.append(\"g\").attr({\n                                    class:\"combination\",\n                                    \"transform\":\"translate(\"+0+\",\"+y+\")\"\n                                })\n\n                                actualRow.selectAll('.cell').data(function (d) { return Object.keys(row).map(function(key){return row[key];})})\n                                .enter()\n                                    .append('circle')\n                                    .attr('cx', function (d, i) {\n                                        return (ctx.cellWidth) * i + ctx.cellWidth / 2+5;\n                                    })\n                                    .attr({\n                                        r: ctx.cellSize / 2 - 3,\n                                        cy: ctx.cellSize / 2+5,\n                                        class: 'cell'\n                                    })\n                                    .style('fill', function (d) {\n\n                                        switch(d.state)\n                                        {case 0: //logicState.NOT\n                                            return ctx.grays[0]\n                                            break;\n                                            case 1: //logicState.MUST\n                                                return ctx.grays[1]\n                                                break;\n                                            default: // logicState.DONTCARE\n                                                return \"url(#DontCarePattern)\"}\n                                    }\n                                )\n                                    .style({\n                                        \"stroke\":function(d){if (d.value ==0) return ctx.grays[1]; else return \"none\"}//ctx.grays[1]\n                                    })\n\n\n                            })\n\n\n\n                        }\n\n\n                    },\n                    \"mouseout\":function(){\n                        ctx.toolTipLayer.selectAll(\".toolTipQuery\").transition().attr({opacity:.0001}).remove();\n                    }\n\n                })\n            ;\n\n//            var cells = combinationGroups.selectAll('.cell').data(function (d) {\n//\n//                return d.map(function (dd, i) {\n//                    return {data: usedSets[i], value: dd}\n//                });\n//            })\n//            // ** init\n//            cells.enter()\n//                .append('circle')\n//                .on({\n//                    'mouseover': function (d, i) {\n//                        mouseoverCell(d3.select(this).node().parentNode.parentNode.__data__, i)\n//                    },\n//                    'mouseout': mouseoutCell\n//                })\n//            cells.exit().remove()\n//\n//            //** update\n//            cells.attr('cx', function (d, i) {\n//                return (ctx.cellWidth) * i + ctx.cellWidth / 2;\n//            })\n//                .attr({\n//                    r: ctx.cellSize / 2 - 3,\n//                    cy: ctx.cellSize / 2,\n//                    class: 'cell'\n//                })\n//                .style('fill', function (d) {\n//                    switch(d.value)\n//                    {case 0: //logicState.NOT\n//                        return ctx.grays[0]\n//                        break;\n//                        case 1: //logicState.MUST\n//                            return ctx.grays[1]\n//                            break;\n//                        default: // logicState.DONTCARE\n//                            return \"url(#DontCarePattern)\"}\n//                }\n//            )\n//                .style({\n//                    \"stroke\":function(d){if (d.value ==0) return ctx.grays[1]; else return \"none\"}//ctx.grays[1]\n//                })\n\n        }\n\n        decorateComplexQueries();\n\n\n\n//        var circles = tableRows.selectAll(\"circle\").data(function(d){return d.selectors})\n//        circles.enter()\n//            .append(\"circle\").attr({\n//                class:\"logicPanelCircle\",\n//                cx:function(d,i){return (i+.5)*cellWidth}, // TODO: add 90 as params!!\n//                cy: .5*cellSize,\n////                if (animated) return 0.5*cellSize;\n////                else return (i+1.5)*cellSize +5},\n//                r: cellSize/2-2\n//            })\n//\n//        circles.style({\n//            fill:function(d){\n//                switch(d.state)\n//                {\n//                    case logicState.NOT:\n//                        return grays[0]\n//                        break;\n//                    case logicState.MUST:\n//                        return grays[1]\n//                        break;\n//                    default: // logicState.DONTCARE\n//                        return \"url(#DontCarePattern)\"\n//                }},\n//            stroke:function(d){\n//                if (d.isSelected()) return logicColor;\n//                else return null;\n//            }\n//\n//        })\n\n\n\n\n        // --- Horizon Bars for size.\n\n        groupRows.each(function (e, j) {\n\n            var g = d3.select(this);\n            var max_scale = ctx.subSetSizeScale.domain()[1];\n\n            var i = 0, is_overflowing = false;\n            var nbLevels = Math.min(ctx.maxLevels, Math.ceil(e.data.setSize / max_scale));\n\n            var data = d3.range(nbLevels).map(function () {\n\n                var f = {};\n                f.data = {};\n                f.data.type = e.data.type;\n\n                // Prevent empty bar when right on 1-level value\n                if(nbLevels==1 && e.data.setSize > 0 && (e.data.setSize % max_scale == 0)) {\n                  f.data.setSize = e.data.setSize;\n                  return f;\n                }\n\n                if (i == nbLevels - 1 && Math.ceil(e.data.setSize / max_scale) < nbLevels + 1)\n                    f.data.setSize = (e.data.setSize % max_scale);\n                else\n                    f.data.setSize = max_scale;\n                i++;\n                return f;\n            })\n\n            g.selectAll(\".cutlines\").remove();\n\n            if (Math.ceil(e.data.setSize / max_scale) > ctx.maxLevels) {\n                var g_lines = g.selectAll(\".cutlines\").data([e.id]).enter().append(\"g\").attr(\"class\", \"cutlines\")\n\n                g_lines.append(\"line\")\n                    .attr({x1: ctx.xStartSetSizes + ctx.subSetSizeWidth-15, x2: ctx.xStartSetSizes + ctx.subSetSizeWidth-5, y1: 0, y2: 20})\n                    .style({'stroke': 'white', 'stroke-width': 1})\n\n                g_lines.append(\"line\")\n                    .attr({x1: ctx.xStartSetSizes + ctx.subSetSizeWidth-20, x2: ctx.xStartSetSizes + ctx.subSetSizeWidth-10, y1: 0, y2: 20})\n                    .style({'stroke': 'white', 'stroke-width': 1})\n            }\n\n            // Add new layers\n            var layers_enter = g.select(\".gHorizon\").selectAll(\".row-type-group\").data(data).enter()\n\n            layers_enter.append('rect')\n                .attr(\"class\", function (d) {\n                    return ( 'subSetSize row-type-group' );\n\n                })\n\n            // Remove useless layers\n            g.selectAll(\".row-type-group\").data(data).exit().remove()\n\n            // Update current layers\n            g.selectAll(\".row-type-group\")\n                .attr({\n                    transform: function (d, i) {\n\n                        return   'translate(' + (ctx.xStartSetSizes) + ', ' + (ctx.cellSizeShrink * i+2) + ')'; // ' + (textHeight - 5) + ')'\n\n                    },\n\n                    width: function (d, i) {\n                        return ctx.subSetSizeScale(d.data.setSize);\n                    },\n                    height: function (d, i) {\n\n                        return ctx.cellSize-4 - ctx.cellSizeShrink * 2 * i;\n\n                    }\n                })       .style({\n                    fill:function(d,i){ return ctx.horizonBarGrays(i);}\n                })\n//                .style(\"opacity\",function (d, i) {\n//                    if (nbLevels == 1)\n//                        return 1;\n//                    else if (nbLevels == 2)\n//                        return .8 + i * .2;\n//                    else\n//                        return .4 + i * .4;\n//                })\n            .on('click', function (d) {\n                    var subSets = d3.select(this).node().parentNode.__data__.data.subSets;\n                    if (!(subSets instanceof Array)) {\n                      var selection = Selection.fromSubset(d3.select(this).node().parentNode.__data__.data.subSets);\n                      selections.addSelection(selection, true);\n                      selections.setActive(selection);\n                    }\n                })\n\n        })\n\n    }\n\n    function updateRelevanceBars(allRows) {\n        var expectedValueBars = allRows.selectAll(\".disproportionality\").data(function (d) {\n            return [d]\n        })\n\n        expectedValueBars.enter()\n            .append('rect')\n            .attr({\n                transform: function (d) {\n                    var start = ctx.expectedValueScale(d3.min([0, d.data.disproportionality]));\n                    start += ctx.xStartExpectedValues;\n                    var y = 2;\n                    if (d.data.type === ROW_TYPE.SUBSET)\n                        y = 1;//cellSize / 3 * 1.7;\n                    return 'translate(' + start + ', ' + y + ')';\n                },\n                width: 1,\n                height: function (d) {\n                    if (d.data.type === ROW_TYPE.SUBSET)\n                        return ctx.cellSize - 2;\n                    else\n                        return ctx.cellSize-4;// / 3;\n                }\n            })\n            .on('mouseover', mouseoverRow)\n            .on('mouseout', mouseoutRow)\n\n        expectedValueBars.exit().remove()\n\n        // transition for subsets\n        changeTheValues(expectedValueBars.filter(function (d) {\n            return (d.data.type === ROW_TYPE.SUBSET)\n        }).transition())\n\n        // no transition for groups\n        changeTheValues(expectedValueBars.filter(function (d) {\n            return (d.data.type !== ROW_TYPE.SUBSET)\n        }))\n//        expectedValueBars.transition()\n\n        function changeTheValues(node) {\n            node.attr({\n                class: function (d) {\n                    return d.data.disproportionality < 0 ? 'disproportionality negative' : 'disproportionality positive';\n                },\n                transform: function (d) {\n                    if (isNaN(d.data.disproportionality)) {\n                        return 'translate(' + 0 + ', ' + 0 + ')';\n                    }\n                    var start = ctx.expectedValueScale(d3.min([0, d.data.disproportionality]));\n                    start += ctx.xStartExpectedValues;\n                    var y = 2;\n                    if (d.data.type == ROW_TYPE.SUBSET)\n                        y = 1;//cellSize / 3 * 1.7;\n                    return 'translate(' + start + ', ' + y + ')';\n                },\n                width: function (d) {\n                    if (isNaN(d.data.disproportionality)) {\n                        return 0;\n                    }\n                    //  console.log(d.data.disproportionality)\n                    return Math.abs(ctx.expectedValueScale(d.data.disproportionality) - ctx.expectedValueScale(0));\n                },\n                height: function (d) {\n                    if (d.data.type === ROW_TYPE.SUBSET)\n                        return ctx.cellSize - 2;\n                    else\n                        return ctx.cellSize-4;// / 3;\n                }\n            })\n        }\n    }\n\n    function updateAttributeStatistic(allRows){\n        allRows.each(function(row,j){\n            if (row.data.type == ROW_TYPE.SEPARATOR) return;\n\n            var rowElement = d3.select(this);\n\n            var detailStatisticElements = rowElement.selectAll(\".detailStatistic\").data(ctx.summaryStatisticVis,function(d,i){return d.attribute+i});\n            detailStatisticElements.exit().remove();\n            detailStatisticElements.enter().append(\"g\").attr({\n                class:function(d){return \"detailStatistic\"}\n            })\n\n\n\n            detailStatisticElements.each(function(d,i){\n\n                d.visObject.renderBoxPlot(row.id,d3.select(this),ctx.xStartStatisticColumns+i*(ctx.summaryStatisticsWidth+ctx.majorPadding),2,null,ctx.cellSize-4,\"detail\"+i); //  function(id, g, x,y,w,h)\n\n            })\n\n        })\n\n\n\n\n    }\n\n\n    function updateOverlays(allRows) {\n        if (selections.getSize() == 0) {\n            allRows.selectAll(\".what\").remove();\n            allRows.selectAll(\".newOverlay\").remove();\n            allRows.selectAll('.selectionIndicators').remove();\n            return;\n        }\n\n        var currentRowSize = 0\n\n        allRows.each(function (e, j) {\n\n            var g = d3.select(this);\n            var max_scale = ctx.subSetSizeScale.domain()[1];\n\n\n          if(e.data.type==ROW_TYPE.GROUP) {\n\n            e.data.selections = {};\n            e.data.selections.setSize = e.data.setSize;\n            currentRowSize = e.data.setSize;\n\n            e.data.subSets.map(function(s, k) {\n\n              if(typeof(e.data.selections) == \"undefined\")\n                e.data.selections = {};\n\n                for (var p in s.selections) {\n                  if(typeof(e.data.selections[p]) == \"undefined\")\n                    e.data.selections[p] = [];\n\n                  e.data.selections[p] = e.data.selections[p].concat(s.selections[p]);\n\n              }\n            });\n\n          }\n            // FIND UUID\n             var usedID = false;\n            //   var alternativeID;\n            var sIDs = Object.getOwnPropertyNames(e.data.selections);\n            var s = e.data.selections;\n            sIDs.forEach(function (prop) {\n                var length = s[prop].length;\n                if (selections.isActiveByUuid(prop)) {\n                    usedID = prop;\n                }\n            });\n            if (!usedID) {\n                return 0;\n            }\n\n            currentRowSize =  s[usedID].length;\n            if(e.data.type==ROW_TYPE.GROUP)\n              e.data.selections.setSize =currentRowSize;\n\n\n            var i = 0, is_overflowing = false;\n            var nbLevels = Math.min(ctx.maxLevels, Math.ceil(currentRowSize / max_scale));\n            var data = d3.range(nbLevels).map(function () {\n\n                var f = {};\n                f.data = {};\n                f.data.setSize = currentRowSize\n                f.data.type = e.data.type;\n               // Prevent empty bar when right on 1-level value\n                if(nbLevels==1 && currentRowSize > 0 && (currentRowSize % max_scale == 0)) {\n                  f.data.setSize = currentRowSize;\n                  return f;\n                }\n\n                if (i == nbLevels - 1 && Math.ceil(currentRowSize / max_scale) < nbLevels + 1)\n                    f.data.setSize = (currentRowSize % max_scale);\n                else\n                    f.data.setSize = max_scale;\n                i++;\n\n\n                return f;\n            })\n\n            // Add new layers\n            var layers_enter = g.selectAll(\".gOverlays\").selectAll(\".newOverlay\").data(data).enter()\n\n            layers_enter.append('rect')\n                .attr(\"class\", \"newOverlay\")\n\n            // Remove useless layers\n            g.selectAll(\".newOverlay\").data(data).exit().remove()\n\n            // Update current layers\n            g.selectAll(\".newOverlay\")\n                .attr({\n                    transform: function (d, i) {\n                     //   var y = 0;\n                     //   if (d.data.type !== ROW_TYPE.SUBSET)\n                     //       y = 0;//cellSize / 3 * .4;\n                        return   'translate(' + (ctx.xStartSetSizes) + ', ' + (ctx.cellSizeShrink * i + 1) + ')'; // ' + (textHeight - 5) + ')'\n                    },\n\n                    width: function (d, i) {\n\n                     return ctx.subSetSizeScale(d.data.setSize);\n\n                  },\n                    height: function (d, i) {\n                        return ctx.cellSize - ctx.cellSizeShrink * 2 * i - 2;\n                    },\n                   fill: function(d) {\n                     var usedID = false;\n                    //   var alternativeID;\n                    var sIDs = Object.getOwnPropertyNames(e.data.selections);\n                    var s = e.data.selections;\n                    sIDs.forEach(function (prop) {\n                        var length = s[prop].length;\n                        if (selections.isActiveByUuid(prop)) {\n                            usedID = prop;\n                        }\n                    });\n                    if (!usedID) {\n                        return 0;\n                    }\n\n                    return selections.getColorFromUuid(usedID)//\"url(#diagonalHatch_0)\"\n                   }\n\n                })\n                .style(\"opacity\", function (d, i) {\n\n                    if (nbLevels == 1)\n                        return .5;\n                    else if (nbLevels == 2)\n                        return .5 + i * .2;\n                    else\n                        return .2 + i * .3;\n                })\n                .on('click', function () {\n                  ctx.intersectionClicked(e);\n                })\n                .on('mouseover', function () {\n                    mouseoverRow(e);\n                })\n                .on('mouseout', function () {\n                    mouseoutRow(e);\n                })\n\n        })\n\n\n/*\n        var selectionOverlay = allRows.selectAll(\".what\").data(function (d) {\n            return [d]\n        })\n        selectionOverlay.enter().append('rect')\n            .on('click', function (d) {\n                if (d.data.type === ROW_TYPE.SUBSET) {\n                    var selection = Selection.fromSubset(d.data);\n                    selections.addSelection(selection, true);\n                    selections.setActive(selection);\n                }\n            })\n            .on('mouseover', mouseoverRow)\n            .on('mouseout', mouseoutRow)\n            .attr(\"class\", \"what\");\n\n        selectionOverlay\n            .attr({\n                transform: function (d) {\n                    var y = 0;\n                    if (d.data.type == ROW_TYPE.SUBSET)\n                        y = 1; //cellSize / 3 * .4;\n                    return   'translate(' + ctx.xStartSetSizes + ', ' + y + ')'; // ' + (textHeight - 5) + ')'\n                },\n\n                width: function (d) {\n                    var s = d.data.selections;\n                    if (typeof s !== 'object') {\n                        return 0;\n                    }\n\n                    var usedID = false;\n                    //   var alternativeID;\n                    var sIDs = Object.getOwnPropertyNames(s);\n                    sIDs.forEach(function (prop) {\n                        var length = s[prop].length;\n                        if (selections.isActiveByUuid(prop)) {\n                            usedID = prop;\n                        }\n                    });\n                    if (!usedID) {\n                        return 0;\n                    }\n                   // d3.select(this).style(\"fill\", selections.getColorFromUuid(usedID));\n                    return   ctx.subSetSizeScale(s[usedID].length);\n                },\n                height: function (d) {\n                    return ctx.cellSize - 2// / 3;\n\n                }\n            })\n*/\n        // the triangles for the multiple selections\n\n        //allRows.data([\"indicators\"]).enter().append(\"g\").attr(\"class\", \"gIndicators\")\n\n\n        var selectIndicators = allRows.select('.gIndicators').selectAll('.selectionIndicators').data(function (d, i) {\n            if (!d.data.selections)\n                return [];\n            var selectionIDs = Object.getOwnPropertyNames(d.data.selections);\n            var selArray = selectionIDs.map(function (k) {\n                return {uuid: k, items: d.data.selections[k]};\n            });\n            selArray = selArray.filter(function (d) {\n                return d.items.length !== 0 && d.uuid != \"undefined\" && d.uuid != \"setSize\"; // prevents useless black indicators.. + Bug\n            })\n            var max_scale = ctx.subSetSizeScale.domain()[1];\n            return selArray;\n        })\n        selectIndicators.enter()\n            .append('path').attr({\n                class: 'selectionIndicators'\n            }).on('click', function (d) {\n                selections.setActiveByUuid(d.uuid);\n                updateOverlays(allRows);\n            }).on('mouseenter', function() {\n              d3.select(this).attr(\"transform\", function (d, i) {\n                //UPDATE\n                return 'translate(' + d3.transform(d3.select(this).attr(\"transform\")).translate + ') scale(1.5) rotate('+d3.transform(d3.select(this).attr(\"transform\")).rotate+')';\n              })\n            }).on('mouseout', function() {\n              //UPDATE\n              d3.select(this).attr(\"transform\", function (d, i) {\n                return 'translate(' + d3.transform(d3.select(this).attr(\"transform\")).translate + ') scale(1) rotate('+d3.transform(d3.select(this).attr(\"transform\")).rotate+')';\n            })})\n        selectIndicators.exit().remove();\n        selectIndicators.attr({\n            transform: function (d, i) {\n\n              var nbLevels = Math.floor(d.items.length / ctx.subSetSizeScale.domain()[1]);\n              var subSetSize = d.items.length % ctx.subSetSizeScale.domain()[1];\n              var rotate = 0;\n              if(nbLevels>=ctx.maxLevels) {\n                subSetSize = ctx.subSetSizeScale.domain()[1]\n                nbLevels = ctx.maxLevels-1;\n                rotate = -90;\n              }\n                return 'translate(' + (ctx.xStartSetSizes + ctx.subSetSizeScale(subSetSize)) + ' , ' + (nbLevels*ctx.cellSizeShrink) +\n                    ') rotate(' + rotate + ')';\n            },\n            d: function (d) {\n                return  \" M -5 0  L  5 0  L 0 6 z M 0 6 L 0 \" + ctx.cellSize;\n            },\n\n            stroke: 'white',\n            \"stroke-width\": 1,\n            fill: function (d, i) {\n                return selections.getColorFromUuid(d.uuid);\n            }\n        })\n    }\n\n    function updateBarLabels(allRows) {\n        var barLabels = allRows.selectAll(\".intersectionSizeLabel\").data(function (d) {\n            return[d]\n        })\n        barLabels.enter().append('text')\n            .attr({class: 'intersectionSizeText intersectionSizeLabel'})\n            .on('click', function (d) {\n                ctx.intersectionClicked(d)\n            });\n        barLabels.exit().remove();\n\n        var barLabelChanges = barLabels.text(function (d) {\n            return d.data.setSize;\n        })\n        if (ctx.barTransitions) barLabelChanges.transition()\n        barLabelChanges.attr({class: 'intersectionSizeText intersectionSizeLabel',\n            y: ctx.cellSize / 2,\n            x: function (d) {\n                return ctx.xStartSetSizes + ctx.subSetSizeScale(d.data.setSize) + 2;\n            }\n\n        });\n    }\n\n    function updateColumnBackgrounds() {\n        var columnBackgrounds = ctx.columnBackgroundNode.selectAll(\".columnBackground\").data(usedSets);\n        columnBackgrounds.enter().append(\"rect\").attr({\n            class: \"columnBackground\"\n        }).style({\n                \"stroke\": \"none\",\n                fill: ctx.backHighlightColor,\n                opacity: 0\n            })\n        columnBackgrounds.exit().remove();\n        columnBackgrounds.attr({\n            'x': function (d, i) {\n                return (ctx.cellWidth) * i;\n            },\n//            y: ctx.textHeight,\n            height: ctx.tableBodyHeight,\n            width: ctx.cellWidth\n        })\n    }\n\n    function plotSubSets() {\n\n\n\n//        console.log(\"plot\");\n        setDynamicVisVariables();\n        ctx.svgBody.attr({\n            height:ctx.rowScale.rangeExtent()[1]\n        })\n\n//        // to limit the foraignobject again\n//        updateFrames($(window).height(), null);\n\n        updateColumnBackgrounds();\n\n        var separatorRow = null;\n        // generate <g> elements for all rows\n        var allRows = updateSubSetGroups().filter(function(r){\n            if (r.data.type==ROW_TYPE.SEPARATOR){\n                separatorRow= d3.select(this);\n                return false;\n            }else return true;\n        })\n\n        var setScale = d3.scale.ordinal().domain([0, 1]).range(ctx.grays);\n\n        var subSetRows = allRows.filter(function (d) {\n            return d.data.type === ROW_TYPE.SUBSET;\n        })\n\n        // decorate subset rows\n        updateSubsetRows(subSetRows, setScale);\n\n        var groupRows = allRows.filter(function (d, i) {\n            if (d.data.type === ROW_TYPE.GROUP || d.data.type === ROW_TYPE.AGGREGATE)\n                return true;\n            return false;\n        })\n\n        // decorate GroupRows\n        updateGroupRows(groupRows);\n\n        // add BarLabels to all bars\n        updateBarLabels(allRows);\n\n//\n        // Rendering the highlights and ticks for selections on top of the selected subsets\n        updateOverlays(allRows);\n\n        // ----------------------- expected value bars -------------------\n\n        updateRelevanceBars(allRows);\n\n        // ----------------------- all Rows -------------------\n        updateAttributeStatistic(allRows);\n\n\n//        var separatorColumns = renderRows.filter(function(d){return (d.data instanceof Separator)});\n//        separatorColumns.append(\"\")\n\n        if (separatorRow!=null){\n            var sepRowLine = separatorRow.selectAll(\".gSeparatorLine\").data([1])\n            sepRowLine.enter().append(\"line\").attr({\n                    class:\"gSeparatorLine\"\n                })\n\n            sepRowLine.attr({\n                x1:-ctx.leftOffset,\n                x2:ctx.w,\n                y1:ctx.cellSize/2,\n                y2:ctx.cellSize/2\n            })\n\n        }\n\n\n\n        // Adjust the row height\n        d3.select(\".divForeign\").select(\"svg\").attr(\"height\", renderRows.length * ctx.cellDistance);\n    }\n\n    function bindEvents() {\n        $(EventManager).bind(\"item-selection-added\", function (event, data) {\n            //console.log(\"Selection was added to selection list with color \" + selections.getColor(data.selection) + ' and ' + data.selection.items.length + ' items.');\n\n            data.selection.mapToSubsets(subSets);\n\n            plotSelectionTabs(\"#selection-tabs\", selections, data.selection);\n            plotSelectedItems(\"#item-table\", data.selection);\n            elementViewers.renderViewer();\n        });\n\n        $(EventManager).bind(\"item-selection-updated\", function (event, data) {\n            //console.log('Selection was updated! New length is ' + data.selection.items.length + ' items.');\n\n            data.selection.mapToSubsets(subSets);\n            plot();\n            plotSelectionTabs(\"#selection-tabs\", selections, data.selection);\n            plotSelectedItems(\"#item-table\", data.selection);\n            elementViewers.renderViewer();\n\n            plotSetOverview();\n        });\n\n        $(EventManager).bind(\"item-selection-removed\", function (event, data) {\n            //console.log(\"Selection was removed from selection list.\");\n            data.selection.unmapFromSubsets(subSets);\n\n            if ( selections.list.length === 0 ) {\n                $( '#filters-list' ).html(\"\");\n                $( '#filters-controls' ).html(\"\");\n            }\n\n            plot();\n            plotSelectionTabs(\"#selection-tabs\", selections, selections.getActive());\n            plotSelectedItems(\"#item-table\", selections.getActive());\n            elementViewers.renderViewer();\n            plotSetOverview();\n        });\n\n        $(EventManager).bind(\"item-selection-activated\", function (event, data) {\n            if (data.selection) {\n                //console.log('Selection ' + data.selection.id + ' was activated.');\n\n                plot();\n                plotSelectionTabs(\"#selection-tabs\", selections, data.selection);\n                data.selection.filterCollection.renderFilters();\n                plotSelectedItems(\"#item-table\", data.selection);\n                plotSetOverview();\n            }\n            else {\n                plot();\n                plotSelectionTabs(\"#selection-tabs\", selections, data.selection);\n                plotSelectedItems(\"#item-table\", data.selection);\n                plotSetOverview();\n            }\n            vennInstance.plot(null, usedSets.length)\n            elementViewers.renderViewer();\n        });\n\n        $(EventManager).bind(\"ui-resize\", debounce(function (event, data) {\n            ctx.resizeSetView(data.newHeight, null)\n//            plot(Math.floor(data.newWidth * .66), Math.floor(data.newHeight));\n            plotSetOverview();\n        }, 300));\n\n        $(EventManager).bind(\"ui-vertical-resize\", debounce(function (event, data) {\n\n            ctx.resizeSetView(data.newHeight, null)\n//            plot(undefined, Math.floor(data.newHeight));\n            plotSetOverview();\n        }, 300));\n\n//        $(EventManager).bind(\"ui-horizontal-resize\", function (event, data) {\n//            plot(Math.floor(data.newWidth * .66), undefined);\n//            plotSetOverview();\n//        });\n\n        $(EventManager).bind(\"loading-dataset-started\", function (event, data) {\n            $(\".ui-fader\").show();\n            $(\"#data-loading-indicator\").show();\n        });\n\n        $(EventManager).bind(\"loading-dataset-finished\", function (event, data) {\n            $(\".ui-fader\").fadeOut(1000);\n            $(\"#data-loading-indicator\").fadeOut(1000);\n\n            elementViewers.renderController();\n            elementViewers.renderViewer();\n        });\n\n        $(EventManager).bind(\"vis-svg-resize\", debounce(function (event, data) {\n            //vis-svg-resize\", { newWidth:+(leftWidth + (endX - startX)) });\n            updateFrames(null, data.newWidth);\n            updateHeaders()\n            plotSubSets()\n            plotSetOverview()\n\n        }, 300));\n    }\n\n    /** Passing true will disable the group */\n    function toggleGroupingL2(disable) {\n        var noGroupingL2 = $('#noGroupingL2');\n\n        if (disable) {\n            noGroupingL2.prop('checked', true);\n        }\n        noGroupingL2.prop('disabled', disable);\n\n        $('#groupByIntersectionSizeL2').prop('disabled', disable);\n        $('#groupBySetL2').prop('disabled', disable);\n        $('#groupByRelevanceMeasureL2').prop('disabled', disable);\n        $('#groupByOverlapDegreeL2').prop('disabled', disable);\n    }\n\n    function disableL2Equivalent(id) {\n        var l2 = $(id);\n        if (l2.prop('checked')) {\n            $('#noGroupingL2').prop('checked', true);\n        }\n        l2.prop('disabled', true);\n    }\n\n    function updateL2Grouping(){\n\n        if (UpSetState.grouping==undefined){\n            d3.select(\"#secondLevelGroupingSelect\").attr({disabled:true})\n        }else{\n            d3.select(\"#secondLevelGroupingSelect\").attr({disabled:null})\n            var selectableOptions = {};\n            Object.keys(ctx.groupingOptions).forEach(function(key){\n                if (key!=UpSetState.grouping) selectableOptions[key] = ctx.groupingOptions[key];\n            })\n\n         //   console.log(\"updateL2:\",selectableOptions);\n\n    //        UpSetState.grouping = StateOpt.groupByRelevanceMeasure;\n    //        UpSetState.levelTwoGrouping = undefined;\n\n            var l2GroupingSelect = d3.select(\"#secondLevelGrouping\").selectAll(\"select\").data([selectableOptions]);\n            l2GroupingSelect.exit().remove();\n            l2GroupingSelect.enter().append(\"select\").attr({\n                id: \"secondLevelGroupingSelect\",\n                class:\"groupingSelect\"\n            }).on({\n                    \"change\": function () {\n                        var value = this.options[this.selectedIndex].value;\n                        ctx.groupingOptions[value].l2action();\n                        updateCardinalitySpinners();\n                        updateState();\n                        updateStatistics();\n                        rowTransition();\n                    }\n                });\n\n\n            // has to be deleted to keep order in list :((\n            d3.select(\"#secondLevelGroupingSelect\").selectAll(\"option\").remove();\n            var l2GroupingOptions = d3.select(\"#secondLevelGroupingSelect\").selectAll(\"option\")\n                .data(\n                    function (d) { return Object.keys(d).map(function (key) { return {key: key, data: d[key]} }) },\n                    function(d){ return d.key})\n                .enter().append(\"option\").attr({\n                    value:function(d){return d.key;},\n                    selected:function(d){return (d.key==UpSetState.levelTwoGrouping || (d.key==\"dont\" && UpSetState.levelTwoGrouping==undefined))?\"selected\":null}\n                }).text(function(d){return d.data.name});\n\n        }\n    }\n\n    function updateCardinalitySpinners(){\n        //  <div id='firstLevelMinCardinality' hidden>min: <input id='firstLevelMinCardinalityInput' type='number' min='0' max='12' value='0'>\n        d3.select(\"#firstLevelMinCardinality\").attr({\n            hidden:((UpSetState.grouping == StateOpt.groupByOverlapDegree)?null:\"true\")\n        }).select(\"input\").attr({\n                value:UpSetState.levelOneDegree,\n                min: 1,\n                max: usedSets.length\n            }).on({\n                \"change\":function(d){\n                    UpSetState.levelOneDegree = +(d3.select(this).node().value);\n                    UpSetState.forceUpdate=true;\n                    updateState();\n                    updateStatistics();\n                    rowTransition();\n                }\n\n\n            })\n\n\n\n        //<div id='secondLevelMinCardinality' hidden>min: <input id='secondLevelMinCardinalityInput' type='number' min='0' max='12' value='0'>\n        d3.select(\"#secondLevelMinCardinality\").attr({\n            hidden:((UpSetState.levelTwoGrouping== StateOpt.groupByOverlapDegree)?null:\"true\")\n        }).select(\"input\").attr({\n                value:UpSetState.levelTwoDegree,\n                min: 1,\n                max: usedSets.length\n            }).on({\n                \"change\":function(d){\n                    UpSetState.levelTwoDegree = +(d3.select(this).node().value);\n                    UpSetState.forceUpdate=true;\n                    updateState();\n                    updateStatistics();\n                    rowTransition();\n                }\n\n\n            })\n\n    }\n\n\n    function setUpSortSelections() {\n\n        // groupingDefinitions\n        ctx.groupingOptions[StateOpt.groupByIntersectionSize] = { name: \"Degree\", l1action:function(){},l2action:function(){} };\n        ctx.groupingOptions[StateOpt.groupBySet]={ name: \"Sets\", l1action:function(){},l2action:function(){} };\n        ctx.groupingOptions[StateOpt.groupByRelevanceMeasure] ={ name: \"Deviation\", l1action:function(){}, l2action:function(){} };\n        ctx.groupingOptions[StateOpt.groupByOverlapDegree] = { name: \"Overlaps\", l1action:function(){}, l2action:function(){} };\n        ctx.groupingOptions[\"dont\"] ={ name: \"Don't Aggregate\", l1action:function(){}, l2action:function(){} };\n\n\n\n\n\n       // ---- define L1 actions\n\n       ctx.groupingOptions[StateOpt.groupByIntersectionSize]\n           .l1action = function(){\n               UpSetState.grouping = StateOpt.groupByIntersectionSize;\n               UpSetState.levelTwoGrouping = undefined;\n           }\n\n       ctx.groupingOptions[StateOpt.groupBySet]\n           .l1action= function () {\n               UpSetState.grouping = StateOpt.groupBySet;\n               UpSetState.levelTwoGrouping = undefined;\n           };\n\n\n        ctx.groupingOptions[StateOpt.groupByRelevanceMeasure]\n            .l1action=function () {\n                UpSetState.grouping = StateOpt.groupByRelevanceMeasure;\n                UpSetState.levelTwoGrouping = undefined;\n            };\n\n        ctx.groupingOptions[StateOpt.groupByOverlapDegree]\n            .l1action=function () {\n                UpSetState.grouping = StateOpt.groupByOverlapDegree;\n                UpSetState.levelTwoGrouping = undefined;\n            };\n\n        ctx.groupingOptions[\"dont\"]\n            .l1action=function () {\n                UpSetState.grouping = undefined;\n                UpSetState.levelTwoGrouping = undefined;\n                UpSetState.forceUpdate = true;\n            };\n\n\n       // --- define L2 actions\n\n\n        // ---------------- Grouping L2 -----------\n\n        ctx.groupingOptions[StateOpt.groupByIntersectionSize]\n            .l2action=function () {\n                UpSetState.levelTwoGrouping = StateOpt.groupByIntersectionSize;\n            };\n\n        ctx.groupingOptions[StateOpt.groupBySet]\n            .l2action=function () {\n                UpSetState.levelTwoGrouping = StateOpt.groupBySet;\n            };\n\n        ctx.groupingOptions[StateOpt.groupByOverlapDegree]\n            .l2action=function () {\n                UpSetState.levelTwoGrouping = StateOpt.groupByOverlapDegree;\n            };\n\n        ctx.groupingOptions[StateOpt.groupByRelevanceMeasure]\n            .l2action=function () {\n                UpSetState.levelTwoGrouping = StateOpt.groupByRelevanceMeasure;\n            };\n\n        ctx.groupingOptions[\"dont\"]\n            .l2action=function () {\n                UpSetState.levelTwoGrouping = undefined;\n            };\n\n\n\n        // ----------- grouping L1 -------------------------\n\n        var l1GroupingSelect = d3.select(\"#firstLevelGrouping\").selectAll(\"select\").data([ctx.groupingOptions]);\n        l1GroupingSelect.exit().remove(); // will not be called\n        l1GroupingSelect.enter().append(\"select\").attr({\n            id: \"firstLevelGroupingSelect\",\n            class:\"groupingSelect\"\n        }).on({\n                \"change\": function () {\n                    var value = this.options[this.selectedIndex].value;\n                    ctx.groupingOptions[value].l1action();\n                    updateL2Grouping();\n                    updateCardinalitySpinners();\n                    updateState();\n                    updateStatistics();\n                    rowTransition();\n\n                }\n            });\n\n        var l1GroupingOptions = l1GroupingSelect.selectAll(\"option\")\n            .data(function (d) {return Object.keys(d).map(function (key) { return {key: key, data: d[key]} }) });\n        l1GroupingOptions.exit().remove();\n        l1GroupingOptions.enter().append(\"option\").attr({\n            value:function(d){return d.key;}\n        }).text(function(d){return d.data.name});\n\n        // ----------- grouping L2 as update as it depends on L1 -------------------------\n        updateL2Grouping();\n        updateCardinalitySpinners();\n\n\n\n\n\n        // ------- options ----\n\n        d3.selectAll('#collapseAll').on(\n            'click',\n            function (d) {\n                UpSetState.collapseAll = true;\n                UpSetState.collapseChanged = true;\n                updateState();\n                updateStatistics();\n                rowTransition();\n            });\n\n        d3.selectAll('#expandAll').on(\n            'click',\n            function (d) {\n                UpSetState.expandAll = true;\n                UpSetState.collapseChanged = true;\n                updateState();\n                updateStatistics();\n                rowTransition();\n            });\n\n        // --------- sortings ------\n\n        // sort based on occurrence of one specific data item\n        //d3.selectAll('.sortBySet, .setLabel').on(\n        //   'click',\n        //    function (d) {\n        //        UpSetState.sorting = StateOpt.sortBySetItem;\n        //        UpSetState.grouping = undefined;\n        //        UpSetState.levelTwoGrouping = undefined;\n        //        updateState(d);\n        //        rowTransition();\n        //    });\n\n        d3.selectAll('#sortNrSetsInIntersection').on(\n            'click',\n            function (d) {\n                UpSetState.sorting = StateOpt.sortByCombinationSize;\n//                UpSetState.grouping = undefined;\n//                UpSetState.levelTwoGrouping = undefined;\n                UpSetState.forceUpdate = true;\n                updateState();\n                rowTransition();\n            });\n\n        d3.selectAll('.sortIntersectionSizeGlobal').on(\n            'click',\n            function (d) {\n                UpSetState.sorting = StateOpt.sortBySubSetSize;\n                UpSetState.grouping = undefined;\n                UpSetState.levelTwoGrouping = undefined;\n                UpSetState.forceUpdate = true;\n                $('#noGrouping').prop('checked', true);\n                toggleGroupingL2(true);\n                $('#sortIntersectionSize').prop('checked', true);\n\n                updateState();\n                rowTransition();\n            });\n\n        d3.selectAll('#sortIntersectionSize').on(\n            'click',\n            function (d) {\n                UpSetState.sorting = StateOpt.sortBySubSetSize;\n                UpSetState.forceUpdate = true;\n                updateState();\n                rowTransition();\n            });\n\n        // Not preserving the grouping\n        d3.selectAll('.sortRelevanceMeasureGlobal').on(\n            'click',\n            function () {\n                UpSetState.sorting = StateOpt.sortByExpectedValue;\n                UpSetState.grouping = undefined;\n                UpSetState.levelTwoGrouping = undefined;\n                UpSetState.forceUpdate = true;\n                $('#noGrouping').prop('checked', true);\n                $('#sortRelevanceMeasure').prop('checked', true);\n                toggleGroupingL2(true);\n                updateState();\n                rowTransition();\n            });\n\n        // Preserving the grouping\n        d3.selectAll('#sortRelevanceMeasure').on(\n            'click',\n            function () {\n                UpSetState.sorting = StateOpt.sortByExpectedValue;\n                UpSetState.forceUpdate = true;\n                updateState();\n                rowTransition();\n            });\n\n    }\n\n    document.getElementById('rowSizeValue').addEventListener('change', function () {\n        ctx.cellDistance = +(document.getElementById('rowSizeValue').value);\n        rowTransition();\n    });\n\n//    document.getElementById('rowPaddingValue').addEventListener('input', function () {\n//        ctx.cellDistance = +(document.getElementById('rowPaddingValue').value);\n//        //console.log(ctx.cellSize);\n//        rowTransition();\n//    });\n\n    var rowTransition = function (animateRows) {\n        if (animateRows != null) ctx.rowTransitions = animateRows;\n        else ctx.rowTransitions = true;\n        updateHeaders();\n        plotSubSets();\n        ctx.rowTransitions = true\n    }\n\n    ctx.updateHeaders = updateHeaders;\n    ctx.plot = rowTransition\n    ctx.plotTable = function () {\n        ctx.barTransitions = false;\n        plotSubSets();\n        ctx.barTransitions = true;\n    }\n\n    ctx.resizeSetView = updateFrames\n//    function(windowHeight, windowWidth){\n//        updateFrames(windowHeight, windowWidth);\n//        rowTransition(false);\n//    }\n\n    function updateFrames(windowHeight, windowWidth) {\n        if (windowWidth == null) {\n            d3.select(\".matrixTableContainer\")\n                .style({\n                    height: windowHeight+\"px\"\n                })\n\n//            d3.select('#bodyVis')\n//                .style({\n//                    height: (windowHeight-2*ctx.textHeight-40)+\"px\" // TODO: HACK\n//                    height: (windowHeight-300)+\"px\" // TODO: HACK\n//                })\n\n//            ctx.svgBody.attr({\n//                height: (windowHeight - 70)\n//            })\n            var tmc = d3.select(\".matrixTableContainer\")\n\n            var visHeight = windowHeight - ctx.textHeight - 70;\n\n//            ctx.foreignObject.attr({\n//                height: visHeight\n//            })\n//\n//            ctx.foreignDiv.style(\"height\", +(visHeight - ctx.textHeight) + \"px\")\n        } else if (windowHeight == null) {\n            ctx.svgBody.attr({\n                width: (Math.max(windowWidth, 400))\n            })\n            ctx.svgHeader.attr({\n                width: (Math.max(windowWidth, 400))\n            })\n\n\n\n            var totalWidthMax = ctx.cellWidth * usedSets.length + ctx.majorPadding + ctx.leftOffset\n                + ctx.subSetSizeWidthMax + ctx.expectedValueWidthMax + 50+ctx.summaryStatisticVis.length*(ctx.summaryStatisticsWidth+ctx.majorPadding);\n\n            ctx.subSetSizeWidth = d3.scale.linear()\n                .domain([totalWidthMax-(ctx.expectedValueWidthMax-100), totalWidthMax-(ctx.expectedValueWidthMax-100)-(ctx.subSetSizeWidthMax-100)]).range([ctx.subSetSizeWidthMax, 100]).clamp(true)(windowWidth);\n\n            ctx.expectedValueWidth = d3.scale.linear()\n                .domain([totalWidthMax, totalWidthMax-(ctx.expectedValueWidthMax-100)]).range([ctx.expectedValueWidthMax, 100]).clamp(true)(windowWidth);\n\n            ctx[\"brushableScaleSubsetUpdate\"](null, {\n                width: ctx.subSetSizeWidth\n            });\n        }\n    }\n\n    setUpSortSelections()\n    initData(ctx, [init], datasets);\n//    init();\n\n}\n"

/***/ })
/******/ ])
});
;
//# sourceMappingURL=UpSet.js.map